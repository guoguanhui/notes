<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>结构化命令 | WaleGarrett</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/notes/logo.jpg">
    <meta name="description" content="WaleGarrett的学习记录">
    
    <link rel="preload" href="/notes/assets/css/0.styles.54ab1000.css" as="style"><link rel="preload" href="/notes/assets/js/app.c9da24a6.js" as="script"><link rel="preload" href="/notes/assets/js/3.15042843.js" as="script"><link rel="preload" href="/notes/assets/js/1.8ca8e0eb.js" as="script"><link rel="preload" href="/notes/assets/js/70.430fd8cd.js" as="script"><link rel="prefetch" href="/notes/assets/js/10.1becd84f.js"><link rel="prefetch" href="/notes/assets/js/100.e686635a.js"><link rel="prefetch" href="/notes/assets/js/101.d90ba6a2.js"><link rel="prefetch" href="/notes/assets/js/102.37c9c783.js"><link rel="prefetch" href="/notes/assets/js/103.dec1797e.js"><link rel="prefetch" href="/notes/assets/js/104.9e4cdf99.js"><link rel="prefetch" href="/notes/assets/js/105.8616c171.js"><link rel="prefetch" href="/notes/assets/js/106.bc2f20eb.js"><link rel="prefetch" href="/notes/assets/js/107.4fc0003b.js"><link rel="prefetch" href="/notes/assets/js/108.f7ed7756.js"><link rel="prefetch" href="/notes/assets/js/109.867fe8d3.js"><link rel="prefetch" href="/notes/assets/js/11.11eeb9c8.js"><link rel="prefetch" href="/notes/assets/js/110.ce3c1db9.js"><link rel="prefetch" href="/notes/assets/js/111.5f88fd17.js"><link rel="prefetch" href="/notes/assets/js/112.0ec3be4a.js"><link rel="prefetch" href="/notes/assets/js/113.b17af37a.js"><link rel="prefetch" href="/notes/assets/js/114.c3bd0ee7.js"><link rel="prefetch" href="/notes/assets/js/115.e942f535.js"><link rel="prefetch" href="/notes/assets/js/116.a07fe354.js"><link rel="prefetch" href="/notes/assets/js/117.7f109010.js"><link rel="prefetch" href="/notes/assets/js/118.70cf9c49.js"><link rel="prefetch" href="/notes/assets/js/119.68965728.js"><link rel="prefetch" href="/notes/assets/js/12.e21b4812.js"><link rel="prefetch" href="/notes/assets/js/120.9065ed1d.js"><link rel="prefetch" href="/notes/assets/js/121.a8a35fe7.js"><link rel="prefetch" href="/notes/assets/js/122.70596256.js"><link rel="prefetch" href="/notes/assets/js/123.b9715cd7.js"><link rel="prefetch" href="/notes/assets/js/124.7345d826.js"><link rel="prefetch" href="/notes/assets/js/125.d4392f5d.js"><link rel="prefetch" href="/notes/assets/js/126.ff7fff9e.js"><link rel="prefetch" href="/notes/assets/js/127.acc1dff7.js"><link rel="prefetch" href="/notes/assets/js/128.81dcc7a3.js"><link rel="prefetch" href="/notes/assets/js/129.6c2d778a.js"><link rel="prefetch" href="/notes/assets/js/13.afb6371c.js"><link rel="prefetch" href="/notes/assets/js/130.1c463291.js"><link rel="prefetch" href="/notes/assets/js/131.fade390b.js"><link rel="prefetch" href="/notes/assets/js/132.a1fe16f6.js"><link rel="prefetch" href="/notes/assets/js/133.a719a028.js"><link rel="prefetch" href="/notes/assets/js/134.66c5c006.js"><link rel="prefetch" href="/notes/assets/js/135.5b78fa9f.js"><link rel="prefetch" href="/notes/assets/js/136.2e6405e5.js"><link rel="prefetch" href="/notes/assets/js/137.41fb8a7a.js"><link rel="prefetch" href="/notes/assets/js/138.06de929f.js"><link rel="prefetch" href="/notes/assets/js/139.2f7ab686.js"><link rel="prefetch" href="/notes/assets/js/14.a2175c4c.js"><link rel="prefetch" href="/notes/assets/js/140.6918a01b.js"><link rel="prefetch" href="/notes/assets/js/141.95f9f12a.js"><link rel="prefetch" href="/notes/assets/js/142.aa0cee93.js"><link rel="prefetch" href="/notes/assets/js/143.d60a38b0.js"><link rel="prefetch" href="/notes/assets/js/144.638c8e0a.js"><link rel="prefetch" href="/notes/assets/js/145.1a1685af.js"><link rel="prefetch" href="/notes/assets/js/146.bc665756.js"><link rel="prefetch" href="/notes/assets/js/147.809233d9.js"><link rel="prefetch" href="/notes/assets/js/148.d6b15e4e.js"><link rel="prefetch" href="/notes/assets/js/149.646dfac5.js"><link rel="prefetch" href="/notes/assets/js/15.7ec2be59.js"><link rel="prefetch" href="/notes/assets/js/150.64b53d63.js"><link rel="prefetch" href="/notes/assets/js/151.0984c27e.js"><link rel="prefetch" href="/notes/assets/js/152.42cf7076.js"><link rel="prefetch" href="/notes/assets/js/153.80ae1b86.js"><link rel="prefetch" href="/notes/assets/js/154.1b7e1514.js"><link rel="prefetch" href="/notes/assets/js/155.0a6c1fb7.js"><link rel="prefetch" href="/notes/assets/js/156.916e2a53.js"><link rel="prefetch" href="/notes/assets/js/157.8d361889.js"><link rel="prefetch" href="/notes/assets/js/158.858d71f6.js"><link rel="prefetch" href="/notes/assets/js/159.9a2f07f9.js"><link rel="prefetch" href="/notes/assets/js/16.679c7661.js"><link rel="prefetch" href="/notes/assets/js/160.4f54106a.js"><link rel="prefetch" href="/notes/assets/js/161.3cc67e9e.js"><link rel="prefetch" href="/notes/assets/js/162.c94a5be4.js"><link rel="prefetch" href="/notes/assets/js/163.dc11bf4c.js"><link rel="prefetch" href="/notes/assets/js/164.5f0bb30d.js"><link rel="prefetch" href="/notes/assets/js/165.17595a0b.js"><link rel="prefetch" href="/notes/assets/js/166.26cc364b.js"><link rel="prefetch" href="/notes/assets/js/167.a8b2ddf0.js"><link rel="prefetch" href="/notes/assets/js/168.17f43071.js"><link rel="prefetch" href="/notes/assets/js/169.d5e82e04.js"><link rel="prefetch" href="/notes/assets/js/17.016980ed.js"><link rel="prefetch" href="/notes/assets/js/170.11696f57.js"><link rel="prefetch" href="/notes/assets/js/171.70305f2f.js"><link rel="prefetch" href="/notes/assets/js/172.f4b63da4.js"><link rel="prefetch" href="/notes/assets/js/173.42057c95.js"><link rel="prefetch" href="/notes/assets/js/174.246a6e0b.js"><link rel="prefetch" href="/notes/assets/js/175.4855ab27.js"><link rel="prefetch" href="/notes/assets/js/176.d75790bd.js"><link rel="prefetch" href="/notes/assets/js/177.f616c3f5.js"><link rel="prefetch" href="/notes/assets/js/178.659b087d.js"><link rel="prefetch" href="/notes/assets/js/179.010eacce.js"><link rel="prefetch" href="/notes/assets/js/18.6f1dbb8f.js"><link rel="prefetch" href="/notes/assets/js/180.a11dd312.js"><link rel="prefetch" href="/notes/assets/js/181.c74fb0b6.js"><link rel="prefetch" href="/notes/assets/js/182.4f548539.js"><link rel="prefetch" href="/notes/assets/js/183.32dc4b08.js"><link rel="prefetch" href="/notes/assets/js/184.7b15f3e9.js"><link rel="prefetch" href="/notes/assets/js/185.ad484525.js"><link rel="prefetch" href="/notes/assets/js/186.db3693bc.js"><link rel="prefetch" href="/notes/assets/js/187.2a0df038.js"><link rel="prefetch" href="/notes/assets/js/188.987a82c9.js"><link rel="prefetch" href="/notes/assets/js/189.c693f3a1.js"><link rel="prefetch" href="/notes/assets/js/19.9e1eac04.js"><link rel="prefetch" href="/notes/assets/js/190.2e253fc8.js"><link rel="prefetch" href="/notes/assets/js/191.d70ee914.js"><link rel="prefetch" href="/notes/assets/js/192.4f808c44.js"><link rel="prefetch" href="/notes/assets/js/193.133fd0a8.js"><link rel="prefetch" href="/notes/assets/js/194.c1c26af9.js"><link rel="prefetch" href="/notes/assets/js/195.5d112624.js"><link rel="prefetch" href="/notes/assets/js/196.e756a155.js"><link rel="prefetch" href="/notes/assets/js/197.6f9b8105.js"><link rel="prefetch" href="/notes/assets/js/198.3c59ba72.js"><link rel="prefetch" href="/notes/assets/js/199.15e2d96e.js"><link rel="prefetch" href="/notes/assets/js/20.e41f5564.js"><link rel="prefetch" href="/notes/assets/js/200.992db7f7.js"><link rel="prefetch" href="/notes/assets/js/201.9c266b22.js"><link rel="prefetch" href="/notes/assets/js/202.842ef603.js"><link rel="prefetch" href="/notes/assets/js/203.01bca3f3.js"><link rel="prefetch" href="/notes/assets/js/204.f9c2a70d.js"><link rel="prefetch" href="/notes/assets/js/205.f9268403.js"><link rel="prefetch" href="/notes/assets/js/206.4cf08b44.js"><link rel="prefetch" href="/notes/assets/js/207.0ef45ecc.js"><link rel="prefetch" href="/notes/assets/js/208.0ac3b838.js"><link rel="prefetch" href="/notes/assets/js/209.5e055156.js"><link rel="prefetch" href="/notes/assets/js/21.2d865954.js"><link rel="prefetch" href="/notes/assets/js/210.d8204d91.js"><link rel="prefetch" href="/notes/assets/js/211.acc0168d.js"><link rel="prefetch" href="/notes/assets/js/212.5eec4fbf.js"><link rel="prefetch" href="/notes/assets/js/213.272bf6e6.js"><link rel="prefetch" href="/notes/assets/js/214.bf006247.js"><link rel="prefetch" href="/notes/assets/js/215.f11c4fd7.js"><link rel="prefetch" href="/notes/assets/js/216.cf94ea1b.js"><link rel="prefetch" href="/notes/assets/js/217.330e075c.js"><link rel="prefetch" href="/notes/assets/js/218.0b9e982c.js"><link rel="prefetch" href="/notes/assets/js/219.7e778a76.js"><link rel="prefetch" href="/notes/assets/js/22.88dd9e53.js"><link rel="prefetch" href="/notes/assets/js/220.6d5ffbc6.js"><link rel="prefetch" href="/notes/assets/js/221.bac51660.js"><link rel="prefetch" href="/notes/assets/js/23.a8a4e106.js"><link rel="prefetch" href="/notes/assets/js/24.6a7395f6.js"><link rel="prefetch" href="/notes/assets/js/25.3e79ff45.js"><link rel="prefetch" href="/notes/assets/js/26.33e76c58.js"><link rel="prefetch" href="/notes/assets/js/27.2e20fce9.js"><link rel="prefetch" href="/notes/assets/js/28.92202fbe.js"><link rel="prefetch" href="/notes/assets/js/29.31e72924.js"><link rel="prefetch" href="/notes/assets/js/30.63118840.js"><link rel="prefetch" href="/notes/assets/js/31.40bb3db2.js"><link rel="prefetch" href="/notes/assets/js/32.34771f12.js"><link rel="prefetch" href="/notes/assets/js/33.12f2bfaf.js"><link rel="prefetch" href="/notes/assets/js/34.0685ab4b.js"><link rel="prefetch" href="/notes/assets/js/35.497cff30.js"><link rel="prefetch" href="/notes/assets/js/36.1f5c1fc2.js"><link rel="prefetch" href="/notes/assets/js/37.bd6b811a.js"><link rel="prefetch" href="/notes/assets/js/38.a7a23117.js"><link rel="prefetch" href="/notes/assets/js/39.cdf8ca3c.js"><link rel="prefetch" href="/notes/assets/js/4.0716db17.js"><link rel="prefetch" href="/notes/assets/js/40.21388ef8.js"><link rel="prefetch" href="/notes/assets/js/41.ee9dc436.js"><link rel="prefetch" href="/notes/assets/js/42.a3ec0597.js"><link rel="prefetch" href="/notes/assets/js/43.be5d9816.js"><link rel="prefetch" href="/notes/assets/js/44.2f99673b.js"><link rel="prefetch" href="/notes/assets/js/45.c443ff93.js"><link rel="prefetch" href="/notes/assets/js/46.bd004ac4.js"><link rel="prefetch" href="/notes/assets/js/47.20add895.js"><link rel="prefetch" href="/notes/assets/js/48.1c5da96b.js"><link rel="prefetch" href="/notes/assets/js/49.31c7e29d.js"><link rel="prefetch" href="/notes/assets/js/5.03d74ef1.js"><link rel="prefetch" href="/notes/assets/js/50.b48ca783.js"><link rel="prefetch" href="/notes/assets/js/51.b4bc061c.js"><link rel="prefetch" href="/notes/assets/js/52.77dc2135.js"><link rel="prefetch" href="/notes/assets/js/53.3fc2d110.js"><link rel="prefetch" href="/notes/assets/js/54.ab331494.js"><link rel="prefetch" href="/notes/assets/js/55.59fa9d3a.js"><link rel="prefetch" href="/notes/assets/js/56.6864911d.js"><link rel="prefetch" href="/notes/assets/js/57.44dbdabe.js"><link rel="prefetch" href="/notes/assets/js/58.516ab1c4.js"><link rel="prefetch" href="/notes/assets/js/59.56d4d38d.js"><link rel="prefetch" href="/notes/assets/js/6.c1d1ac7a.js"><link rel="prefetch" href="/notes/assets/js/60.9038d0d8.js"><link rel="prefetch" href="/notes/assets/js/61.d5696bbd.js"><link rel="prefetch" href="/notes/assets/js/62.59b5f172.js"><link rel="prefetch" href="/notes/assets/js/63.e9c7508b.js"><link rel="prefetch" href="/notes/assets/js/64.4241a14e.js"><link rel="prefetch" href="/notes/assets/js/65.91a07396.js"><link rel="prefetch" href="/notes/assets/js/66.b82f5c7e.js"><link rel="prefetch" href="/notes/assets/js/67.afcaae6c.js"><link rel="prefetch" href="/notes/assets/js/68.d4eb82fd.js"><link rel="prefetch" href="/notes/assets/js/69.a4267fbd.js"><link rel="prefetch" href="/notes/assets/js/7.8e24ac99.js"><link rel="prefetch" href="/notes/assets/js/71.1016e8c6.js"><link rel="prefetch" href="/notes/assets/js/72.9ec57099.js"><link rel="prefetch" href="/notes/assets/js/73.20c4449a.js"><link rel="prefetch" href="/notes/assets/js/74.39b9604e.js"><link rel="prefetch" href="/notes/assets/js/75.4f09e706.js"><link rel="prefetch" href="/notes/assets/js/76.88ffa9c5.js"><link rel="prefetch" href="/notes/assets/js/77.eec6caf8.js"><link rel="prefetch" href="/notes/assets/js/78.166b5a56.js"><link rel="prefetch" href="/notes/assets/js/79.ef2af5da.js"><link rel="prefetch" href="/notes/assets/js/8.00d48dd8.js"><link rel="prefetch" href="/notes/assets/js/80.c0eb3a50.js"><link rel="prefetch" href="/notes/assets/js/81.21ed8523.js"><link rel="prefetch" href="/notes/assets/js/82.a7717793.js"><link rel="prefetch" href="/notes/assets/js/83.cb39ac8d.js"><link rel="prefetch" href="/notes/assets/js/84.3a0c34dc.js"><link rel="prefetch" href="/notes/assets/js/85.379f9075.js"><link rel="prefetch" href="/notes/assets/js/86.500344a3.js"><link rel="prefetch" href="/notes/assets/js/87.a52c8c96.js"><link rel="prefetch" href="/notes/assets/js/88.d14778d2.js"><link rel="prefetch" href="/notes/assets/js/89.ca52efc6.js"><link rel="prefetch" href="/notes/assets/js/9.5b519f35.js"><link rel="prefetch" href="/notes/assets/js/90.8529f3f5.js"><link rel="prefetch" href="/notes/assets/js/91.65963b3b.js"><link rel="prefetch" href="/notes/assets/js/92.041432c3.js"><link rel="prefetch" href="/notes/assets/js/93.d97cc1eb.js"><link rel="prefetch" href="/notes/assets/js/94.4c8de3b2.js"><link rel="prefetch" href="/notes/assets/js/95.81ea24d1.js"><link rel="prefetch" href="/notes/assets/js/96.4190ea57.js"><link rel="prefetch" href="/notes/assets/js/97.a72a27df.js"><link rel="prefetch" href="/notes/assets/js/98.504f98ad.js"><link rel="prefetch" href="/notes/assets/js/99.1da9035d.js">
    <link rel="stylesheet" href="/notes/assets/css/0.styles.54ab1000.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-130b300a><div data-v-130b300a><div class="password-shadow password-wrapper-out" style="display:none;" data-v-25ba6db2 data-v-130b300a data-v-130b300a><h3 class="title" data-v-25ba6db2 data-v-25ba6db2>WaleGarrett</h3> <p class="description" data-v-25ba6db2 data-v-25ba6db2>WaleGarrett的学习记录</p> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><!---->
            
          <!---->
          2022
        </a></span></div></div> <div class="hide" data-v-130b300a><header class="navbar" data-v-130b300a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/notes/" class="home-link router-link-active"><img src="/notes/logo.jpg" alt="WaleGarrett" class="logo"> <span class="site-name">WaleGarrett</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/notes/" class="nav-link"><i class="undefined"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      Java
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>JavaSE</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/blog/Java/JavaSE/" class="nav-link"><i class="undefined"></i>
  JavaSE基础
</a></li></ul></li><li class="dropdown-item"><h4>Java IO</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/blog/Java/Java IO/" class="nav-link"><i class="undefined"></i>
  Java IO
</a></li></ul></li><li class="dropdown-item"><h4>Java容器</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/blog/Java/Java容器/" class="nav-link"><i class="undefined"></i>
  Java容器
</a></li></ul></li><li class="dropdown-item"><h4>Java并发</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/blog/多线程与并发/" class="nav-link"><i class="undefined"></i>
  多线程与并发
</a></li></ul></li><li class="dropdown-item"><h4>JVM</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/blog/JVM/Java运行时内存区.html" class="nav-link"><i class="undefined"></i>
  Java运行时内存区
</a></li><li class="dropdown-subitem"><a href="/notes/blog/JVM/Java内存模型.html" class="nav-link"><i class="undefined"></i>
  Java内存模型
</a></li><li class="dropdown-subitem"><a href="/notes/blog/JVM/类加载.html" class="nav-link"><i class="undefined"></i>
  类加载
</a></li><li class="dropdown-subitem"><a href="/notes/blog/JVM/程序编译.html" class="nav-link"><i class="undefined"></i>
  程序编译
</a></li><li class="dropdown-subitem"><a href="/notes/blog/JVM/虚拟机对象.html" class="nav-link"><i class="undefined"></i>
  虚拟机对象
</a></li><li class="dropdown-subitem"><a href="/notes/blog/JVM/垃圾收集/" class="nav-link"><i class="undefined"></i>
  垃圾收集
</a></li><li class="dropdown-subitem"><a href="/notes/blog/JVM/JVM调优.html" class="nav-link"><i class="undefined"></i>
  JVM调优
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      Spring系列
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/blog/Spring系列/Spring/" class="nav-link"><i class="undefined"></i>
  Spring
</a></li><li class="dropdown-item"><!----> <a href="/notes/blog/Spring系列/Spring MVC/" class="nav-link"><i class="undefined"></i>
  Spring MVC
</a></li><li class="dropdown-item"><!----> <a href="/notes/blog/Spring系列/Spring Boot/" class="nav-link"><i class="undefined"></i>
  Spring Boot
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      计算机基础
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>操作系统</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/blog/操作系统/" class="nav-link"><i class="undefined"></i>
  操作系统知识体系
</a></li></ul></li><li class="dropdown-item"><h4>计算机网络</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/blog/计算机网络/" class="nav-link"><i class="undefined"></i>
  计算机网络知识体系
</a></li></ul></li><li class="dropdown-item"><h4>数据结构</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/blog/数据结构/" class="nav-link"><i class="undefined"></i>
  数据结构知识体系
</a></li></ul></li><li class="dropdown-item"><h4>数据库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/blog/数据库/数据库基础/" class="nav-link"><i class="undefined"></i>
  数据库基础
</a></li><li class="dropdown-subitem"><a href="/notes/blog/数据库/MySQL/" class="nav-link"><i class="undefined"></i>
  MySQL
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      linux
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/blog/linux/linux命令/" class="nav-link"><i class="undefined"></i>
  linux命令
</a></li><li class="dropdown-item"><!----> <a href="/notes/blog/linux/脚本编程/" class="nav-link"><i class="undefined"></i>
  脚本编程
</a></li><li class="dropdown-item"><!----> <a href="/notes/blog/linux/linux内存管理/" class="nav-link"><i class="undefined"></i>
  linux内存管理
</a></li><li class="dropdown-item"><!----> <a href="/notes/blog/linux/linux文件系统/" class="nav-link"><i class="undefined"></i>
  linux文件系统
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      开发
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/blog/设计模式/" class="nav-link"><i class="undefined"></i>
  设计模式
</a></li><li class="dropdown-item"><!----> <a href="/notes/blog/开发工具/git/git基础知识.html" class="nav-link"><i class="undefined"></i>
  git
</a></li><li class="dropdown-item"><!----> <a href="/notes/blog/开发工具/maven/maven基础知识.html" class="nav-link"><i class="undefined"></i>
  maven
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      中间件
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/blog/中间件/redis/" class="nav-link"><i class="undefined"></i>
  redis
</a></li><li class="dropdown-item"><!----> <a href="/notes/blog/中间件/kafka/" class="nav-link"><i class="undefined"></i>
  kafka
</a></li><li class="dropdown-item"><!----> <a href="/notes/blog/中间件/HBase/" class="nav-link"><i class="undefined"></i>
  HBase
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      框架
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>ORM框架</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/blog/数据库/MyBatis/" class="nav-link"><i class="undefined"></i>
  MyBatis框架
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      架构
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/blog/架构/" class="nav-link"><i class="undefined"></i>
  系统架构
</a></li><li class="dropdown-item"><!----> <a href="/notes/blog/分布式/" class="nav-link"><i class="undefined"></i>
  分布式
</a></li></ul></div></div><div class="nav-item"><a href="https://www.cnblogs.com/GarrettWale/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  博客文章
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-130b300a></div> <aside class="sidebar" data-v-130b300a><div class="personal-info-wrapper" data-v-39576ba9 data-v-130b300a><!----> <!----> <div class="num" data-v-39576ba9><div data-v-39576ba9><h3 data-v-39576ba9>211</h3> <h6 data-v-39576ba9>Articles</h6></div> <div data-v-39576ba9><h3 data-v-39576ba9>106</h3> <h6 data-v-39576ba9>Tags</h6></div></div> <ul class="social-links" data-v-39576ba9></ul> <hr data-v-39576ba9></div> <nav class="nav-links"><div class="nav-item"><a href="/notes/" class="nav-link"><i class="undefined"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      Java
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>JavaSE</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/blog/Java/JavaSE/" class="nav-link"><i class="undefined"></i>
  JavaSE基础
</a></li></ul></li><li class="dropdown-item"><h4>Java IO</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/blog/Java/Java IO/" class="nav-link"><i class="undefined"></i>
  Java IO
</a></li></ul></li><li class="dropdown-item"><h4>Java容器</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/blog/Java/Java容器/" class="nav-link"><i class="undefined"></i>
  Java容器
</a></li></ul></li><li class="dropdown-item"><h4>Java并发</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/blog/多线程与并发/" class="nav-link"><i class="undefined"></i>
  多线程与并发
</a></li></ul></li><li class="dropdown-item"><h4>JVM</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/blog/JVM/Java运行时内存区.html" class="nav-link"><i class="undefined"></i>
  Java运行时内存区
</a></li><li class="dropdown-subitem"><a href="/notes/blog/JVM/Java内存模型.html" class="nav-link"><i class="undefined"></i>
  Java内存模型
</a></li><li class="dropdown-subitem"><a href="/notes/blog/JVM/类加载.html" class="nav-link"><i class="undefined"></i>
  类加载
</a></li><li class="dropdown-subitem"><a href="/notes/blog/JVM/程序编译.html" class="nav-link"><i class="undefined"></i>
  程序编译
</a></li><li class="dropdown-subitem"><a href="/notes/blog/JVM/虚拟机对象.html" class="nav-link"><i class="undefined"></i>
  虚拟机对象
</a></li><li class="dropdown-subitem"><a href="/notes/blog/JVM/垃圾收集/" class="nav-link"><i class="undefined"></i>
  垃圾收集
</a></li><li class="dropdown-subitem"><a href="/notes/blog/JVM/JVM调优.html" class="nav-link"><i class="undefined"></i>
  JVM调优
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      Spring系列
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/blog/Spring系列/Spring/" class="nav-link"><i class="undefined"></i>
  Spring
</a></li><li class="dropdown-item"><!----> <a href="/notes/blog/Spring系列/Spring MVC/" class="nav-link"><i class="undefined"></i>
  Spring MVC
</a></li><li class="dropdown-item"><!----> <a href="/notes/blog/Spring系列/Spring Boot/" class="nav-link"><i class="undefined"></i>
  Spring Boot
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      计算机基础
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>操作系统</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/blog/操作系统/" class="nav-link"><i class="undefined"></i>
  操作系统知识体系
</a></li></ul></li><li class="dropdown-item"><h4>计算机网络</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/blog/计算机网络/" class="nav-link"><i class="undefined"></i>
  计算机网络知识体系
</a></li></ul></li><li class="dropdown-item"><h4>数据结构</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/blog/数据结构/" class="nav-link"><i class="undefined"></i>
  数据结构知识体系
</a></li></ul></li><li class="dropdown-item"><h4>数据库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/blog/数据库/数据库基础/" class="nav-link"><i class="undefined"></i>
  数据库基础
</a></li><li class="dropdown-subitem"><a href="/notes/blog/数据库/MySQL/" class="nav-link"><i class="undefined"></i>
  MySQL
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      linux
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/blog/linux/linux命令/" class="nav-link"><i class="undefined"></i>
  linux命令
</a></li><li class="dropdown-item"><!----> <a href="/notes/blog/linux/脚本编程/" class="nav-link"><i class="undefined"></i>
  脚本编程
</a></li><li class="dropdown-item"><!----> <a href="/notes/blog/linux/linux内存管理/" class="nav-link"><i class="undefined"></i>
  linux内存管理
</a></li><li class="dropdown-item"><!----> <a href="/notes/blog/linux/linux文件系统/" class="nav-link"><i class="undefined"></i>
  linux文件系统
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      开发
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/blog/设计模式/" class="nav-link"><i class="undefined"></i>
  设计模式
</a></li><li class="dropdown-item"><!----> <a href="/notes/blog/开发工具/git/git基础知识.html" class="nav-link"><i class="undefined"></i>
  git
</a></li><li class="dropdown-item"><!----> <a href="/notes/blog/开发工具/maven/maven基础知识.html" class="nav-link"><i class="undefined"></i>
  maven
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      中间件
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/blog/中间件/redis/" class="nav-link"><i class="undefined"></i>
  redis
</a></li><li class="dropdown-item"><!----> <a href="/notes/blog/中间件/kafka/" class="nav-link"><i class="undefined"></i>
  kafka
</a></li><li class="dropdown-item"><!----> <a href="/notes/blog/中间件/HBase/" class="nav-link"><i class="undefined"></i>
  HBase
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      框架
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>ORM框架</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/notes/blog/数据库/MyBatis/" class="nav-link"><i class="undefined"></i>
  MyBatis框架
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      架构
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/blog/架构/" class="nav-link"><i class="undefined"></i>
  系统架构
</a></li><li class="dropdown-item"><!----> <a href="/notes/blog/分布式/" class="nav-link"><i class="undefined"></i>
  分布式
</a></li></ul></div></div><div class="nav-item"><a href="https://www.cnblogs.com/GarrettWale/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  博客文章
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>linux</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/notes/blog/linux/linux命令/" class="sidebar-heading clickable"><span>linux命令</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/notes/blog/linux/linux内存管理/" class="sidebar-heading clickable"><span>linux内存管理</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/notes/blog/linux/linux文件系统/" class="sidebar-heading clickable"><span>linux文件系统</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/notes/blog/linux/脚本编程/" class="sidebar-heading clickable open"><span>脚本编程</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/blog/linux/脚本编程/脚本编程基础.html" class="sidebar-link">脚本编程基础</a></li><li><a href="/notes/blog/linux/脚本编程/处理输入.html" class="sidebar-link">处理输入</a></li><li><a href="/notes/blog/linux/脚本编程/处理输出.html" class="sidebar-link">处理输出</a></li><li><a href="/notes/blog/linux/脚本编程/结构化命令.html" class="active sidebar-link">结构化命令</a></li><li><a href="/notes/blog/linux/脚本编程/函数.html" class="sidebar-link">函数</a></li><li><a href="/notes/blog/linux/脚本编程/sed与gawk.html" class="sidebar-link">sed与gawk</a></li></ul></section></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-25ba6db2 data-v-130b300a><h3 class="title" data-v-25ba6db2 data-v-25ba6db2>结构化命令</h3> <!----> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><!---->
            
          <!---->
          2022
        </a></span></div></div> <div data-v-130b300a><main class="page"><section><div class="page-title"><h1 class="title">结构化命令</h1> <div data-v-f875f3fc><!----> <i class="iconfont reco-date" data-v-f875f3fc><span data-v-f875f3fc>4/1/2022</span></i> <!----> <i class="tags iconfont reco-tag" data-v-f875f3fc><span class="tag-item" data-v-f875f3fc>linux</span><span class="tag-item" data-v-f875f3fc>shell</span></i></div></div> <div class="theme-reco-content content__default"><p>上一章给出的那些 shell 脚本里，shell 按照命令在脚本中出现的顺序依次进行处理。对顺序操作来说，这已经足够了，因为在这种操作环境下，你想要的就是所有的命令按照正确的顺序执行。然而，并非所有程序都如此操作。</p> <p>许多程序要求对 shell 脚本中的命令施加一些逻辑流程控制。有一类命令会根据条件使脚本跳过某些命令。这样的命令通常称为<code>结构化命令</code>（structured command）。</p> <p>结构化命令允许你改变程序执行的顺序。在 bash shell 中有不少结构化命令，我们会逐个研究。</p> <h2 id="if-语句"><a href="#if-语句" class="header-anchor">#</a> if 语句</h2> <p>最基本的结构化命令就是 if-then 语句。if-then 语句有如下格式。</p> <p>if <em>command</em><br>
then<br> <em>commands</em><br>
fi</p> <p>如果你在用其他编程语言的 if-then 语句，这种形式可能会让你有点困惑。在其他编程语言中，if 语句之后的对象是一个等式，这个等式的求值结果为 TRUE 或 FALSE。但 bash shell 的 if 语句并不是这么做的。</p> <p>bash shell 的 <strong>==if 语句会运行 if 后面的那个命令。如果该命令的退出状态码是 0（该命令成功运行），位于 then 部分的命令就会被执行。如果该命令的退出状态码是其他值，then 部分的命令就不会被执行，bash shell 会继续执行脚本中的下一个命令==</strong>。fi 语句用来表示 if-then 语句到此结束。</p> <p>这里有个简单的例子可解释这个概念。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test1.sh
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># testing the if statement</span>
<span class="token keyword">if</span> <span class="token builtin class-name">pwd</span>
<span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;It worked&quot;</span>
<span class="token keyword">fi</span>
$
</code></pre></div><p>这个脚本在 if 行采用了 pwd 命令。如果命令成功结束，echo 语句就会显示该文本字符串。在命令行运行该脚本时，会得到如下结果。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ ./test1.sh
/home/Christine
It worked
$
</code></pre></div><p>shell 执行了 if 行中的 pwd 命令。由于退出状态码是 0，它就又执行了 then 部分的 echo 语句。</p> <p>你可能在有些脚本中看到过 if-then 语句的另一种形式：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">if</span> <span class="token builtin class-name">command</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    commands
<span class="token keyword">fi</span>
</code></pre></div><p><strong>通过把分号放在待求值的命令尾部，就可以将 then 语句放在同一行上了，这样看起来更像其他编程语言中的 if-then 语句</strong>。</p> <p>在 then 部分，你可以使用不止一条命令。可以像在脚本中的其他地方一样在这里列出多条命令。bash shell 会将这些命令当成一个块，如果 if 语句行的命令的退出状态值为 0，所有的命令都会被执行；如果 if 语句行的命令的退出状态不为 0，所有的命令都会被跳过。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test3.sh
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># testing multiple commands in the then section</span>
<span class="token comment">#</span>
<span class="token assign-left variable">testuser</span><span class="token operator">=</span>Christine
<span class="token comment">#</span>
<span class="token keyword">if</span> <span class="token function">grep</span> <span class="token variable">$testuser</span> /etc/passwd<span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;This is my first command&quot;</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;This is my second command&quot;</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;I can even put in other commands besides echo:&quot;</span>
    <span class="token function">ls</span> -a /home/<span class="token variable">$testuser</span>/.b*
<span class="token keyword">fi</span>
$
</code></pre></div><p>if 语句行使用 grep 命令在/etc/passwd 文件中查找某个用户名当前是否在系统上使用。如果有用户使用了那个登录名，脚本会显示一些文本信息并列出该用户 HOME 目录的 bash 文件。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ ./test3.sh
Christine:x:501:501:Christine B:/home/Christine:/bin/bash
This is my first <span class="token builtin class-name">command</span>
This is my second <span class="token builtin class-name">command</span>
I can even put <span class="token keyword">in</span> other commands besides echo:
/home/Christine/.bash_history  /home/Christine/.bash_profile
/home/Christine/.bash_logout   /home/Christine/.bashrc
$
</code></pre></div><p>但是，如果将 testuser 变量设置成一个系统上不存在的用户，则什么都不会显示。看起来也没什么新鲜的。如果在这里显示的一些消息可说明这个用户名在系统中未找到，这样可能就会显得更友好。此时可以用 if-then-else 语句来做到这一点。当 if 语句中的命令返回非零退出状态码时，bash shell 会执行 else 部分中的命令。现在可以复制并修改测试脚本来加入 else 部分。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cp</span> test3.sh test4.sh
$
$ <span class="token function">vim</span> test4.sh
$
$ <span class="token function">cat</span> test4.sh
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># testing the else section</span>
<span class="token comment">#</span>
<span class="token assign-left variable">testuser</span><span class="token operator">=</span>NoSuchUser
<span class="token comment">#</span>
<span class="token keyword">if</span> <span class="token function">grep</span> <span class="token variable">$testuser</span> /etc/passwd
<span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;The bash files for user <span class="token variable">$testuser</span> are:&quot;</span>
    <span class="token function">ls</span> -a /home/<span class="token variable">$testuser</span>/.b*
    <span class="token builtin class-name">echo</span>
<span class="token keyword">else</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;The user <span class="token variable">$testuser</span> does not exist on this system.&quot;</span>
    <span class="token builtin class-name">echo</span>
<span class="token keyword">fi</span>
$
$ ./test4.sh
The user NoSuchUser does not exist on this system.
$
</code></pre></div><p>这样就更友好了。跟 then 部分一样，else 部分也可以包含多条命令。</p> <h2 id="嵌套-if"><a href="#嵌套-if" class="header-anchor">#</a> 嵌套 if</h2> <p>有时你需要检查脚本代码中的多种条件。对此，可以使用嵌套的 if-then 语句。</p> <p>要检查/etc/passwd 文件中是否存在某个用户名以及该用户的目录是否尚在，可以使用嵌套的 if-then 语句。嵌套的 if-then 语句位于主 if-then-else 语句的 else 代码块中。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">ls</span> -d /home/NoSuchUser/
/home/NoSuchUser/
$
$ <span class="token function">cat</span> test5.sh
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># Testing nested ifs</span>
<span class="token comment">#</span>
<span class="token assign-left variable">testuser</span><span class="token operator">=</span>NoSuchUser
<span class="token comment">#</span>
<span class="token keyword">if</span> <span class="token function">grep</span> <span class="token variable">$testuser</span> /etc/passwd
<span class="token keyword">then</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;The user <span class="token variable">$testuser</span> exists on this system.&quot;</span>
<span class="token keyword">else</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;The user <span class="token variable">$testuser</span> does not exist on this system.&quot;</span>
    <span class="token keyword">if</span> <span class="token function">ls</span> -d /home/<span class="token variable">$testuser</span>/
    <span class="token keyword">then</span>
        <span class="token builtin class-name">echo</span> <span class="token string">&quot;However, <span class="token variable">$testuser</span> has a directory.&quot;</span>
    <span class="token keyword">fi</span>
<span class="token keyword">fi</span>
$
$ ./test5.sh
The user NoSuchUser does not exist on this system.
/home/NoSuchUser/
However, NoSuchUser has a directory.
$
</code></pre></div><p>这个脚本准确无误地发现，尽管登录名已经从/etc/passwd 中删除了，但是该用户的目录仍然存在。在脚本中使用这种嵌套 if-then 语句的问题在于代码不易阅读，很难理清逻辑流程。</p> <p>可以使用 else 部分的另一种形式：elif。这样就不用再书写多个 if-then 语句了。elif 使用另一个 if-then 语句延续 else 部分。elif 语句行提供了另一个要测试的命令，这类似于原始的 if 语句行。如果 elif 后命令的退出状态码是 0，则 bash 会执行第二个 then 语句部分的命令。使用这种嵌套方法，代码更清晰，逻辑更易懂。甚至可以更进一步，让脚本检查拥有目录的不存在用户以及没有拥有目录的不存在用户。这可以通过在嵌套 elif 中加入一个 else 语句来实现。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test5.sh
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># Testing nested ifs - use elif &amp; else</span>
<span class="token comment">#</span>
<span class="token assign-left variable">testuser</span><span class="token operator">=</span>NoSuchUser
<span class="token comment">#</span>
<span class="token keyword">if</span> <span class="token function">grep</span> <span class="token variable">$testuser</span> /etc/passwd
<span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;The user <span class="token variable">$testuser</span> exists on this system.&quot;</span>
<span class="token comment">#</span>
<span class="token keyword">elif</span> <span class="token function">ls</span> -d /home/<span class="token variable">$testuser</span>
<span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;The user <span class="token variable">$testuser</span> does not exist on this system.&quot;</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;However, <span class="token variable">$testuser</span> has a directory.&quot;</span>
<span class="token comment">#</span>
<span class="token keyword">else</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;The user <span class="token variable">$testuser</span> does not exist on this system.&quot;</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;And, <span class="token variable">$testuser</span> does not have a directory.&quot;</span>
<span class="token keyword">fi</span>
$
$ ./test5.sh
/home/NoSuchUser
The user NoSuchUser does not exist on this system.
However, NoSuchUser has a directory.
$
$ <span class="token function">sudo</span> <span class="token function">rmdir</span> /home/NoSuchUser
<span class="token punctuation">[</span>sudo<span class="token punctuation">]</span> password <span class="token keyword">for</span> Christine:
$
$ ./test5.sh
ls: cannot access /home/NoSuchUser: No such <span class="token function">file</span> or directory
The user NoSuchUser does not exist on this system.
And, NoSuchUser does not have a directory.
$
</code></pre></div><p>在/home/NoSuchUser 目录被删除之前，这个测试脚本执行的是 elif 语句，返回零值的退出状态。因此 elif 的 then 代码块中的语句得以执行。删除了/home/NoSuchUser 目录之后，elif 语句返回的是非零值的退出状态。这使得 elif 块中的 else 代码块得以执行。</p> <blockquote><p><strong>记住，在 elif 语句中，紧跟其后的 else 语句属于 elif 代码块。它们并不属于之前的 if-then 代码块。</strong></p></blockquote> <p>可以继续将多个 elif 语句串起来，形成一个大的 if-then-elif 嵌套组合。每块命令都会根据命令是否会返回退出状态码 0 来执行。记住，bash shell 会依次执行 if 语句，只有第一个返回退出状态码 0 的语句中的 then 部分会被执行。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">if</span> command1
<span class="token keyword">then</span>
    <span class="token builtin class-name">command</span> <span class="token builtin class-name">set</span> <span class="token number">1</span>
<span class="token keyword">elif</span> command2
<span class="token keyword">then</span>
    <span class="token builtin class-name">command</span> <span class="token builtin class-name">set</span> <span class="token number">2</span>
<span class="token keyword">elif</span> command3
<span class="token keyword">then</span>
    <span class="token builtin class-name">command</span> <span class="token builtin class-name">set</span> <span class="token number">3</span>
<span class="token keyword">elif</span> command4
<span class="token keyword">then</span>
    <span class="token builtin class-name">command</span> <span class="token builtin class-name">set</span> <span class="token number">4</span>
<span class="token keyword">fi</span>
</code></pre></div><p>尽管使用了 elif 语句的代码看起来更清晰，但是脚本的逻辑仍然会让人犯晕。在本章稍后你会看到如何使用 case 命令代替 if-then 语句的大量嵌套。</p> <h2 id="test-命令"><a href="#test-命令" class="header-anchor">#</a> test 命令</h2> <p>到目前为止，在 if 语句中看到的都是普通 shell 命令。你可能想问，if-then 语句是否能直接测试命令退出状态码之外的条件。</p> <p>答案是不能。但在 bash shell 中有个好用的工具可以帮你通过 if-then 语句测试其他条件。</p> <p>test 命令提供了在 if-then 语句中测试不同条件的途径。如果 test 命令中列出的条件成立，test 命令就会退出并返回退出状态码 0。这样 if-then 语句就与其他编程语言中的 if-then 语句以类似的方式工作了。如果条件不成立，test 命令就会退出并返回非零的退出状态码，这使得 if-then 语句不会再被执行。</p> <p>如果只执行 test 命令本身，不写 test 命令的条件部分，它会以非零的退出状态码退出，并执行 else 语句块。当你加入一个条件时，test 命令会测试该条件。例如，可以使用 test 命令确定变量中是否有内容。这只需要一个简单的条件表达式。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test6.sh
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># Testing the test command</span>
<span class="token comment">#</span>
<span class="token assign-left variable">my_variable</span><span class="token operator">=</span><span class="token string">&quot;Full&quot;</span>
<span class="token comment">#</span>
<span class="token keyword">if</span> <span class="token builtin class-name">test</span> <span class="token variable">$my_variable</span>
<span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;The <span class="token variable">$my_variable</span> expression returns a True&quot;</span>
<span class="token comment">#</span>
<span class="token keyword">else</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;The <span class="token variable">$my_variable</span> expression returns a False&quot;</span>
<span class="token keyword">fi</span>
$
$ ./test6.sh
The Full expression returns a True
$
</code></pre></div><p>变量 my_variable 中包含有内容（Full），因此当 test 命令测试条件时，返回的退出状态为 0。这使得 then 语句块中的语句得以执行。如你所料，如果该变量中没有包含内容，就会出现相反的情况。</p> <p><strong>==bash shell 提供了另一种条件测试方法，无需在 if-then 语句中声明 test 命令。==</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">if</span> <span class="token punctuation">[</span> condition <span class="token punctuation">]</span>
<span class="token keyword">then</span>
    commands
<span class="token keyword">fi</span>
</code></pre></div><p>方括号定义了测试条件，是与 test 命令同义的特殊 bash 命令。<strong>==注意，第一个方括号之后和第二个方括号之前必须加上一个空格，否则就会报错。==</strong></p> <p>test 命令可以判断三类条件：</p> <ul><li>数值比较</li> <li>字符串比较</li> <li>文件比较</li></ul> <p>接下来将会介绍如何在 if-then 语句中使用这些条件测试。</p> <h3 id="数值比较"><a href="#数值比较" class="header-anchor">#</a> 数值比较</h3> <p>使用 test 命令最常见的情形是对两个数值进行比较。如下列出了测试两个值时可用的条件参数。</p> <ul><li>n1 -eq n2 检查 n1 是否与 n2 相等</li> <li>n1 -ge n2 检查 n1 是否大于或等于 n2</li> <li>n1 -gt n2 检查 n1 是否大于 n2</li> <li>n1 -le n2 检查 n1 是否小于或等于 n2</li> <li>n1 -lt n2 检查 n1 是否小于 n2</li> <li>n1 -ne n2 检查 n1 是否不等于 n2</li></ul> <p>数值条件测试可以用在数字和变量上。这里有个例子。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> numeric_test.sh
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># Using numeric test evaluations</span>
<span class="token comment">#</span>
<span class="token assign-left variable">value1</span><span class="token operator">=</span><span class="token number">10</span>
<span class="token assign-left variable">value2</span><span class="token operator">=</span><span class="token number">11</span>
<span class="token comment">#</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$value1</span> -gt <span class="token number">5</span> <span class="token punctuation">]</span>
<span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;The test value <span class="token variable">$value1</span> is greater than 5&quot;</span>
<span class="token keyword">fi</span>
<span class="token comment">#</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$value1</span> -eq <span class="token variable">$value2</span> <span class="token punctuation">]</span>
<span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;The values are equal&quot;</span>
<span class="token keyword">else</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;The values are different&quot;</span>
<span class="token keyword">fi</span>
<span class="token comment">#</span>
$
</code></pre></div><p>第一个条件测试测试变量 value1 的值是否大于 5。第二个条件测试测试变量 value1 的值是否和变量 value2 的值相等。两个数值条件测试的结果和预想一致。</p> <p>但是涉及浮点值时，数值条件测试会有一个限制。bash shell 只能处理整数。如果你只是要通过 echo 语句来显示这个结果，那没问题。但是，在基于数字的函数中就不行了，比如数值测试条件，不能在 test 命令中使用浮点值。</p> <h3 id="字符串比较"><a href="#字符串比较" class="header-anchor">#</a> 字符串比较</h3> <p>条件测试还允许比较字符串值。比较字符串比较烦琐。</p> <ul><li>str1 = str2 检查 str1 是否和 str2 相同</li> <li>str1 != str2 检查 str1 是否和 str2 不同</li> <li>str1 &lt; str2 检查 str1 是否比 str2 小</li> <li>str1 &gt; str2 检查 str1 是否比 str2 大</li> <li><strong>-n str1 检查 str1 的长度是否非 0</strong></li> <li><strong>-z str1 检查 str1 的长度是否为 0</strong></li></ul> <p>记住，在比较字符串的相等性时，比较测试会将所有的标点和大小写情况都考虑在内。</p> <p>要测试一个字符串是否比另一个字符串大就是麻烦的开始。当要开始使用测试条件的大于或小于功能时，就会出现两个经常困扰 shell 程序员的问题：</p> <ul><li><strong>大于号和小于号必须转义，否则 shell 会把它们当作重定向符号，把字符串值当作文件名；</strong></li> <li>大于和小于顺序和 sort 命令所采用的不同。</li></ul> <p>在编写脚本时，第一条可能会导致一个不易察觉的严重问题。下面的例子展示了 shell 脚本编程初学者时常碰到的问题。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> badtest.sh
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># mis-using string comparisons</span>
<span class="token comment">#</span>
<span class="token assign-left variable">val1</span><span class="token operator">=</span>baseball
<span class="token assign-left variable">val2</span><span class="token operator">=</span>hockey
<span class="token comment">#</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$val1</span> <span class="token operator">&gt;</span> <span class="token variable">$val2</span> <span class="token punctuation">]</span>
<span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$val1</span> is greater than <span class="token variable">$val2</span>&quot;</span>
<span class="token keyword">else</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$val1</span> is less than <span class="token variable">$val2</span>&quot;</span>
<span class="token keyword">fi</span>
$
$ ./badtest.sh
baseball is greater than hockey
$ <span class="token function">ls</span> -l hockey
-rw-r--r-- <span class="token number">1</span> rich rich <span class="token number">0</span> Sep <span class="token number">30</span> <span class="token number">19</span>:08 hockey
$
</code></pre></div><p>这个脚本中只用了大于号，没有出现错误，但结果是错的。脚本把大于号解释成了输出重定向。因此，它创建了一个名为 hockey 的文件。由于重定向的顺利完成，test 命令返回了退出状态码 0，if 语句便以为所有命令都成功结束了。要解决这个问题，就需要使用反斜杠<code>\&gt;</code>正确转义大于号。</p> <p>第二个问题更细微，除非你经常处理大小写字母，否则几乎遇不到。sort 命令处理大写字母的方法刚好跟 test 命令相反。比如两个变量<code>val1=Testing val2=testing</code>，**==在 test 命令中，大写字母被认为是小于小写字母的。但 sort 命令恰好相反。当你将同样的字符串放进文件中并用 sort 命令排序时，小写字母会先出现。==**这是由各个命令使用的排序技术不同造成的。</p> <p>test 命令中使用的是标准的 ASCII 顺序，根据每个字符的 ASCII 数值来决定排序结果。sort 命令使用的是系统的本地化语言设置中定义的排序顺序。对于英语，本地化设置指定了在排序顺序中小写字母出现在大写字母前。</p> <blockquote><p>test 命令测试表达式使用标准的数学比较符号来表示字符串比较，而用文本代码来表示数值比较。这个细微的特性被很多程序员理解反了。如果你对数值使用了数学运算符号，shell 会将它们当成字符串值，可能无法得到正确的结果。</p></blockquote> <p>最后，-n 和-z 可以检查一个变量是否含有数据。如果一个变量为空字符串，或其从未被定义，那么均会被认为它的字符串长度为 0。</p> <blockquote><p>空的和未初始化的变量会对 shell 脚本测试造成灾难性的影响。如果不是很确定一个变量的内容，最好在将其用于数值或字符串比较之前先通过-n 或-z 来测试一下变量是否含有值。</p></blockquote> <h3 id="文件比较"><a href="#文件比较" class="header-anchor">#</a> 文件比较</h3> <p>最后一类比较测试很有可能是 shell 编程中最为强大、也是用得最多的比较形式。它允许你测试 Linux 文件系统上文件和目录的状态。</p> <ul><li><strong>-d file 检查 file 是否存在并是一个目录</strong></li> <li><strong>-e file 检查 file 是否存在（文件或目录）</strong></li> <li><strong>-f file 检查 file 是否存在并是一个文件</strong></li> <li>-r file 检查 file 是否存在并可读</li> <li>-s file 检查 file 是否存在并非空</li> <li>-w file 检查 file 是否存在并可写</li> <li>-x file 检查 file 是否存在并可执行</li> <li>-O file 检查 file 是否存在并属当前用户所有</li> <li>-G file 检查 file 是否存在并且默认组与当前用户相同</li> <li>file1 -nt file2 检查 file1 是否比 file2 新</li> <li>file1 -ot file2 检查 file1 是否比 file2 旧</li></ul> <p>这些测试条件使你能够在 shell 脚本中检查文件系统中的文件。它们经常出现在需要进行文件访问的脚本中。鉴于其使用广泛，建议熟练掌握。用于比较文件路径是相对你运行该脚本的目录而言的。</p> <p>需要注意的是，-G 比较会检查文件的默认组，如果它匹配了用户的默认组，则测试成功。由于-G 比较只会检查默认组而非用户所属的所有组，这会叫人有点困惑。如果文件的组被改成了某个组，用户也是其中的一员，但用户并不以其为默认组，此时-G 比较会失败，因为它只比较默认组，不会去比较其他的组。</p> <p>此外，在比较两个文件的新旧时，这些比较都不会先检查文件是否存在，如果你要检查的文件已经移走，就会出现问题。在你尝试使用-nt 或-ot 比较文件之前，必须先确认文件是存在的。</p> <h2 id="复合条件测试"><a href="#复合条件测试" class="header-anchor">#</a> 复合条件测试</h2> <p>if-then 语句允许你使用布尔逻辑来组合测试。有两种布尔运算符可用：</p> <ul><li>[ condition1 ] &amp;&amp; [ condition2 ]</li> <li>[ condition1 ] || [ condition2 ]</li></ul> <p>结合方括号测试方式和布尔逻辑组合，可以测试更多条件。</p> <h2 id="if-语句的高级特性"><a href="#if-语句的高级特性" class="header-anchor">#</a> if 语句的高级特性</h2> <p>bash shell 提供了两项可在 if-then 语句中使用的高级特性：</p> <ul><li>用于数学表达式的双括号</li> <li>用于高级字符串处理功能的双方括号</li></ul> <h3 id="使用双括号-常用"><a href="#使用双括号-常用" class="header-anchor">#</a> 使用双括号-常用</h3> <p>双括号命令允许你在比较过程中使用高级数学表达式。test 命令只能在比较中使用简单的算术操作。双括号命令提供了更多的数学符号，这些符号对于用过其他编程语言的程序员而言并不陌生。除了 test 命令使用的标准数学运算符，如下列出了双括号命令中还可以使用的其他运算符。</p> <ul><li>val++ 后增</li> <li>val-- 后减</li> <li>++val 先增</li> <li>--val 先减</li> <li>! 逻辑求反</li> <li>~ 位求反</li> <li>** 幂运算</li> <li>&lt;&lt; 左位移</li> <li>&gt;&gt; 右位移</li> <li>&amp; 位布尔和</li> <li>| 位布尔或</li> <li>&amp;&amp; 逻辑和</li> <li>|| 逻辑或</li></ul> <p>可以在 if 语句中用双括号命令，也可以在脚本中的普通命令里使用来赋值。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test23.sh
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># using double parenthesis</span>
<span class="token comment">#</span>
<span class="token assign-left variable">val1</span><span class="token operator">=</span><span class="token number">10</span>
<span class="token comment">#</span>
<span class="token keyword">if</span> <span class="token variable"><span class="token punctuation">((</span> $val1 <span class="token operator">**</span> <span class="token number">2</span> <span class="token operator">&gt;</span> <span class="token number">90</span> <span class="token punctuation">))</span></span>
<span class="token keyword">then</span>
    <span class="token variable"><span class="token punctuation">((</span> val2 <span class="token operator">=</span> $val1 <span class="token operator">**</span> <span class="token number">2</span> <span class="token punctuation">))</span></span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;The square of <span class="token variable">$val1</span> is <span class="token variable">$val2</span>&quot;</span>
<span class="token keyword">fi</span>
$
$ ./test23.sh
The square of <span class="token number">10</span> is <span class="token number">100</span>
$
</code></pre></div><p><strong>==注意，不需要将双括号中表达式里的大于号转义。这是双括号命令提供的另一个高级特性。==</strong></p> <h3 id="使用双方括号"><a href="#使用双方括号" class="header-anchor">#</a> 使用双方括号</h3> <p>双方括号命令提供了针对字符串比较的高级特性。双方括号使用了 test 命令中采用的标准字符串比较。但它提供了 test 命令未提供的另一个特性——<code>模式匹配</code>（pattern matching）。</p> <blockquote><p>双方括号在 bash shell 中工作良好。不过要小心，不是所有的 shell 都支持双方括号。</p></blockquote> <p>在模式匹配中，可以定义一个正则表达式（后续将详细讨论）来匹配字符串值。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test24.sh
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># using pattern matching</span>
<span class="token comment">#</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token environment constant">$USER</span> <span class="token operator">==</span> r* <span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;Hello <span class="token environment constant">$USER</span>&quot;</span>
<span class="token keyword">else</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;Sorry, I do not know you&quot;</span>
<span class="token keyword">fi</span>
$
$ ./test24.sh
Hello rich
$

</code></pre></div><p>在上面的脚本中，我们使用了双等号（==）。双等号将右边的字符串（r*）视为一个模式，并应用模式匹配规则。双方括号命令$USER 环境变量进行匹配，看它是否以字母 r 开头。如果是的话，比较通过，shell 会执行 then 部分的命令。</p> <h2 id="case-命令"><a href="#case-命令" class="header-anchor">#</a> case 命令</h2> <p>你会经常发现自己在尝试计算一个变量的值，在一组可能的值中寻找特定值。在这种情形下，你不得不写出很长的 if-then-else 语句，就像下面这样。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test25.sh
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># looking for a possible value</span>
<span class="token comment">#</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token environment constant">$USER</span> <span class="token operator">=</span> <span class="token string">&quot;rich&quot;</span> <span class="token punctuation">]</span>
<span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;Welcome <span class="token environment constant">$USER</span>&quot;</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;Please enjoy your visit&quot;</span>
<span class="token keyword">elif</span> <span class="token punctuation">[</span> <span class="token environment constant">$USER</span> <span class="token operator">=</span> <span class="token string">&quot;barbara&quot;</span> <span class="token punctuation">]</span>
<span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;Welcome <span class="token environment constant">$USER</span>&quot;</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;Please enjoy your visit&quot;</span>
<span class="token keyword">elif</span> <span class="token punctuation">[</span> <span class="token environment constant">$USER</span> <span class="token operator">=</span> <span class="token string">&quot;testing&quot;</span> <span class="token punctuation">]</span>
<span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;Special testing account&quot;</span>
<span class="token keyword">elif</span> <span class="token punctuation">[</span> <span class="token environment constant">$USER</span> <span class="token operator">=</span> <span class="token string">&quot;jessica&quot;</span> <span class="token punctuation">]</span>
<span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;Do not forget to logout when you're done&quot;</span>
<span class="token keyword">else</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;Sorry, you are not allowed here&quot;</span>
<span class="token keyword">fi</span>
$
$ ./test25.sh
Welcome rich
Please enjoy your visit
$
</code></pre></div><p>elif 语句继续 if-then 检查，为比较变量寻找特定的值。有了 case 命令，就不需要再写出所有的 elif 语句来不停地检查同一个变量的值了。case 命令会采用列表格式来检查单个变量的多个值。</p> <p>case 命令会将指定的变量与不同模式进行比较。如果变量和模式是匹配的，那么 shell 会执行为该模式指定的命令。**可以通过竖线操作符在一行中分隔出多个模式模式。**星号会捕获所有与已知模式不匹配的值。这里有个将 if-then-else 程序转换成用 case 命令的例子。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test26.sh
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># using the case command</span>
<span class="token comment">#</span>
<span class="token keyword">case</span> <span class="token environment constant">$USER</span> <span class="token keyword">in</span>
rich <span class="token operator">|</span> barbara<span class="token punctuation">)</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;Welcome, <span class="token environment constant">$USER</span>&quot;</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;Please enjoy your visit&quot;</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
testing<span class="token punctuation">)</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;Special testing account&quot;</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
jessica<span class="token punctuation">)</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;Do not forget to log off when you're done&quot;</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
*<span class="token punctuation">)</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;Sorry, you are not allowed here&quot;</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
<span class="token keyword">esac</span>
$
$ ./test26.sh
Welcome, rich
Please enjoy your visit
$
</code></pre></div><p>case 命令提供了一个更清晰的方法来为变量每个可能的值指定不同的选项。</p> <h2 id="for-命令"><a href="#for-命令" class="header-anchor">#</a> for 命令</h2> <p>重复执行一系列命令在编程中很常见。通常你需要重复一组命令直至达到某个特定条件，比如处理某个目录下的所有文件、系统上的所有用户或是某个文本文件中的所有行。for 命令有几种不同的方式来读取列表中的值，下面几节将会介绍各种方式。</p> <h3 id="读取列表中的值"><a href="#读取列表中的值" class="header-anchor">#</a> 读取列表中的值</h3> <p>for 命令最基本的用法就是遍历 for 命令自身所定义的一系列值。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test1
 <span class="token comment">#!/bin/bash</span>
<span class="token comment"># basic for command</span>
<span class="token keyword">for</span> <span class="token for-or-select variable">test</span> <span class="token keyword">in</span> Alabama Alaska Arizona Arkansas California Colorado
<span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> The next state is <span class="token variable">$test</span>
<span class="token keyword">done</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;The last state we visited was <span class="token variable">$test</span>&quot;</span>
<span class="token assign-left variable">test</span><span class="token operator">=</span>Connecticut
<span class="token builtin class-name">echo</span> <span class="token string">&quot;Wait, now we're visiting <span class="token variable">$test</span>&quot;</span>
$ ./test1
The next state is Alabama
The next state is Alaska
The next state is Arizona
The next state is Arkansas
The next state is California
The next state is Colorado
The last state we visited was Colorado
Wait, now we're visiting Connecticut
$
</code></pre></div><p>每次 for 命令遍历值列表，它都会将列表中的下个值赋给$test变量。$test 变量可以像 for 命令语句中的其他脚本变量一样使用。在最后一次迭代后，$test 变量的值会在 shell 脚本的剩余部分一直保持有效。它会一直保持最后一次迭代的值（除非你修改了它）。$test 变量保持了其值，也允许我们修改它的值，并在 for 命令循环之外跟其他变量一样使用</p> <p>事情并不会总像你在 for 循环中看到的那么简单。有时会遇到难处理的数据。有时 for 循环的值列表中可能存在中间有空格的值，此时使用单引号或者双引号将中间存在空格的值括起来即可。有时候，有的值自身中存在单引号或双引号，这时需要用另外一种相反的引号将其括起来，或者使用反斜杠转义即可正常使用。</p> <h3 id="从变量读取列表"><a href="#从变量读取列表" class="header-anchor">#</a> 从变量读取列表</h3> <p>通常 shell 脚本遇到的情况是，你将一系列值都集中存储在了一个变量中，然后需要遍历变量中的整个列表。也可以通过 for 命令完成这个任务。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test4
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># using a variable to hold the list</span>
<span class="token assign-left variable">list</span><span class="token operator">=</span><span class="token string">&quot;Alabama Alaska Arizona Arkansas Colorado&quot;</span>
<span class="token assign-left variable">list</span><span class="token operator">=</span><span class="token variable">$list</span><span class="token string">&quot; Connecticut&quot;</span>
<span class="token keyword">for</span> <span class="token for-or-select variable">state</span> <span class="token keyword">in</span> <span class="token variable">$list</span>
<span class="token keyword">do</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;Have you ever visited <span class="token variable">$state</span>?&quot;</span>
<span class="token keyword">done</span>
$ ./test4
Have you ever visited Alabama?
Have you ever visited Alaska?
Have you ever visited Arizona?
Have you ever visited Arkansas?
Have you ever visited Colorado?
Have you ever visited Connecticut?

</code></pre></div><p>$list变量包含了用于迭代的标准文本值列表。注意，代码还是用了另一个赋值语句向$list 变量包含的已有列表中添加（或者说是拼接）了一个值。<strong>这是向变量中存储的已有文本字符串尾部添加文本的一个常用方法。</strong></p> <h3 id="从命令读取值"><a href="#从命令读取值" class="header-anchor">#</a> 从命令读取值</h3> <p>生成列表中所需值的另外一个途径就是使用命令的输出。可以用命令替换来执行任何能产生输出的命令，然后在 for 命令中使用该命令的输出。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test5
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># reading values from a file</span>
<span class="token assign-left variable">file</span><span class="token operator">=</span><span class="token string">&quot;states&quot;</span>
<span class="token keyword">for</span> <span class="token for-or-select variable">state</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">cat</span> $file<span class="token variable">)</span></span>
<span class="token keyword">do</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;Visit beautiful <span class="token variable">$state</span>&quot;</span>
<span class="token keyword">done</span>
$ <span class="token function">cat</span> states
Alabama
Alaska
Arizona
Arkansas
Colorado
Connecticut
Delaware
Florida
Georgia
$ ./test5
Visit beautiful Alabama
Visit beautiful Alaska
Visit beautiful Arizona
Visit beautiful Arkansas
Visit beautiful Colorado
Visit beautiful Connecticut
Visit beautiful Delaware
Visit beautiful Florida
Visit beautiful Georgia
$
</code></pre></div><p>这个例子在命令替换中使用了 cat 命令来输出文件 states 的内容。你会注意到 states 文件中每一行有一个州，而不是通过空格分隔的。for 命令仍然以每次一行的方式遍历了 cat 命令的输出，假定每个州都是在单独的一行上。但这并没有解决数据中有空格的问题。如果你列出了一个名字中有空格的州，for 命令仍然会将每个单词当作单独的值。这是有原因的，下一节我们将会了解。</p> <blockquote><p>test5 的代码范例将文件名赋给变量，文件名中没有加入路径。这要求文件和脚本位于同一个目录中。如果不是的话，你需要使用全路径名（不管是绝对路径还是相对路径）来引用文件位置。</p></blockquote> <h3 id="更改字段分隔符"><a href="#更改字段分隔符" class="header-anchor">#</a> 更改字段分隔符</h3> <p>造成这个问题的原因是特殊的环境变量 IFS，叫作内部字段分隔符（internal field separator）。IFS 环境变量定义了 bash shell 用作字段分隔符的一系列字符。默认情况下，bash shell 会将下列字符当作字段分隔符：</p> <ul><li><strong>空格</strong></li> <li><strong>制表符</strong></li> <li><strong>换行符</strong></li></ul> <p>如果 bash shell 在数据中看到了这些字符中的任意一个，它就会假定这表明了列表中一个新数据字段的开始。在处理可能含有空格的数据（比如文件名）时，这会非常麻烦，就像你在上一个脚本示例中看到的。</p> <p>要解决这个问题，可以在 shell 脚本中临时更改 IFS 环境变量的值来限制被 bash shell 当作字段分隔符的字符。例如，如果你想修改 IFS 的值，使其只能识别换行符，那就必须这么做：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span><span class="token string">$'<span class="token entity" title="\n">\n</span>'</span>
</code></pre></div><p>将这个语句加入到脚本中，告诉 bash shell 在数据值中忽略空格和制表符。对前一个脚本使用这种方法，shell 脚本就能够使用列表中含有空格的值了。</p> <blockquote><p>在处理代码量较大的脚本时，可能在一个地方需要修改 IFS 的值，然后忽略这次修改，在脚本的其他地方继续沿用 IFS 的默认值。一个可参考的安全实践是在改变 IFS 之前保存原来的 IFS 值，之后再恢复它。这种技术可以这样实现： IFS.OLD=$IFS   IFS=$'\n' &lt;在代码中使用新的 IFS 值&gt; IFS=$IFS.OLD 这就保证了在脚本的后续操作中使用的是 IFS 的默认值。</p></blockquote> <p>还有其他一些 IFS 环境变量的绝妙用法。假定你要遍历一个文件中用冒号分隔的值（比如在/etc/passwd 文件中）。你要做的就是将 IFS 的值设为冒号</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span>:
</code></pre></div><p>如果要指定多个 IFS 字符，只要将它们在赋值行串起来就行。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span><span class="token string">$'<span class="token entity" title="\n">\n</span>'</span><span class="token builtin class-name">:</span><span class="token punctuation">;</span>&quot;
</code></pre></div><p>这个赋值会将换行符、冒号、分号和双引号作为字段分隔符。如何使用 IFS 字符解析数据没有任何限制。</p> <h3 id="用通配符读取目录"><a href="#用通配符读取目录" class="header-anchor">#</a> 用通配符读取目录</h3> <p>最后，可以用 for 命令来自动遍历目录中的文件。进行此操作时，必须在文件名或路径名中使用通配符。它会强制 shell 使用文件扩展匹配。文件扩展匹配是生成匹配指定通配符的文件名或路径名的过程。</p> <p>如果不知道所有的文件名，这个特性在处理目录中的文件时就非常好用。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test6
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># iterate through all the files in a directory</span>
<span class="token keyword">for</span> <span class="token for-or-select variable">file</span> <span class="token keyword">in</span> /home/rich/test/*
<span class="token keyword">do</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> -d <span class="token string">&quot;<span class="token variable">$file</span>&quot;</span> <span class="token punctuation">]</span>
    <span class="token keyword">then</span>
        <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$file</span> is a directory&quot;</span>
    <span class="token keyword">elif</span> <span class="token punctuation">[</span> -f <span class="token string">&quot;<span class="token variable">$file</span>&quot;</span> <span class="token punctuation">]</span>
    <span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$file</span> is a file&quot;</span>
    <span class="token keyword">fi</span>
<span class="token keyword">done</span>
$ ./test6
/home/rich/test/dir1 is a directory
/home/rich/test/myprog.c is a <span class="token function">file</span>
/home/rich/test/myprog is a <span class="token function">file</span>
/home/rich/test/myscript is a <span class="token function">file</span>
/home/rich/test/newdir is a directory
/home/rich/test/newfile is a <span class="token function">file</span>
/home/rich/test/newfile2 is a <span class="token function">file</span>
/home/rich/test/testdir is a directory
/home/rich/test/testing is a <span class="token function">file</span>
/home/rich/test/testprog is a <span class="token function">file</span>
/home/rich/test/testprog.c is a <span class="token function">file</span>
$
</code></pre></div><p>for 命令会遍历/home/rich/test/*输出的结果。该代码用 test 命令测试了每个条目（使用方括号方法），以查看它是目录（通过-d 参数）还是文件（通过-f 参数）</p> <p>注意，我们在这个例子的 if 语句中做了一些不同的处理</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">if</span> <span class="token punctuation">[</span> -d <span class="token string">&quot;<span class="token variable">$file</span>&quot;</span> <span class="token punctuation">]</span>
</code></pre></div><p>在 Linux 中，目录名和文件名中包含空格当然是合法的。要适应这种情况，应该将$file 变量用双引号圈起来。如果不这么做，遇到含有空格的目录名或文件名时就会有错误产生。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>./test6: line <span class="token number">6</span>: <span class="token punctuation">[</span>: too many arguments
./test6: line <span class="token number">9</span>: <span class="token punctuation">[</span>: too many arguments
</code></pre></div><p>在 test 命令中，bash shell 会将额外的单词当作参数，进而造成错误。</p> <p>也可以在 for 命令中列出多个目录通配符，将目录查找和列表合并进同一个 for 语句。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test7
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># iterating through multiple directories</span>
<span class="token keyword">for</span> <span class="token for-or-select variable">file</span> <span class="token keyword">in</span> /home/rich/.b* /home/rich/badtest
<span class="token keyword">do</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> -d <span class="token string">&quot;<span class="token variable">$file</span>&quot;</span> <span class="token punctuation">]</span>
    <span class="token keyword">then</span>
        <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$file</span> is a directory&quot;</span>
    <span class="token keyword">elif</span> <span class="token punctuation">[</span> -f <span class="token string">&quot;<span class="token variable">$file</span>&quot;</span> <span class="token punctuation">]</span>
    <span class="token keyword">then</span>
        <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$file</span> is a file&quot;</span>
    <span class="token keyword">else</span>
        <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$file</span> doesn't exist&quot;</span>
    <span class="token keyword">fi</span>
<span class="token keyword">done</span>

$ ./test7
/home/rich/.backup.timestamp is a <span class="token function">file</span>
/home/rich/.bash_history is a <span class="token function">file</span>
/home/rich/.bash_logout is a <span class="token function">file</span>
/home/rich/.bash_profile is a <span class="token function">file</span>
/home/rich/.bashrc is a <span class="token function">file</span>
/home/rich/badtest doesn't exist
$
</code></pre></div><p>for 语句首先使用了文件扩展匹配来遍历通配符生成的文件列表，然后它会遍历列表中的下一个文件。可以将任意多的通配符放进列表中。</p> <blockquote><p>注意，你可以在数据列表中放入任何东西。即使文件或目录不存在，for 语句也会尝试处理列表中的内容。在处理文件或目录时，这可能会是个问题。你无法知道你正在尝试遍历的目录是否存在：在处理之前测试一下文件或目录总是好的。</p></blockquote> <h2 id="c-语言风格的-for-命令"><a href="#c-语言风格的-for-命令" class="header-anchor">#</a> C 语言风格的 for 命令</h2> <p>如果你从事过 C 语言编程，可能会对 bash shell 中 for 命令的工作方式有点惊奇。在 C 语言中，for 循环通常定义一个变量，然后这个变量会在每次迭代时自动改变。通常程序员会将这个变量用作计数器，并在每次迭代中让计数器增一或减一。bash 的 for 命令也提供了这个功能。本节将会告诉你如何在 bash shell 脚本中使用 C 语言风格的 for 命令。</p> <p>C 语言的 for 命令有一个用来指明变量的特定方法，一个必须保持成立才能继续迭代的条件，以及另一个在每个迭代中改变变量的方法。当指定的条件不成立时，for 循环就会停止。条件等式通过标准的数学符号定义。比如，考虑下面的 C 语言代码：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;The next number is %d\n&quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这段代码产生了一个简单的迭代循环，其中变量 i 作为计数器。第一部分将一个默认值赋给该变量。中间的部分定义了循环重复的条件。当定义的条件不成立时，for 循环就停止迭代。最后一部分定义了迭代的过程。在每次迭代之后，最后一部分中定义的表达式会被执行。在本例中，i 变量会在每次迭代后增一。</p> <p>bash shell 也支持一种 for 循环，它看起来跟 C 语言风格的 for 循环类似，但有一些细微的不同，其中包括一些让 shell 脚本程序员困惑的东西。以下是 bash 中 C 语言风格的 for 循环的基本格式。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span> variableassignment <span class="token punctuation">;</span> condition <span class="token punctuation">;</span> iterationprocess <span class="token punctuation">))</span></span>
</code></pre></div><p>C 语言风格的 for 循环的格式会让 bash shell 脚本程序员摸不着头脑，因为它使用了 C 语言风格的变量引用方式而不是 shell 风格的变量引用方式。C 语言风格的 for 命令看起来如下。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">(</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> a <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> a<span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>注意，有些部分并没有遵循 bash shell 标准的 for 命令：</p> <ul><li><strong>变量赋值可以有空格；</strong></li> <li><strong>条件中的变量不以美元符开头；</strong></li> <li><strong>迭代过程的算式未用 expr 命令格式。</strong></li></ul> <p>shell 开发人员创建了这种格式以更贴切地模仿 C 语言风格的 for 命令。这虽然对 C 语言程序员来说很好，但也会把专家级的 shell 程序员弄得一头雾水。在脚本中使用 C 语言风格的 for 循环时要小心。</p> <p>以下例子是在 bash shell 程序中使用 C 语言风格的 for 命令</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test8
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># testing the C-style for loop</span>
<span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">))</span></span>
<span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;The next number is <span class="token variable">$i</span>&quot;</span>
<span class="token keyword">done</span>
$ ./test8
The next number is <span class="token number">1</span>
The next number is <span class="token number">2</span>
The next number is <span class="token number">3</span>
$
</code></pre></div><p>for 循环通过定义好的变量（本例中是变量 i）来迭代执行这些命令。在每次迭代中，$i 变量包含了 for 循环中赋予的值。在每次迭代后，循环的迭代过程会作用在变量上，在本例中，变量增一。</p> <p>C 语言风格的 for 命令也允许为迭代使用多个变量。循环会单独处理每个变量，你可以为每个变量定义不同的迭代过程。尽管可以使用多个变量，但你只能在 for 循环中定义一种条件。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test9
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># multiple variables</span>
<span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span> a <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">;</span> a<span class="token operator">++</span><span class="token punctuation">,</span> b<span class="token operator">--</span> <span class="token punctuation">))</span></span>
<span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$a</span> - <span class="token variable">$b</span>&quot;</span>
<span class="token keyword">done</span>
$ ./test9
<span class="token number">1</span> - <span class="token number">10</span>
<span class="token number">2</span> - <span class="token number">9</span>
<span class="token number">3</span> - <span class="token number">8</span>
$
</code></pre></div><p>变量 a 和 b 分别用不同的值来初始化并且定义了不同的迭代过程。循环的每次迭代在增加变量 a 的同时减小了变量 b。</p> <h2 id="while-命令"><a href="#while-命令" class="header-anchor">#</a> while 命令</h2> <p>while 命令某种意义上是 if-then 语句和 for 循环的混杂体。while 命令允许定义一个要测试的命令，然后循环执行一组命令，只要定义的测试命令返回的是退出状态码 0。它会<strong>在每次迭代的一开始测试 test 命令。在 test 命令返回非零退出状态码时，while 命令会停止执行那组命令。</strong></p> <p>while 命令的格式是：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">while</span> <span class="token builtin class-name">test</span> <span class="token builtin class-name">command</span>
<span class="token keyword">do</span>
    other commands
<span class="token keyword">done</span>
</code></pre></div><p>while 命令中定义的 test command 和 if-then 语句中的格式一模一样。可以使用任何普通的 bash shell 命令，或者用 test 命令进行条件测试，比如测试变量值。</p> <p>while 命令的关键在于所指定的 test command 的退出状态码必须随着循环中运行的命令而改变。如果退出状态码不发生变化，while 循环就将一直不停地进行下去。
最常见的 test command 的用法是用方括号来检查循环命令中用到的 shell 变量的值。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test10
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># while command test</span>

<span class="token assign-left variable">var1</span><span class="token operator">=</span><span class="token number">10</span>
<span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token variable">$var1</span> -gt <span class="token number">0</span> <span class="token punctuation">]</span>
<span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> <span class="token variable">$var1</span>
    <span class="token assign-left variable">var1</span><span class="token operator">=</span>$<span class="token punctuation">[</span> <span class="token variable">$var1</span> - <span class="token number">1</span> <span class="token punctuation">]</span>
<span class="token keyword">done</span>
$ ./test10
<span class="token number">10</span>
<span class="token number">9</span>
<span class="token number">8</span>
<span class="token number">7</span>
<span class="token number">6</span>
<span class="token number">5</span>
<span class="token number">4</span>
<span class="token number">3</span>
<span class="token number">2</span>
<span class="token number">1</span>
$
</code></pre></div><p>while 命令定义了每次迭代时检查的测试条件：<code>while [ $var1 -gt 0 ]</code> 。只要测试条件成立，while 命令就会不停地循环执行定义好的命令。在这些命令中，测试条件中用到的变量必须被修改，否则就会陷入无限循环。在本例中，我们用 shell 算术来将变量值减一：<code>var1=$[ $var1 - 1 ]</code> 。while 循环会在测试条件不再成立时停止。</p> <p>while 命令允许你在 while 语句行定义多个测试命令。只有最后一个测试命令的退出状态码会被用来决定什么时候结束循环。如果你不够小心，可能会导致一些有意思的结果。下面的例子将说明这一点。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test11
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># testing a multicommand while loop</span>
<span class="token assign-left variable">var1</span><span class="token operator">=</span><span class="token number">10</span>
<span class="token keyword">while</span> <span class="token builtin class-name">echo</span> <span class="token variable">$var1</span>
    <span class="token punctuation">[</span> <span class="token variable">$var1</span> -ge <span class="token number">0</span> <span class="token punctuation">]</span>
<span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;This is inside the loop&quot;</span>
    <span class="token assign-left variable">var1</span><span class="token operator">=</span>$<span class="token punctuation">[</span> <span class="token variable">$var1</span> - <span class="token number">1</span> <span class="token punctuation">]</span>
<span class="token keyword">done</span>
$ ./test11
<span class="token number">10</span>
This is inside the loop
<span class="token number">9</span>
This is inside the loop
<span class="token number">8</span>
This is inside the loop
<span class="token number">7</span>
This is inside the loop
<span class="token number">6</span>
This is inside the loop
<span class="token number">5</span>
This is inside the loop
<span class="token number">4</span>
This is inside the loop
<span class="token number">3</span>
This is inside the loop
<span class="token number">2</span>
This is inside the loop
<span class="token number">1</span>
This is inside the loop
<span class="token number">0</span>
This is inside the loop
-1
</code></pre></div><p>while 语句中定义了两个测试命令。第一个测试简单地显示了 var1 变量的当前值。第二个测试用方括号来判断 var1 变量的值。在循环内部，echo 语句会显示一条简单的消息，说明循环被执行了。注意当你运行本例时输出最后还有一个-1。</p> <p>while 循环会在 var1 变量等于 0 时执行 echo 语句，然后将 var1 变量的值减一。接下来再次执行测试命令，用于下一次迭代。echo 测试命令被执行并显示了 var 变量的值（现在小于 0 了）。直到 shell 执行 test 测试命令，whle 循环才会停止。</p> <h2 id="until-命令"><a href="#until-命令" class="header-anchor">#</a> until 命令</h2> <p>until 命令和 while 命令工作的方式完全相反。until 命令要求你指定一个通常返回非零退出状态码的测试命令。只有测试命令的退出状态码不为 0，bash shell 才会执行循环中列出的命令。一旦测试命令返回了退出状态码 0，循环就结束了。和 while 命令类似，你可以在 until 命令语句中放入多个测试命令。只有最后一个命令的退出状态码决定了 bash shell 是否执行已定义的 other commands。下面是使用 until 命令的一个例子。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test12
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># using the until command</span>
<span class="token assign-left variable">var1</span><span class="token operator">=</span><span class="token number">100</span>
<span class="token keyword">until</span> <span class="token punctuation">[</span> <span class="token variable">$var1</span> -eq <span class="token number">0</span> <span class="token punctuation">]</span>
<span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> <span class="token variable">$var1</span>
    <span class="token assign-left variable">var1</span><span class="token operator">=</span>$<span class="token punctuation">[</span> <span class="token variable">$var1</span> - <span class="token number">25</span> <span class="token punctuation">]</span>
<span class="token keyword">done</span>
$ ./test12
<span class="token number">100</span>
<span class="token number">75</span>
<span class="token number">50</span>
<span class="token number">25</span>
$
</code></pre></div><p>本例中会测试 var1 变量来决定 until 循环何时停止。只要该变量的值等于 0，until 命令就会停止循环。同 while 命令一样，在 until 命令中使用多个测试命令时要注意。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test13
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># using the until command</span>
<span class="token assign-left variable">var1</span><span class="token operator">=</span><span class="token number">100</span>
<span class="token keyword">until</span> <span class="token builtin class-name">echo</span> <span class="token variable">$var1</span>
    <span class="token punctuation">[</span> <span class="token variable">$var1</span> -eq <span class="token number">0</span> <span class="token punctuation">]</span>
<span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> Inside the loop: <span class="token variable">$var1</span>
    <span class="token assign-left variable">var1</span><span class="token operator">=</span>$<span class="token punctuation">[</span> <span class="token variable">$var1</span> - <span class="token number">25</span> <span class="token punctuation">]</span>
<span class="token keyword">done</span>
$ ./test13
<span class="token number">100</span>
Inside the loop: <span class="token number">100</span>
<span class="token number">75</span>
Inside the loop: <span class="token number">75</span>
<span class="token number">50</span>
Inside the loop: <span class="token number">50</span>
<span class="token number">25</span>
Inside the loop: <span class="token number">25</span>
<span class="token number">0</span>
$

</code></pre></div><h2 id="嵌套循环"><a href="#嵌套循环" class="header-anchor">#</a> 嵌套循环</h2> <p>循环语句可以在循环内使用任意类型的命令，包括其他循环命令。这种循环叫作<code>嵌套循环</code>（nested loop）。**注意，在使用嵌套循环时，你是在迭代中使用迭代，与命令运行的次数是乘积关系。**不注意这点的话，有可能会在脚本中造成问题。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test14
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># nesting for loops</span>
<span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> a <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">;</span> a<span class="token operator">++</span> <span class="token punctuation">))</span></span>
<span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;Starting loop <span class="token variable">$a</span>:&quot;</span>
    <span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> b <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">;</span> b<span class="token operator">++</span> <span class="token punctuation">))</span></span>
        <span class="token keyword">do</span>
            <span class="token builtin class-name">echo</span> <span class="token string">&quot;   Inside loop: <span class="token variable">$b</span>&quot;</span>
        <span class="token keyword">done</span>
<span class="token keyword">done</span>
$ ./test14
Starting loop <span class="token number">1</span>:
    Inside loop: <span class="token number">1</span>
    Inside loop: <span class="token number">2</span>
    Inside loop: <span class="token number">3</span>
Starting loop <span class="token number">2</span>:
    Inside loop: <span class="token number">1</span>
    Inside loop: <span class="token number">2</span>
    Inside loop: <span class="token number">3</span>
Starting loop <span class="token number">3</span>:
    Inside loop: <span class="token number">1</span>
    Inside loop: <span class="token number">2</span>
    Inside loop: <span class="token number">3</span>
$
</code></pre></div><p>这个被嵌套的循环（也称为内部循环，inner loop）会在外部循环的每次迭代中遍历一次它所有的值。注意，两个循环的 do 和 done 命令没有任何差别。bash shell 知道当第一个 done 命令执行时是指内部循环而非外部循环。</p> <p>在混用循环命令时也一样，比如在 while 循环内部放置一个 for 循环。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test15
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># placing a for loop inside a while loop</span>
<span class="token assign-left variable">var1</span><span class="token operator">=</span><span class="token number">5</span>
<span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token variable">$var1</span> -ge <span class="token number">0</span> <span class="token punctuation">]</span>
<span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;Outer loop: <span class="token variable">$var1</span>&quot;</span>
    <span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span> var2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> $var2 <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> var2<span class="token operator">++</span> <span class="token punctuation">))</span></span>
    <span class="token keyword">do</span>
        <span class="token assign-left variable">var3</span><span class="token operator">=</span>$<span class="token punctuation">[</span> <span class="token variable">$var1</span> * <span class="token variable">$var2</span> <span class="token punctuation">]</span>
        <span class="token builtin class-name">echo</span> <span class="token string">&quot;  Inner loop: <span class="token variable">$var1</span> * <span class="token variable">$var2</span> = <span class="token variable">$var3</span>&quot;</span>
    <span class="token keyword">done</span>
<span class="token assign-left variable">var1</span><span class="token operator">=</span>$<span class="token punctuation">[</span> <span class="token variable">$var1</span> - <span class="token number">1</span> <span class="token punctuation">]</span>
<span class="token keyword">done</span>
$ ./test15
Outer loop: <span class="token number">5</span>
    Inner loop: <span class="token number">5</span> * <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">5</span>
    Inner loop: <span class="token number">5</span> * <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">10</span>
Outer loop: <span class="token number">4</span>
    Inner loop: <span class="token number">4</span> * <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">4</span>
    Inner loop: <span class="token number">4</span> * <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">8</span>
Outer loop: <span class="token number">3</span>
    Inner loop: <span class="token number">3</span> * <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">3</span>
    Inner loop: <span class="token number">3</span> * <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">6</span>
Outer loop: <span class="token number">2</span>
    Inner loop: <span class="token number">2</span> * <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">2</span>
    Inner loop: <span class="token number">2</span> * <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">4</span>
Outer loop: <span class="token number">1</span>
    Inner loop: <span class="token number">1</span> * <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">1</span>
    Inner loop: <span class="token number">1</span> * <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">2</span>
Outer loop: <span class="token number">0</span>
    Inner loop: <span class="token number">0</span> * <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">0</span>
    Inner loop: <span class="token number">0</span> * <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">0</span>
$
</code></pre></div><p>同样，shell 能够区分开内部 for 循环和外部 while 循环各自的 do 和 done 命令。如果真的想挑战脑力，可以混用 until 和 while 循环。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test16
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># using until and while loops</span>
<span class="token assign-left variable">var1</span><span class="token operator">=</span><span class="token number">3</span>
<span class="token keyword">until</span> <span class="token punctuation">[</span> <span class="token variable">$var1</span> -eq <span class="token number">0</span> <span class="token punctuation">]</span>
<span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;Outer loop: <span class="token variable">$var1</span>&quot;</span>
    <span class="token assign-left variable">var2</span><span class="token operator">=</span><span class="token number">1</span>
    <span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token variable">$var2</span> -lt <span class="token number">5</span> <span class="token punctuation">]</span>
    <span class="token keyword">do</span>
        <span class="token assign-left variable">var3</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> <span class="token string">&quot;scale=4; <span class="token variable">$var1</span> / <span class="token variable">$var2</span>&quot;</span> <span class="token operator">|</span> <span class="token function">bc</span><span class="token variable">)</span></span>
        <span class="token builtin class-name">echo</span> <span class="token string">&quot;   Inner loop: <span class="token variable">$var1</span> / <span class="token variable">$var2</span> = <span class="token variable">$var3</span>&quot;</span>
        <span class="token assign-left variable">var2</span><span class="token operator">=</span>$<span class="token punctuation">[</span> <span class="token variable">$var2</span> + <span class="token number">1</span> <span class="token punctuation">]</span>
    <span class="token keyword">done</span>
    <span class="token assign-left variable">var1</span><span class="token operator">=</span>$<span class="token punctuation">[</span> <span class="token variable">$var1</span> - <span class="token number">1</span> <span class="token punctuation">]</span>
<span class="token keyword">done</span>
$ ./test16
Outer loop: <span class="token number">3</span>
    Inner loop: <span class="token number">3</span> / <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">3.0000</span>
    Inner loop: <span class="token number">3</span> / <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">1.5000</span>
    Inner loop: <span class="token number">3</span> / <span class="token number">3</span> <span class="token operator">=</span> <span class="token number">1.0000</span>
    Inner loop: <span class="token number">3</span> / <span class="token number">4</span> <span class="token operator">=</span> .7500
Outer loop: <span class="token number">2</span>
    Inner loop: <span class="token number">2</span> / <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">2.0000</span>
    Inner loop: <span class="token number">2</span> / <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">1.0000</span>
    Inner loop: <span class="token number">2</span> / <span class="token number">3</span> <span class="token operator">=</span> .6666
    Inner loop: <span class="token number">2</span> / <span class="token number">4</span> <span class="token operator">=</span> .5000
Outer loop: <span class="token number">1</span>
    Inner loop: <span class="token number">1</span> / <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">1.0000</span>
    Inner loop: <span class="token number">1</span> / <span class="token number">2</span> <span class="token operator">=</span> .5000
    Inner loop: <span class="token number">1</span> / <span class="token number">3</span> <span class="token operator">=</span> .3333
    Inner loop: <span class="token number">1</span> / <span class="token number">4</span> <span class="token operator">=</span> .2500
$
</code></pre></div><p>外部的 until 循环以值 3 开始，并继续执行到值等于 0。内部 while 循环以值 1 开始并一直执行，只要值小于 5。每个循环都必须改变在测试条件中用到的值，否则循环就会无止尽进行下去。</p> <h2 id="循环处理文件数据"><a href="#循环处理文件数据" class="header-anchor">#</a> 循环处理文件数据</h2> <p>如果需要遍历存储在文件中的数据，则需要结合已经讲过的两种技术：</p> <ul><li>使用嵌套循环</li> <li>修改 IFS 环境变量</li></ul> <p>通过修改 IFS 环境变量，就能强制 for 命令将文件中的每行都当成单独的一个条目来处理，即便数据中有空格也是如此。一旦从文件中提取出了单独的行，可能需要再次利用循环来提取行中的数据。</p> <p>典型的例子是处理/etc/passwd 文件中的数据。这要求你逐行遍历/etc/passwd 文件，然后将 IFS 变量的值改成冒号，这样就能分隔开每行中的各个数据段了。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token shebang important">#!/bin/bash</span>
<span class="token comment"># changing the IFS value</span>
<span class="token environment constant">IFS</span>.OLD<span class="token operator">=</span><span class="token environment constant">$IFS</span>
<span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span><span class="token string">$'<span class="token entity" title="\n">\n</span>'</span>
<span class="token keyword">for</span> <span class="token for-or-select variable">entry</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">cat</span> /etc/passwd<span class="token variable">)</span></span>
<span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;Values in <span class="token variable">$entry</span> –&quot;</span>
    <span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span>:
    <span class="token keyword">for</span> <span class="token for-or-select variable">value</span> <span class="token keyword">in</span> <span class="token variable">$entry</span>
    <span class="token keyword">do</span>
        <span class="token builtin class-name">echo</span> <span class="token string">&quot;   <span class="token variable">$value</span>&quot;</span>
    <span class="token keyword">done</span>
<span class="token keyword">done</span>
$
</code></pre></div><p>这个脚本使用了两个不同的 IFS 值来解析数据。第一个 IFS 值解析出/etc/passwd 文件中的单独的行。内部 for 循环接着将 IFS 的值修改为冒号，允许你从/etc/passwd 的行中解析出单独的值。内部循环会解析出/etc/passwd 每行中的各个值。这种方法在处理外部导入电子表格所采用的逗号分隔的数据时也很方便。</p> <h2 id="控制循环"><a href="#控制循环" class="header-anchor">#</a> 控制循环</h2> <p>你可能会想，一旦启动了循环，就必须苦等到循环完成所有的迭代。并不是这样的。有两个命令能帮我们控制循环内部的情况：</p> <ul><li>break 命令</li> <li>continue 命令</li></ul> <p>每个命令在如何控制循环的执行方面有不同的用法。下面几节将介绍如何使用这些命令来控制循环。</p> <h3 id="break-命令"><a href="#break-命令" class="header-anchor">#</a> break 命令</h3> <p>break 命令是退出循环的一个简单方法。可以用 break 命令来退出任意类型的循环，包括 while 和 until 循环。有几种情况可以使用 break 命令，本节将介绍这些方法。</p> <ol><li>跳出单个循环</li></ol> <p>在 shell 执行 break 命令时，它会尝试跳出当前正在执行的循环。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">cat</span> test17
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># breaking out of a for loop</span>
<span class="token keyword">for</span> <span class="token for-or-select variable">var1</span> <span class="token keyword">in</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token number">10</span>
<span class="token keyword">do</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$var1</span> -eq <span class="token number">5</span> <span class="token punctuation">]</span>
    <span class="token keyword">then</span>
        <span class="token builtin class-name">break</span>
    <span class="token keyword">fi</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;Iteration number: <span class="token variable">$var1</span>&quot;</span>
<span class="token keyword">done</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;The for loop is completed&quot;</span>


$ ./test17
Iteration number: <span class="token number">1</span>
Iteration number: <span class="token number">2</span>
Iteration number: <span class="token number">3</span>
Iteration number: <span class="token number">4</span>
The <span class="token keyword">for</span> loop is completed
$
</code></pre></div><p>for 循环通常都会遍历列表中指定的所有值。但当满足 if-then 的条件时，shell 会执行 break 命令，停止 for 循环。这种方法同样适用于 while 和 until 循环。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test18
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># breaking out of a while loop</span>
<span class="token assign-left variable">var1</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token variable">$var1</span> -lt <span class="token number">10</span> <span class="token punctuation">]</span>
<span class="token keyword">do</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$var1</span> -eq <span class="token number">5</span> <span class="token punctuation">]</span>
    <span class="token keyword">then</span>
        <span class="token builtin class-name">break</span>
    <span class="token keyword">fi</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;Iteration: <span class="token variable">$var1</span>&quot;</span>
    <span class="token assign-left variable">var1</span><span class="token operator">=</span>$<span class="token punctuation">[</span> <span class="token variable">$var1</span> + <span class="token number">1</span> <span class="token punctuation">]</span>
<span class="token keyword">done</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;The while loop is completed&quot;</span>
$ ./test18
Iteration: <span class="token number">1</span>
Iteration: <span class="token number">2</span>
Iteration: <span class="token number">3</span>
Iteration: <span class="token number">4</span>
The <span class="token keyword">while</span> loop is completed
$
</code></pre></div><p>while 循环会在 if-then 的条件满足时执行 break 命令，终止。</p> <ol start="2"><li>跳出内部循环</li></ol> <p>在处理多个循环时，break 命令会自动终止你所在的最内层的循环。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test19
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># breaking out of an inner loop</span>
<span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> a <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> a<span class="token operator">++</span> <span class="token punctuation">))</span></span>
<span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;Outer loop: <span class="token variable">$a</span>&quot;</span>
    <span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> b <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> b<span class="token operator">++</span> <span class="token punctuation">))</span></span>
    <span class="token keyword">do</span>
        <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$b</span> -eq <span class="token number">5</span> <span class="token punctuation">]</span>
        <span class="token keyword">then</span>
            <span class="token builtin class-name">break</span>
        <span class="token keyword">fi</span>
        <span class="token builtin class-name">echo</span> <span class="token string">&quot;   Inner loop: <span class="token variable">$b</span>&quot;</span>
    <span class="token keyword">done</span>
<span class="token keyword">done</span>
$ ./test19
Outer loop: <span class="token number">1</span>
    Inner loop: <span class="token number">1</span>
    Inner loop: <span class="token number">2</span>
    Inner loop: <span class="token number">3</span>
    Inner loop: <span class="token number">4</span>
Outer loop: <span class="token number">2</span>
    Inner loop: <span class="token number">1</span>
    Inner loop: <span class="token number">2</span>
    Inner loop: <span class="token number">3</span>
    Inner loop: <span class="token number">4</span>
Outer loop: <span class="token number">3</span>
    Inner loop: <span class="token number">1</span>
    Inner loop: <span class="token number">2</span>
    Inner loop: <span class="token number">3</span>
    Inner loop: <span class="token number">4</span>
$
</code></pre></div><p>内部循环里的 for 语句指明当变量 b 等于 100 时停止迭代。但内部循环的 if-then 语句指明当变量 b 的值等于 5 时执行 break 命令。注意，即使内部循环通过 break 命令终止了，外部循环依然继续执行。</p> <ol start="3"><li>跳出外部循环</li></ol> <p>有时你在内部循环，但需要停止外部循环。break 命令接受单个命令行参数值：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">break</span> n
</code></pre></div><p>其中 <strong>==n 指定了要跳出的循环层级。默认情况下，n 为 1，表明跳出的是当前的循环。如果你将 n 设为 2，break 命令就会停止下一级的外部循环==</strong>。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test20
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># breaking out of an outer loop</span>
<span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> a <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> a<span class="token operator">++</span> <span class="token punctuation">))</span></span>
<span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;Outer loop: <span class="token variable">$a</span>&quot;</span>
    <span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> b <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> b<span class="token operator">++</span> <span class="token punctuation">))</span></span>
    <span class="token keyword">do</span>
        <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$b</span> -gt <span class="token number">4</span> <span class="token punctuation">]</span>
        <span class="token keyword">then</span>
            <span class="token builtin class-name">break</span> <span class="token number">2</span>
        <span class="token keyword">fi</span>
        <span class="token builtin class-name">echo</span> <span class="token string">&quot;   Inner loop: <span class="token variable">$b</span>&quot;</span>
    <span class="token keyword">done</span>
<span class="token keyword">done</span>
$ ./test20
Outer loop: <span class="token number">1</span>
    Inner loop: <span class="token number">1</span>
    Inner loop: <span class="token number">2</span>
    Inner loop: <span class="token number">3</span>
    Inner loop: <span class="token number">4</span>
$
</code></pre></div><p>注意，当 shell 执行了 break 命令后，外部循环就停止了。</p> <h3 id="continue-命令"><a href="#continue-命令" class="header-anchor">#</a> continue 命令</h3> <p>continue 命令可以提前中止某次循环中的命令，但并不会完全终止整个循环。可以在循环内部设置 shell 不执行命令的条件。这里有个在 for 循环中使用 continue 命令的简单例子。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test21
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># using the continue command</span>
<span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span> var1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> var1 <span class="token operator">&lt;</span> <span class="token number">15</span><span class="token punctuation">;</span> var1<span class="token operator">++</span> <span class="token punctuation">))</span></span>
<span class="token keyword">do</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$var1</span> -gt <span class="token number">5</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">[</span> <span class="token variable">$var1</span> -lt <span class="token number">10</span> <span class="token punctuation">]</span>
    <span class="token keyword">then</span>
        <span class="token builtin class-name">continue</span>
    <span class="token keyword">fi</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;Iteration number: <span class="token variable">$var1</span>&quot;</span>
<span class="token keyword">done</span>
$ ./test21
Iteration number: <span class="token number">1</span>
Iteration number: <span class="token number">2</span>
Iteration number: <span class="token number">3</span>
Iteration number: <span class="token number">4</span>
Iteration number: <span class="token number">5</span>
Iteration number: <span class="token number">10</span>
Iteration number: <span class="token number">11</span>
Iteration number: <span class="token number">12</span>
Iteration number: <span class="token number">13</span>
Iteration number: <span class="token number">14</span>
$
</code></pre></div><p>当 if-then 语句的条件被满足时（值大于 5 且小于 10），shell 会执行 continue 命令，跳过此次循环中剩余的命令，但整个循环还会继续。当 if-then 的条件不再被满足时，一切又回到正轨。</p> <p>也可以在 while 和 until 循环中使用 continue 命令，但要特别小心。记住，当 shell 执行 continue 命令时，它会跳过剩余的命令。如果你在其中某个条件里对测试条件变量进行增值，问题就会出现。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> badtest3
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># improperly using the continue command in a while loop</span>
<span class="token assign-left variable">var1</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token keyword">while</span> <span class="token builtin class-name">echo</span> <span class="token string">&quot;while iteration: <span class="token variable">$var1</span>&quot;</span>
    <span class="token punctuation">[</span> <span class="token variable">$var1</span> -lt <span class="token number">15</span> <span class="token punctuation">]</span>
<span class="token keyword">do</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$var1</span> -gt <span class="token number">5</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">[</span> <span class="token variable">$var1</span> -lt <span class="token number">10</span> <span class="token punctuation">]</span>
    <span class="token keyword">then</span>
        <span class="token builtin class-name">continue</span>
    <span class="token keyword">fi</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;   Inside iteration number: <span class="token variable">$var1</span>&quot;</span>
    <span class="token assign-left variable">var1</span><span class="token operator">=</span>$<span class="token punctuation">[</span> <span class="token variable">$var1</span> + <span class="token number">1</span> <span class="token punctuation">]</span>
<span class="token keyword">done</span>
$ ./badtest3 <span class="token operator">|</span> <span class="token function">more</span>
<span class="token keyword">while</span> iteration: <span class="token number">0</span>
    Inside iteration number: <span class="token number">0</span>
<span class="token keyword">while</span> iteration: <span class="token number">1</span>
    Inside iteration number: <span class="token number">1</span>
<span class="token keyword">while</span> iteration: <span class="token number">2</span>
    Inside iteration number: <span class="token number">2</span>
<span class="token keyword">while</span> iteration: <span class="token number">3</span>
    Inside iteration number: <span class="token number">3</span>
<span class="token keyword">while</span> iteration: <span class="token number">4</span>
    Inside iteration number: <span class="token number">4</span>
<span class="token keyword">while</span> iteration: <span class="token number">5</span>
    Inside iteration number: <span class="token number">5</span>
<span class="token keyword">while</span> iteration: <span class="token number">6</span>
<span class="token keyword">while</span> iteration: <span class="token number">6</span>
<span class="token keyword">while</span> iteration: <span class="token number">6</span>
<span class="token keyword">while</span> iteration: <span class="token number">6</span>
<span class="token keyword">while</span> iteration: <span class="token number">6</span>
<span class="token keyword">while</span> iteration: <span class="token number">6</span>
<span class="token keyword">while</span> iteration: <span class="token number">6</span>
<span class="token keyword">while</span> iteration: <span class="token number">6</span>
<span class="token keyword">while</span> iteration: <span class="token number">6</span>
<span class="token keyword">while</span> iteration: <span class="token number">6</span>
<span class="token keyword">while</span> iteration: <span class="token number">6</span>
</code></pre></div><p>你得确保将脚本的输出重定向到了 more 命令，这样才能停止输出。在 if-then 的条件成立之前，所有一切看起来都很正常，然后 shell 执行了 continue 命令。当 shell 执行 continue 命令时，它跳过了 while 循环中余下的命令。不幸的是，被跳过的部分正是$var1 计数变量增值的地方，而这个变量又被用于 while 测试命令中。这意味着这个变量的值不会再变化了，从前面连续的输出显示中你也可以看出来。</p> <p>和 break 命令一样，continue 命令也允许通过命令行参数指定要继续执行哪一级循环：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">continue</span> n
</code></pre></div><p>其中 n 定义了要继续的循环层级。下面是继续外部 for 循环的一个例子。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test22
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># continuing an outer loop</span>
<span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> a <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> a<span class="token operator">++</span> <span class="token punctuation">))</span></span>
<span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;Iteration <span class="token variable">$a</span>:&quot;</span>
    <span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> b <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> b<span class="token operator">++</span> <span class="token punctuation">))</span></span>
    <span class="token keyword">do</span>
        <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$a</span> -gt <span class="token number">2</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">[</span> <span class="token variable">$a</span> -lt <span class="token number">4</span> <span class="token punctuation">]</span>
        <span class="token keyword">then</span>
            <span class="token builtin class-name">continue</span> <span class="token number">2</span>
        <span class="token keyword">fi</span>
        <span class="token assign-left variable">var3</span><span class="token operator">=</span>$<span class="token punctuation">[</span> <span class="token variable">$a</span> * <span class="token variable">$b</span> <span class="token punctuation">]</span>
        <span class="token builtin class-name">echo</span> <span class="token string">&quot;   The result of <span class="token variable">$a</span> * <span class="token variable">$b</span> is <span class="token variable">$var3</span>&quot;</span>
    <span class="token keyword">done</span>
<span class="token keyword">done</span>

$ ./test22
Iteration <span class="token number">1</span>:
    The result of <span class="token number">1</span> * <span class="token number">1</span> is <span class="token number">1</span>
    The result of <span class="token number">1</span> * <span class="token number">2</span> is <span class="token number">2</span>
Iteration <span class="token number">2</span>:
    The result of <span class="token number">2</span> * <span class="token number">1</span> is <span class="token number">2</span>
    The result of <span class="token number">2</span> * <span class="token number">2</span> is <span class="token number">4</span>
Iteration <span class="token number">3</span>:
Iteration <span class="token number">4</span>:
    The result of <span class="token number">4</span> * <span class="token number">1</span> is <span class="token number">4</span>
    The result of <span class="token number">4</span> * <span class="token number">2</span> is <span class="token number">8</span>
Iteration <span class="token number">5</span>:
    The result of <span class="token number">5</span> * <span class="token number">1</span> is <span class="token number">5</span>
    The result of <span class="token number">5</span> * <span class="token number">2</span> is <span class="token number">10</span>
$
</code></pre></div><p>此处用 continue 命令来停止处理循环内的命令，但会继续处理外部循环。注意，值为 3 的那次迭代并没有处理任何内部循环语句。尽管 continue 命令停止了内部处理过程，但外部循环依然会继续。</p> <h2 id="处理循环的输出"><a href="#处理循环的输出" class="header-anchor">#</a> 处理循环的输出</h2> <p>最后，在 shell 脚本中，你可以对循环的输出使用管道或进行重定向。这可以通过在 done 命令之后添加一个处理命令来实现。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">for</span> <span class="token for-or-select variable">file</span> <span class="token keyword">in</span> /home/rich/*
<span class="token keyword">do</span>
    <span class="token keyword">if</span> <span class="token punctuation">[</span> -d <span class="token string">&quot;<span class="token variable">$file</span>&quot;</span> <span class="token punctuation">]</span>
    <span class="token keyword">then</span>
        <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$file</span> is a directory&quot;</span>
    <span class="token keyword">elif</span>
        <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$file</span> is a file&quot;</span>
    <span class="token keyword">fi</span>
<span class="token keyword">done</span> <span class="token operator">&gt;</span> output.txt
</code></pre></div><p><strong>shell 会将 for 命令的结果重定向到文件 output.txt 中，而不是显示在屏幕上</strong>。考虑下面将 for 命令的输出重定向到文件的例子。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test23
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># redirecting the for output to a file</span>
<span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> a <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> a<span class="token operator">++</span> <span class="token punctuation">))</span></span>
<span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;The number is <span class="token variable">$a</span>&quot;</span>
<span class="token keyword">done</span> <span class="token operator">&gt;</span> test23.txt
<span class="token builtin class-name">echo</span> <span class="token string">&quot;The command is finished.&quot;</span>
$ ./test23
The <span class="token builtin class-name">command</span> is finished.
$ <span class="token function">cat</span> test23.txt
The number is <span class="token number">1</span>
The number is <span class="token number">2</span>
The number is <span class="token number">3</span>
The number is <span class="token number">4</span>
The number is <span class="token number">5</span>
The number is <span class="token number">6</span>
The number is <span class="token number">7</span>
The number is <span class="token number">8</span>
The number is <span class="token number">9</span>
$
</code></pre></div><p>shell 创建了文件 test23.txt 并将 for 命令的输出重定向到这个文件。shell 在 for 命令之后正常显示了 echo 语句。</p> <p>这种方法同样适用于将循环的结果管接给另一个命令。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test24
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># piping a loop to another command</span>
<span class="token keyword">for</span> <span class="token for-or-select variable">state</span> <span class="token keyword">in</span> <span class="token string">&quot;North Dakota&quot;</span> Connecticut Illinois Alabama Tennessee
<span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$state</span> is the next place to go&quot;</span>
<span class="token keyword">done</span> <span class="token operator">|</span> <span class="token function">sort</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;This completes our travels&quot;</span>
$ ./test24
Alabama is the next place to go
Connecticut is the next place to go
Illinois is the next place to go
North Dakota is the next place to go
Tennessee is the next place to go
This completes our travels
$
</code></pre></div><p>state 值并没有在 for 命令列表中以特定次序列出。for 命令的输出传给了 sort 命令，该命令会改变 for 命令输出结果的顺序。运行这个脚本实际上说明了结果已经在脚本内部排好序了。</p> <h2 id="实战例子"><a href="#实战例子" class="header-anchor">#</a> 实战例子</h2> <p>现在你已经看到了 shell 脚本中各种循环的使用方法，来看一些实际应用的例子吧。循环是对系统数据进行迭代的常用方法，无论是目录中的文件还是文件中的数据。下面的一些例子演示了如何使用简单的循环来处理数据。</p> <h3 id="查找可执行文件"><a href="#查找可执行文件" class="header-anchor">#</a> 查找可执行文件</h3> <p>当你从命令行中运行一个程序的时候，Linux 系统会搜索一系列目录来查找对应的文件。这些目录被定义在环境变量 PATH 中。如果你想找出系统中有哪些可执行文件可供使用，只需要扫描 PATH 环境变量中所有的目录就行了。如果要徒手查找的话，就得花点时间了。不过我们可以编写一个小小的脚本，轻而易举地搞定这件事。</p> <p>首先是创建一个 for 循环，对环境变量 PATH 中的目录进行迭代。处理的时候别忘了设置 IFS 分隔符。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span>:
<span class="token keyword">for</span> <span class="token for-or-select variable">folder</span> <span class="token keyword">in</span> <span class="token environment constant">$PATH</span>
<span class="token keyword">do</span>
</code></pre></div><p>现在你已经将各个目录存放在了变量$folder 中，可以使用另一个 for 循环来迭代特定目录中的所有文件。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">for</span> <span class="token for-or-select variable">file</span> <span class="token keyword">in</span> <span class="token variable">$folder</span>/*
<span class="token keyword">do</span>
</code></pre></div><p>最后一步是检查各个文件是否具有可执行权限，你可以使用 if-then 测试功能来实现。</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">if</span> <span class="token punctuation">[</span> -x <span class="token variable">$file</span> <span class="token punctuation">]</span>
<span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;   <span class="token variable">$file</span>&quot;</span>
<span class="token keyword">fi</span>
</code></pre></div><p>好了，搞定了！将这些代码片段组合成脚本就行了。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test25
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># finding files in the PATH</span>
<span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span>:
<span class="token keyword">for</span> <span class="token for-or-select variable">folder</span> <span class="token keyword">in</span> <span class="token environment constant">$PATH</span>
<span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$folder</span>:&quot;</span>
    <span class="token keyword">for</span> <span class="token for-or-select variable">file</span> <span class="token keyword">in</span> <span class="token variable">$folder</span>/*
    <span class="token keyword">do</span>
        <span class="token keyword">if</span> <span class="token punctuation">[</span> -x <span class="token variable">$file</span> <span class="token punctuation">]</span>
        <span class="token keyword">then</span>
            <span class="token builtin class-name">echo</span> <span class="token string">&quot;   <span class="token variable">$file</span>&quot;</span>
        <span class="token keyword">fi</span>
    <span class="token keyword">done</span>
<span class="token keyword">done</span>
$
</code></pre></div><p>运行这段代码时，你会得到一个可以在命令行中使用的可执行文件的列表。输出显示了在环境变量 PATH 所包含的所有目录中找到的全部可执行文件。</p> <h3 id="创建多个用户账户"><a href="#创建多个用户账户" class="header-anchor">#</a> 创建多个用户账户</h3> <p>shell 脚本的目标是让系统管理员过得更轻松。如果你碰巧工作在一个拥有大量用户的环境中，最烦人的工作之一就是创建新用户账户。好在可以使用 while 循环来降低工作的难度。</p> <p>你不用为每个需要创建的新用户账户手动输入 useradd 命令，而是可以将需要添加的新用户账户放在一个文本文件中，然后创建一个简单的脚本进行处理。这个文本文件的格式如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>userid,user name
</code></pre></div><p>第一个条目是你为新用户账户所选用的用户 ID。第二个条目是用户的全名。两个值之间使用逗号分隔，这样就形成了一种名为逗号分隔值的文件格式（或者是.csv）。这种文件格式在电子表格中极其常见，所以你可以轻松地在电子表格程序中创建用户账户列表，然后将其保存成.csv 格式，以备 shell 脚本读取及处理。</p> <p>要读取文件中的数据，得用上一点 shell 脚本编程技巧。我们将 IFS 分隔符设置成逗号，并将其放入 while 语句的条件测试部分。然后使用 read 命令读取文件中的各行。实现代码如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token keyword">while</span> <span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span>’,’ <span class="token builtin class-name">read</span> –r userid name
</code></pre></div><p>read 命令会自动读取.csv 文本文件的下一行内容，所以不需要专门再写一个循环来处理。当 read 命令返回 FALSE 时（也就是读取完整个文件时），while 命令就会退出。妙极了！
要想把数据从文件中送入 while 命令，只需在 while 命令尾部使用一个重定向符就可以了。将各部分处理过程写成脚本如下。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> test26
<span class="token comment">#!/bin/bash</span>
<span class="token comment"># process new user accounts</span>
<span class="token assign-left variable">input</span><span class="token operator">=</span><span class="token string">&quot;users.csv&quot;</span>
<span class="token keyword">while</span> <span class="token assign-left variable"><span class="token environment constant">IFS</span></span><span class="token operator">=</span><span class="token string">','</span> <span class="token builtin class-name">read</span> -r userid name
<span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;adding <span class="token variable">$userid</span>&quot;</span>
    <span class="token function">useradd</span> -c <span class="token string">&quot;<span class="token variable">$name</span>&quot;</span> -m <span class="token variable">$userid</span>
<span class="token keyword">done</span> <span class="token operator">&lt;</span> <span class="token string">&quot;<span class="token variable">$input</span>&quot;</span>
$
</code></pre></div><p>$input 变量指向数据文件，并且该变量被作为 while 命令的重定向数据。users.csv 文件内容如下。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> users.csv
rich,Richard Blum
christine,Christine Bresnahan
barbara,Barbara Blum
tim,Timothy Bresnahan
$
</code></pre></div><p>必须作为 root 用户才能运行这个脚本，因为 useradd 命令需要 root 权限。执行此脚本后，看一眼/etc/passwd 文件，你会发现账户已经创建好了。</p> <hr> <p>循环是编程的一部分。bash shell 提供了三种可用于脚本中的循环命令。for 命令允许你遍历一系列的值，不管是在命令行里提供好的、包含在变量中的还是通过文件扩展匹配获得的文件名和目录名。while 命令使用普通命令或测试命令提供了基于命令条件的循环。只有在命令（或条件）产生退出状态码 0 时，while 循环才会继续迭代指定的一组命令。until 命令也提供了迭代命令的一种方法，但它的迭代是建立在命令（或条件）产生非零退出状态码的基础上。这个特性允许你设置一个迭代结束前都必须满足的条件。可以在 shell 脚本中对循环进行组合，生成多层循环。bash shell 提供了 continue 和 break 命令，允许你根据循环内的不同值改变循环的正常流程。bash shell 还允许使用标准的命令重定向和管道来改变循环的输出。你可以使用重定向来将循环的输出重定向到一个文件或是另一个命令。这就为控制 shell 脚本执行提供了丰富的功能。下一章将会讨论如何和 shell 脚本用户交互。shell 脚本通常并不完全是自成一体的。它们需要在运行时被提供某些外部数据。下一章将讨论各种可用来向 shell 脚本提供实时数据的方法。</p> <h2 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h2> <p><a href="https://archlinuxstudio.github.io/ShellTutorial/#/shellBasic/structured_command" target="_blank" rel="noopener noreferrer">Linux命令行与Shell脚本教程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <a href="https://archlinuxstudio.github.io/ShellTutorial/#/shellBasic/more_structured_command" target="_blank" rel="noopener noreferrer">Linux命令行与Shell脚本教程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">4/4/2022, 11:35:53 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/notes/blog/linux/脚本编程/处理输出.html" class="prev">
            处理输出
          </a></span> <span class="next"><a href="/notes/blog/linux/脚本编程/函数.html">
            函数
          </a></span></p></div> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-22d702a7><li class="level-2" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#if-语句" class="sidebar-link reco-side-if-语句" data-v-22d702a7>if 语句</a></li><li class="level-2" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#嵌套-if" class="sidebar-link reco-side-嵌套-if" data-v-22d702a7>嵌套 if</a></li><li class="level-2" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#test-命令" class="sidebar-link reco-side-test-命令" data-v-22d702a7>test 命令</a></li><li class="level-3" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#数值比较" class="sidebar-link reco-side-数值比较" data-v-22d702a7>数值比较</a></li><li class="level-3" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#字符串比较" class="sidebar-link reco-side-字符串比较" data-v-22d702a7>字符串比较</a></li><li class="level-3" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#文件比较" class="sidebar-link reco-side-文件比较" data-v-22d702a7>文件比较</a></li><li class="level-2" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#复合条件测试" class="sidebar-link reco-side-复合条件测试" data-v-22d702a7>复合条件测试</a></li><li class="level-2" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#if-语句的高级特性" class="sidebar-link reco-side-if-语句的高级特性" data-v-22d702a7>if 语句的高级特性</a></li><li class="level-3" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#使用双括号-常用" class="sidebar-link reco-side-使用双括号-常用" data-v-22d702a7>使用双括号-常用</a></li><li class="level-3" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#使用双方括号" class="sidebar-link reco-side-使用双方括号" data-v-22d702a7>使用双方括号</a></li><li class="level-2" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#case-命令" class="sidebar-link reco-side-case-命令" data-v-22d702a7>case 命令</a></li><li class="level-2" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#for-命令" class="sidebar-link reco-side-for-命令" data-v-22d702a7>for 命令</a></li><li class="level-3" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#读取列表中的值" class="sidebar-link reco-side-读取列表中的值" data-v-22d702a7>读取列表中的值</a></li><li class="level-3" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#从变量读取列表" class="sidebar-link reco-side-从变量读取列表" data-v-22d702a7>从变量读取列表</a></li><li class="level-3" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#从命令读取值" class="sidebar-link reco-side-从命令读取值" data-v-22d702a7>从命令读取值</a></li><li class="level-3" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#更改字段分隔符" class="sidebar-link reco-side-更改字段分隔符" data-v-22d702a7>更改字段分隔符</a></li><li class="level-3" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#用通配符读取目录" class="sidebar-link reco-side-用通配符读取目录" data-v-22d702a7>用通配符读取目录</a></li><li class="level-2" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#c-语言风格的-for-命令" class="sidebar-link reco-side-c-语言风格的-for-命令" data-v-22d702a7>C 语言风格的 for 命令</a></li><li class="level-2" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#while-命令" class="sidebar-link reco-side-while-命令" data-v-22d702a7>while 命令</a></li><li class="level-2" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#until-命令" class="sidebar-link reco-side-until-命令" data-v-22d702a7>until 命令</a></li><li class="level-2" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#嵌套循环" class="sidebar-link reco-side-嵌套循环" data-v-22d702a7>嵌套循环</a></li><li class="level-2" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#循环处理文件数据" class="sidebar-link reco-side-循环处理文件数据" data-v-22d702a7>循环处理文件数据</a></li><li class="level-2" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#控制循环" class="sidebar-link reco-side-控制循环" data-v-22d702a7>控制循环</a></li><li class="level-3" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#break-命令" class="sidebar-link reco-side-break-命令" data-v-22d702a7>break 命令</a></li><li class="level-3" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#continue-命令" class="sidebar-link reco-side-continue-命令" data-v-22d702a7>continue 命令</a></li><li class="level-2" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#处理循环的输出" class="sidebar-link reco-side-处理循环的输出" data-v-22d702a7>处理循环的输出</a></li><li class="level-2" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#实战例子" class="sidebar-link reco-side-实战例子" data-v-22d702a7>实战例子</a></li><li class="level-3" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#查找可执行文件" class="sidebar-link reco-side-查找可执行文件" data-v-22d702a7>查找可执行文件</a></li><li class="level-3" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#创建多个用户账户" class="sidebar-link reco-side-创建多个用户账户" data-v-22d702a7>创建多个用户账户</a></li><li class="level-2" data-v-22d702a7><a href="/notes/blog/linux/%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4.html#参考" class="sidebar-link reco-side-参考" data-v-22d702a7>参考</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/notes/assets/js/app.c9da24a6.js" defer></script><script src="/notes/assets/js/3.15042843.js" defer></script><script src="/notes/assets/js/1.8ca8e0eb.js" defer></script><script src="/notes/assets/js/70.430fd8cd.js" defer></script>
  </body>
</html>
