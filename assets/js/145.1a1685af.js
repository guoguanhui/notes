(window.webpackJsonp=window.webpackJsonp||[]).push([[145],{700:function(r,t,e){"use strict";e.r(t);var a=e(14),_=Object(a.a)({},(function(){var r=this,t=r.$createElement,e=r._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("p",[e("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203251732387.png",alt:"img"}})]),r._v(" "),e("h2",{attrs:{id:"一条mysql更新语句的执行过程是什么样的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一条mysql更新语句的执行过程是什么样的"}},[r._v("#")]),r._v(" 一条MySQL更新语句的执行过程是什么样的？")]),r._v(" "),e("h4",{attrs:{id:"_1-连接验证及解析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-连接验证及解析"}},[r._v("#")]),r._v(" 1.连接验证及解析")]),r._v(" "),e("p",[r._v("客户端与MySQL Server建立连接，发送语句给MySQL Server，接收到后如果是查询语句会先去查询缓存中看，有的话就直接返回了，（新版本的MySQL已经废除了查询缓存，命中率太低了），如果是缓存没有或者是非查询语句，会创建一个解析树，然后进行优化，（解析器知道语句是要执行什么，会评估使用各种索引的代价，然后去使用索引，以及调节表的连接顺序）然后调用innodb引擎的接口来执行语句。")]),r._v(" "),e("h4",{attrs:{id:"_2-写undo-log"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-写undo-log"}},[r._v("#")]),r._v(" 2.写undo log")]),r._v(" "),e("p",[r._v("innodb 引擎首先开启事务，获得一个事务ID(是一直递增的)，根据执行的语句生成一个反向的语句，(如果是INSERT会生成一条DELETE语句，如果UPDATE语句就会生成一个UPDATE成旧数据的语句)，用于提交失败后回滚，将这条反向语句写入undo log，得到回滚指针，并且更新这个数据行的回滚指针和事务id。（事务提交后，Undo log并不能立马被删除，而是放入待清理的链表，由purge 线程判断是否有其他事务在使用undo 段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间，简单的说就是看之前的事务是否提交成功，这个事务及之前的事务都提交成功了，这部分undo log才能删除。）")]),r._v(" "),e("h4",{attrs:{id:"_3-从索引中查找数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-从索引中查找数据"}},[r._v("#")]),r._v(" 3.从索引中查找数据")]),r._v(" "),e("p",[r._v("根据索引去B+树中找到这一行数据（如果是普通索引，查到不符合条件的索引，会把所有数据查找出来，唯一性索引查到第一个数据就可以了）")]),r._v(" "),e("h4",{attrs:{id:"_4-更新数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-更新数据"}},[r._v("#")]),r._v(" 4.更新数据")]),r._v(" "),e("p",[r._v("判断数据页是否在内存中？")]),r._v(" "),e("h4",{attrs:{id:"_4-1数据页在内存中"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-1数据页在内存中"}},[r._v("#")]),r._v(" 4.1数据页在内存中")]),r._v(" "),e("p",[r._v("索引是普通索引还是唯一性索引？")]),r._v(" "),e("h5",{attrs:{id:"_4-1-1普通索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-1普通索引"}},[r._v("#")]),r._v(" 4.1.1普通索引")]),r._v(" "),e("p",[r._v("直接更新内存中的数据页")]),r._v(" "),e("h5",{attrs:{id:"_4-1-2唯一性索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-2唯一性索引"}},[r._v("#")]),r._v(" 4.1.2唯一性索引")]),r._v(" "),e("p",[r._v("判断更新后是否会数据冲突(不能破坏索引的唯一性)，不会的话就更新内存中的数据页。")]),r._v(" "),e("h4",{attrs:{id:"_4-2-数据页不在内存中"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-数据页不在内存中"}},[r._v("#")]),r._v(" 4.2 数据页不在内存中")]),r._v(" "),e("p",[r._v("索引是普通索引还是唯一性索引？")]),r._v(" "),e("h5",{attrs:{id:"_4-2-1普通索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-1普通索引"}},[r._v("#")]),r._v(" 4.2.1普通索引")]),r._v(" "),e("p",[r._v("将对数据页的更新操作记录到change buffer，暂时不更新到磁盘。change buffer会在空闲时异步更新到磁盘。")]),r._v(" "),e("h5",{attrs:{id:"_4-2-2-唯一性索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-2-唯一性索引"}},[r._v("#")]),r._v(" 4.2.2 唯一性索引")]),r._v(" "),e("p",[r._v("因为需要保证更新后的唯一性，所以不能延迟更新，必须把数据页从磁盘加载到内存，然后判断更新后是否会数据冲突，不会的话就更新数据页。")]),r._v(" "),e("h4",{attrs:{id:"_5-写redo-log-prepare状态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-写redo-log-prepare状态"}},[r._v("#")]),r._v(" 5.写redo log（prepare状态）")]),r._v(" "),e("p",[r._v("将对数据页的更改写入到redo log，此时redo log中这条事务的状态为prepare状态。")]),r._v(" "),e("h4",{attrs:{id:"_6-写bin-log-同时将redo-log设置为commit状态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-写bin-log-同时将redo-log设置为commit状态"}},[r._v("#")]),r._v(" 6.写bin log（同时将redo log设置为commit状态）")]),r._v(" "),e("p",[r._v("通知MySQL server已经更新操作写入到redo log 了，随时可以提交，将执行的SQL写入到bin log日志，将redo log 中这条事务的状态改成commit状态，事务提交成功。")]),r._v(" "),e("p",[e("a",{attrs:{href:"https://www.cnblogs.com/yuyue2014/p/6121114.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("https://www.cnblogs.com/yuyue2014/p/6121114.html"),e("OutboundLink")],1)]),r._v(" "),e("h5",{attrs:{id:"undo-log"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#undo-log"}},[r._v("#")]),r._v(" "),e("a",{attrs:{href:"http://notfound9.github.io/interviewGuide/#/docs/MySQLNote?id=undo-log",target:"_blank",rel:"noopener noreferrer"}},[r._v("undo log"),e("OutboundLink")],1)]),r._v(" "),e("p",[r._v("主要是保证事务的原子性，事务执行失败就回滚，用于在事务执行失败后，对数据回滚。")]),r._v(" "),e("p",[r._v("是逻辑日志，记录的是SQL语句。")]),r._v(" "),e("p",[r._v("在事务提交后，undo log日志不会立即删除，会放到一个待删除的链表中，有purge线程判断是否有其他事务在使用上一个事务之前的版本信息，然后决定是否可以清理，简单的来说就是前面的事务都提交成功了，这些undo才能删除。")]),r._v(" "),e("h5",{attrs:{id:"change-buffer是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#change-buffer是什么"}},[r._v("#")]),r._v(" "),e("a",{attrs:{href:"http://notfound9.github.io/interviewGuide/#/docs/MySQLNote?id=change-buffer%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F",target:"_blank",rel:"noopener noreferrer"}},[r._v("change buffer是什么？"),e("OutboundLink")],1)]),r._v(" "),e("p",[e("strong",[r._v("（change buffer就是将更新数据页的操作缓存下来）")])]),r._v(" "),e("p",[r._v("在更新数据时，如果数据行所在的数据页在内存中，直接更新内存中的数据页。")]),r._v(" "),e("p",[r._v("如果不在内存中，为了减少磁盘IO的次数，innodb会将这些更新操作缓存在change buffer中，在下一次查询时需要访问这个数据页时，在执行change buffer中的操作对数据页进行更新。（或者是在MySQL Server空闲时，会将change buffer中所有操作更新到磁盘，也就是俗称的‘刷页’。）")]),r._v(" "),e("p",[r._v("适合写多读少的场景，因为这样即便立即写了，也不太可能会被访问到，延迟更新可以减少磁盘I/O，只有普通索引会用到，因为唯一性索引，在更新时就需要判断唯一性，所以没有必要。")]),r._v(" "),e("h5",{attrs:{id:"redo-log"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redo-log"}},[r._v("#")]),r._v(" "),e("a",{attrs:{href:"http://notfound9.github.io/interviewGuide/#/docs/MySQLNote?id=redo-log",target:"_blank",rel:"noopener noreferrer"}},[r._v("redo log"),e("OutboundLink")],1)]),r._v(" "),e("p",[r._v("就是为了保证事务的持久性，在做数据更新操作时，先将对数据页的更改记录到redo log，然后再去更新内存中的数据页，在下次查询数据页或者空闲时间，将操作记录更新到磁盘。这样可以将随机I/O改为顺序I/O。")]),r._v(" "),e("p",[r._v("优点是减少磁盘I/O次数，即便发生故障也可以根据redo log来将数据恢复到最新状态。")]),r._v(" "),e("p",[r._v("缺点是会造成内存脏页，后台线程会自动对脏页刷盘，或者是淘汰数据页时刷盘，此时会暂时查询操作，影响查询。")]),r._v(" "),e("h5",{attrs:{id:"二段提交制是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二段提交制是什么"}},[r._v("#")]),r._v(" "),e("a",{attrs:{href:"http://notfound9.github.io/interviewGuide/#/docs/MySQLNote?id=%E4%BA%8C%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F",target:"_blank",rel:"noopener noreferrer"}},[r._v("二段提交制是什么？"),e("OutboundLink")],1)]),r._v(" "),e("p",[r._v("更新时，先改内存中的数据页，将更新操作写入redo log日志，此时redo log进入prepare状态，然后通知MySQL Server执行完了，随时可以提交，MySQL Server将更新的SQL写入bin log，然后调用innodb接口将redo log设置为提交状态，更新完成。")]),r._v(" "),e("p",[r._v("如果只是写了bin log就提交，那么忽然发生故障，主节点可以根据redo log恢复数据到最新，但是主从同步时会丢掉这部分更新的数据。")]),r._v(" "),e("p",[r._v("如果只是写binlog，然后写redo log，如果忽然发生故障，主节点根据redo log恢复数据时就会丢掉这部分数据。")]),r._v(" "),e("h5",{attrs:{id:"崩溃恢复时的判断规则-以redolog是否commit或者binlog是否完整来确定"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#崩溃恢复时的判断规则-以redolog是否commit或者binlog是否完整来确定"}},[r._v("#")]),r._v(" "),e("a",{attrs:{href:"http://notfound9.github.io/interviewGuide/#/docs/MySQLNote?id=%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D%E6%97%B6%E7%9A%84%E5%88%A4%E6%96%AD%E8%A7%84%E5%88%99%EF%BC%88%E4%BB%A5redolog%E6%98%AF%E5%90%A6commit%E6%88%96%E8%80%85binlog%E6%98%AF%E5%90%A6%E5%AE%8C%E6%95%B4%E6%9D%A5%E7%A1%AE%E5%AE%9A%EF%BC%89",target:"_blank",rel:"noopener noreferrer"}},[r._v("崩溃恢复时的判断规则（以redolog是否commit或者binlog是否完整来确定）"),e("OutboundLink")],1)]),r._v(" "),e("ol",[e("li",[r._v("如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交；")]),r._v(" "),e("li",[r._v("如果 redo log 里面的事务只有完整的 prepare，则判断对应的事务 binlog 是否存在并完整： a. 如果是，则提交事务； b. 否则，回滚事务。")])]),r._v(" "),e("h2",{attrs:{id:"一-mysql-基础架构分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一-mysql-基础架构分析"}},[r._v("#")]),r._v(" 一 MySQL 基础架构分析")]),r._v(" "),e("h3",{attrs:{id:"_1-1-mysql-基本架构概览"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-mysql-基本架构概览"}},[r._v("#")]),r._v(" 1.1 MySQL 基本架构概览")]),r._v(" "),e("p",[r._v("下图是 MySQL 的一个简要架构图，从下图你可以很清晰的看到用户的 SQL 语句在 MySQL 内部是如何执行的。")]),r._v(" "),e("p",[r._v("先简单介绍一下下图涉及的一些组件的基本作用帮助大家理解这幅图，在 1.2 节中会详细介绍到这些组件的作用。")]),r._v(" "),e("ul",[e("li",[e("strong",[r._v("连接器：")]),r._v(" 身份认证和权限相关(登录 MySQL 的时候)。")]),r._v(" "),e("li",[e("strong",[r._v("查询缓存：")]),r._v(" 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。")]),r._v(" "),e("li",[e("strong",[r._v("分析器：")]),r._v(" 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。")]),r._v(" "),e("li",[e("strong",[r._v("优化器：")]),r._v(" 按照 MySQL 认为最优的方案去执行。")])]),r._v(" "),e("p",[e("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203251732113.png",alt:"img"}})]),r._v(" "),e("p",[r._v("简单来说 MySQL 主要分为 Server 层和存储引擎层：")]),r._v(" "),e("ul",[e("li",[e("strong",[r._v("Server 层")]),r._v("：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。")]),r._v(" "),e("li",[e("strong",[r._v("存储引擎")]),r._v("： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。"),e("strong",[r._v("现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。")])])]),r._v(" "),e("h3",{attrs:{id:"_1-2-server-层基本组件介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-server-层基本组件介绍"}},[r._v("#")]),r._v(" 1.2 Server 层基本组件介绍")]),r._v(" "),e("h4",{attrs:{id:"_1-连接器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-连接器"}},[r._v("#")]),r._v(" 1) 连接器")]),r._v(" "),e("p",[r._v("连接器主要和身份认证和权限相关的功能相关，就好比一个级别很高的门卫一样。")]),r._v(" "),e("p",[r._v("主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即时管理员修改了该用户的权限，该用户也是不受影响的。")]),r._v(" "),e("h4",{attrs:{id:"_2-查询缓存-mysql-8-0-版本后移除"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-查询缓存-mysql-8-0-版本后移除"}},[r._v("#")]),r._v(" 2) 查询缓存(MySQL 8.0 版本后移除)")]),r._v(" "),e("p",[r._v("查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。")]),r._v(" "),e("p",[r._v("连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 sql 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。")]),r._v(" "),e("p",[r._v("MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。")]),r._v(" "),e("p",[r._v("所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。")]),r._v(" "),e("p",[r._v("MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。")]),r._v(" "),e("h4",{attrs:{id:"_3-分析器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-分析器"}},[r._v("#")]),r._v(" 3) 分析器")]),r._v(" "),e("p",[r._v("MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：")]),r._v(" "),e("p",[e("strong",[r._v("第一步，词法分析")]),r._v("，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。")]),r._v(" "),e("p",[e("strong",[r._v("第二步，语法分析")]),r._v("，主要就是判断你输入的 sql 是否正确，是否符合 MySQL 的语法。")]),r._v(" "),e("p",[r._v("完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。")]),r._v(" "),e("h4",{attrs:{id:"_4-优化器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-优化器"}},[r._v("#")]),r._v(" 4) 优化器")]),r._v(" "),e("p",[r._v("优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解），比如"),e("strong",[r._v("多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等")]),r._v("。")]),r._v(" "),e("p",[r._v("可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。")]),r._v(" "),e("h4",{attrs:{id:"_5-执行器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-执行器"}},[r._v("#")]),r._v(" 5) 执行器")]),r._v(" "),e("p",[r._v("当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会"),e("strong",[r._v("去调用存储引擎（例如InnoDB）的接口，返回接口执行的结果")]),r._v("。")]),r._v(" "),e("h2",{attrs:{id:"二-语句分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二-语句分析"}},[r._v("#")]),r._v(" 二 语句分析")]),r._v(" "),e("h3",{attrs:{id:"_2-1-查询语句"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-查询语句"}},[r._v("#")]),r._v(" 2.1 查询语句")]),r._v(" "),e("p",[r._v("说了以上这么多，那么究竟一条 sql 语句是如何执行的呢？其实我们的 sql 可以分为两种，一种是查询，一种是更新（增加，更新，删除）。我们先分析下查询语句，语句如下：")]),r._v(" "),e("div",{staticClass:"language-sql extra-class"},[e("pre",{pre:!0,attrs:{class:"language-sql"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[r._v("select")]),r._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("*")]),r._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[r._v("from")]),r._v(" tb_student  A "),e("span",{pre:!0,attrs:{class:"token keyword"}},[r._v("where")]),r._v(" A"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v(".")]),r._v("age"),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("=")]),e("span",{pre:!0,attrs:{class:"token string"}},[r._v("'18'")]),r._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("and")]),r._v(" A"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v(".")]),r._v("name"),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("=")]),e("span",{pre:!0,attrs:{class:"token string"}},[r._v("' 张三 '")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v(";")]),r._v(" \n")])])]),e("p",[r._v("结合上面的说明，我们分析下这个语句的执行流程：")]),r._v(" "),e("ul",[e("li",[r._v("先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 sql 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。")]),r._v(" "),e("li",[r._v("通过"),e("strong",[r._v("分析器")]),r._v("进行"),e("strong",[r._v("词法分析")]),r._v("，提取 sql 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id='1'。然后判断这个 sql 语句是否有"),e("strong",[r._v("语法错误")]),r._v("，比如关键词是否正确等等，如果检查没问题就执行下一步。")]),r._v(" "),e("li",[r._v("接下来就是"),e("strong",[r._v("优化器")]),r._v("进行确定执行方案，上面的 sql 语句，可以有两种执行方案：  a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。   b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。 那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。")]),r._v(" "),e("li",[r._v("进行权限校验，如果没有权限就会返回错误信息，如果有权限就会"),e("strong",[r._v("调用数据库引擎接口")]),r._v("，返回引擎的执行结果。")])]),r._v(" "),e("h3",{attrs:{id:"_2-2-更新语句"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-更新语句"}},[r._v("#")]),r._v(" 2.2 更新语句")]),r._v(" "),e("p",[r._v("以上就是一条查询 sql 的执行流程，那么接下来我们看看一条更新语句如何执行的呢？sql 语句如下：")]),r._v(" "),e("div",{staticClass:"language-sql extra-class"},[e("pre",{pre:!0,attrs:{class:"language-sql"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[r._v("update")]),r._v(" tb_student A "),e("span",{pre:!0,attrs:{class:"token keyword"}},[r._v("set")]),r._v(" A"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v(".")]),r._v("age"),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("=")]),e("span",{pre:!0,attrs:{class:"token string"}},[r._v("'19'")]),r._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[r._v("where")]),r._v(" A"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v(".")]),r._v("name"),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("=")]),e("span",{pre:!0,attrs:{class:"token string"}},[r._v("' 张三 '")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v(";")]),r._v(" \n")])])]),e("p",[r._v("我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的。其实这条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块是 "),e("strong",[r._v("binlog（归档日志）")]),r._v(" ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 "),e("strong",[r._v("redo log（重做日志）")]),r._v("，我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：")]),r._v(" "),e("ul",[e("li",[r._v("先查询到张三这一条数据，如果有缓存，也是会用到缓存。")]),r._v(" "),e("li",[r._v("然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。")]),r._v(" "),e("li",[r._v("执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。")]),r._v(" "),e("li",[r._v("更新完成。")])]),r._v(" "),e("p",[e("strong",[r._v("这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗?")])]),r._v(" "),e("p",[r._v("这是因为最开始 MySQL 并没有 InnoDB 引擎（InnoDB 引擎是其他公司以插件形式插入 MySQL 的），MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。")]),r._v(" "),e("p",[r._v("并不是说只用一个日志模块不可以，只是 "),e("strong",[r._v("InnoDB 引擎就是通过 redo log 来支持事务的")]),r._v("。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，**为什么 redo log 要引入 prepare 预提交状态？**这里我们用反证法来说明下为什么要这么做？")]),r._v(" "),e("ul",[e("li",[e("strong",[r._v("先写 redo log 直接提交，然后写 binlog")]),r._v("，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 bingog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。")]),r._v(" "),e("li",[e("strong",[r._v("先写 binlog，然后写 redo log")]),r._v("，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。")])]),r._v(" "),e("p",[r._v("如果采用 redo log 两阶段提交的方式就不一样了，写完 binglog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binglog 也已经写完了，这个时候发生了异常重启会怎么样呢？ 这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：")]),r._v(" "),e("ul",[e("li",[r._v("判断 redo log 是否完整，如果判断是完整的，就立即提交。")]),r._v(" "),e("li",[r._v("如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。")])]),r._v(" "),e("p",[r._v("这样就解决了数据一致性的问题。")]),r._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[r._v("#")]),r._v(" 总结")]),r._v(" "),e("p",[e("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203251732338.png",alt:"img"}})]),r._v(" "),e("ol",[e("li",[e("p",[r._v("Buffer Pool 是 MySQL 的一个非常重要的组件，因为针对数据库的增删改操作都是在 Buffer Pool 中完成的")])]),r._v(" "),e("li",[e("p",[r._v("Undo log 记录的是数据操作前的样子")])]),r._v(" "),e("li",[e("p",[r._v("redo log 记录的是数据被操作后的样子（"),e("strong",[r._v("redo log 是 Innodb 存储引擎特有")]),r._v("）")])]),r._v(" "),e("li",[e("p",[e("strong",[r._v("bin log 记录的是整个操作记录（这个对于主从复制具有非常重要的意义）")])])]),r._v(" "),e("li",[e("p",[r._v("从准备更新一条数据到事务的提交的流程描述")]),r._v(" "),e("ol",[e("li",[e("p",[r._v("首先执行器根据 MySQL 的执行计划来查询数据，先是从缓存池中查询数据，如果没有就会去数据库中查询，如果查询到了就将其放到缓存池中")])]),r._v(" "),e("li",[e("p",[r._v("在数据被缓存到缓存池的同时，会写入 undo log 日志文件")])]),r._v(" "),e("li",[e("p",[r._v("更新的动作是在 BufferPool 中完成的，同时会将更新后的数据添加到 redo log buffer 中")])]),r._v(" "),e("li",[e("p",[r._v("完成以后就可以提交事务，在提交的同时会做以下三件事")]),r._v(" "),e("ol",[e("li",[e("p",[r._v("将redo log buffer中的数据刷入到 redo log 文件中")])]),r._v(" "),e("li",[e("p",[r._v("将本次操作记录写入到 bin log文件中")])]),r._v(" "),e("li",[e("p",[r._v("将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记")])])])]),r._v(" "),e("li",[e("p",[r._v("至此表示整个更新事务已经完成")])])])])]),r._v(" "),e("h2",{attrs:{id:"参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[r._v("#")]),r._v(" 参考")]),r._v(" "),e("p",[e("a",{attrs:{href:"https://javaguide.cn/database/mysql/how-sql-executed-in-mysql/#_2-2-%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5",target:"_blank",rel:"noopener noreferrer"}},[r._v("https://javaguide.cn/database/mysql/how-sql-executed-in-mysql/#_2-2-%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5"),e("OutboundLink")],1)]),r._v(" "),e("p",[e("a",{attrs:{href:"https://pdai.tech/md/db/sql-mysql/sql-mysql-execute.html#buffer-pool",target:"_blank",rel:"noopener noreferrer"}},[r._v("https://pdai.tech/md/db/sql-mysql/sql-mysql-execute.html#buffer-pool"),e("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=_.exports}}]);