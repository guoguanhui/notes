(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{601:function(r,t,e){"use strict";e.r(t);var v=e(14),a=Object(v.a)({},(function(){var r=this,t=r.$createElement,e=r._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("h2",{attrs:{id:"基础"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[r._v("#")]),r._v(" 基础")]),r._v(" "),e("p",[r._v("谈到这个问题，我们不得不提提之前 Model1 和 Model2 这两个没有 Spring MVC 的时代。")]),r._v(" "),e("ul",[e("li",[e("p",[e("strong",[r._v("Model1 时代")]),r._v(" : 很多学 Java 后端比较晚的朋友可能并没有接触过 Model1 模式下的 JavaWeb 应用开发。在 Model1 模式下，整个 Web 应用几乎全部用 JSP 页面组成，只用少量的 JavaBean 来处理数据库连接、访问等操作。这个模式下 JSP 即是控制层又是表现层。显而易见，这种模式存在很多问题。比如①将控制逻辑和表现逻辑混杂在一起，导致代码重用率极低；②前端和后端相互依赖，难以进行测试并且开发效率极低；")])]),r._v(" "),e("li",[e("p",[e("strong",[r._v("Model2 时代")]),r._v(" ：学过 Servlet 并做过相关 Demo 的朋友应该了解“"),e("strong",[r._v("Java Bean(Model)+ JSP（View,）+Servlet（Controller）")]),r._v(" ”这种开发模式，这就是"),e("strong",[r._v("早期的 JavaWeb MVC 开发模式")]),r._v("。"),e("strong",[r._v("Model：系统涉及的数据，也就是")]),r._v(" "),e("strong",[r._v("dao 和 bean")]),r._v("**。View：展示模型中的数据，只是用来展示。Controller：处理用户请求都发送给 ，返回数据给 JSP 并展示给用户**。")])])]),r._v(" "),e("p",[r._v("Model2 模式下还存在很多问题，Model2的抽象和封装程度还远远不够，使用Model2进行开发时不可避免地会重复造轮子，这就大大降低了程序的可维护性和复用性。于是很多JavaWeb开发相关的 MVC 框架应运而生比如Struts2，但是 Struts2 比较笨重。随着 Spring 轻量级开发框架的流行，Spring 生态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。"),e("strong",[r._v("相比于 Struts2 ， Spring MVC 使用更加简单和方便，开发效率更高，并且 Spring MVC 运行速度更快")]),r._v("。")]),r._v(" "),e("p",[r._v("MVC 是一种设计模式，Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的Web层的开发，并且它天生与 Spring 框架集成。"),e("strong",[r._v("Spring MVC 下我们一般把后端项目分为 Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台页面)。")])]),r._v(" "),e("h2",{attrs:{id:"spring-mvc-总览"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-mvc-总览"}},[r._v("#")]),r._v(" Spring MVC 总览")]),r._v(" "),e("p",[r._v("Spring MVC是Spring提供的一个强大而灵活的Web框架，它是一款实现了MVC设计模式的、请求驱动的轻量级Web框架。**Spring MVC使用MVC架构模式将Web层的各组件进行了解耦。**借助Spring提供的注解功能，Spring MVC提供了POJO（Plain Ordinary Java Object）的开发模式，使得开发和测试更加简单，开发效率更高。")]),r._v(" "),e("p",[e("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203251647707.png",alt:"img"}})]),r._v(" "),e("p",[e("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203251647723.png",alt:"img"}})]),r._v(" "),e("p",[e("strong",[r._v("流程说明（重要）：")])]),r._v(" "),e("ol",[e("li",[r._v("客户端（浏览器）发送请求，直接请求到 "),e("strong",[r._v("DispatcherServlet")]),r._v("。")]),r._v(" "),e("li",[r._v("DispatcherServlet 根据请求信息调用 "),e("strong",[r._v("HandlerMapping")]),r._v("，解析请求对应的 Handler。")]),r._v(" "),e("li",[r._v("解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 "),e("strong",[r._v("HandlerAdapter")]),r._v(" 适配器处理。")]),r._v(" "),e("li",[r._v("HandlerAdapter 会根据 Handler 来调用真正的处理器开处理请求，并处理相应的业务逻辑。")]),r._v(" "),e("li",[r._v("处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个"),e("strong",[r._v("逻辑上的")]),r._v(" "),e("strong",[r._v("View")]),r._v("。")]),r._v(" "),e("li",[e("strong",[r._v("ViewResolver")]),r._v(" 会根据逻辑 View 查找实际的 View。")]),r._v(" "),e("li",[r._v("DispaterServlet 把返回的 Model 传给 View（视图渲染）。")]),r._v(" "),e("li",[r._v("把 View 返回给请求者（浏览器）")])]),r._v(" "),e("h3",{attrs:{id:"spring-mvc-与三层架构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-mvc-与三层架构"}},[r._v("#")]),r._v(" Spring MVC 与三层架构")]),r._v(" "),e("p",[e("strong",[r._v("MVC： model + view + controller")])]),r._v(" "),e("p",[e("strong",[r._v("三层架构： 展现层（view） + 应用层（service） + 数据访问层（dao）")])]),r._v(" "),e("h4",{attrs:{id:"三层架构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三层架构"}},[r._v("#")]),r._v(" 三层架构")]),r._v(" "),e("p",[e("strong",[r._v("三层架构是指：视图层View、服务层Service、持久层Dao，分别完成不同的功能。")])]),r._v(" "),e("p",[r._v("View层：用于接收用户提交请求的代码在这里编写。")]),r._v(" "),e("p",[r._v("Service层：系统的业务逻辑主要在这里编写。")]),r._v(" "),e("p",[r._v("Dao层：直接操作数据库的代码在这里编写。")]),r._v(" "),e("p",[r._v("为了更好的降低各层间的耦合度，在三层架构程序设计中，采用面向抽象编程。即上层对下层的调用，是通过接口实现的。而下层对上层的真正服务提供者，是下层接口的实现类。服务标准（接口）是相同的，服务提供者（实现类）可以更换。这就实现了层间的耦合。")]),r._v(" "),e("p",[e("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203251647312.webp",alt:"img"}})]),r._v(" "),e("h4",{attrs:{id:"mvc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mvc"}},[r._v("#")]),r._v(" MVC")]),r._v(" "),e("p",[e("strong",[r._v("MVC是指：Model模型、View视图、Controller控件器。")])]),r._v(" "),e("p",[r._v("View：视图，为用户提供使用界面，与用户直接进行交互。")]),r._v(" "),e("p",[r._v("Model：模型，承载数据，并对用户提交请求进行计算的模块。其分为两类，一类称为数据承载Bean，一类称为业务处理Bean。"),e("strong",[r._v("所谓数据承载Bean是指实体类，专门承载业务数据的，如Student、User等。而业务处理Bean则是指Service或Dao对象，专门用于处理用户提交请求的。")])]),r._v(" "),e("p",[r._v("Controller：控制器，用于将用户请求转发给相应的Model进行处理，并处理Model的计算结果向用户提供相应响应。")]),r._v(" "),e("p",[r._v("MVC架构程序的工作流程是这样的：")]),r._v(" "),e("p",[r._v("（1）用户通过View页面向服务端提出请求，可以是表单请求、超链接请求、AJAX请求等。")]),r._v(" "),e("p",[r._v("（2）服务端Controller控制器接收到请求后对请求进行解析，找到相应 的Model对用户请求进行处理。")]),r._v(" "),e("p",[r._v("（3）Model处理后，将处理结果再交给Controller。")]),r._v(" "),e("p",[r._v("（4）Controller在接到处理结果后，根据处理结果找到要作为向客户端发回的响应View页面。页面经渲染（数据填充）后，再发送给客户端。")]),r._v(" "),e("p",[e("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203251647247.webp",alt:"img"}})]),r._v(" "),e("h4",{attrs:{id:"mvc与三层架构的关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mvc与三层架构的关系"}},[r._v("#")]),r._v(" MVC与三层架构的关系")]),r._v(" "),e("p",[e("strong",[r._v("model并不等于数据访问层，view也不等于展现层，controller更不代表应用层。")])]),r._v(" "),e("p",[e("strong",[r._v("实际上MVC只存在三层架构的展现层")])]),r._v(" "),e("p",[r._v("MVC与三层架构很相似，但它们并不一样。如果以三层架构为背景，那么MVC的三个部分分别对应的是什么？")]),r._v(" "),e("p",[r._v("三层架构中的View层简单的说就是跟用户发生直接关系的层，MVC中的V和C就是这样的存在，所以MVC中的V和C均属于三层架构的View层。同时，我们知道MVC中的M（Model）包括了数据承载Bean和业务处理Bean，其中业务处理Bean分为Service或Dao对象，分别对应业务逻辑处理和数据库操作，相应的，它们对应的是三层架构中的Service层和Dao层。")]),r._v(" "),e("p",[r._v("故，它们的关系如下图所示：")]),r._v(" "),e("p",[e("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203251647678.webp",alt:"img"}})]),r._v(" "),e("h4",{attrs:{id:"ssm与三层架构的关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ssm与三层架构的关系"}},[r._v("#")]),r._v(" SSM与三层架构的关系")]),r._v(" "),e("p",[r._v("SSM即SpringMVC、Spring、Mybatis三个框架。它们在三层架构中所处的位置是不同的，即它们在三层架构中的功能各不相同，各司其职。")]),r._v(" "),e("p",[r._v("SpringMVC：作为View层的实现者，完成用户的请求接收功能。SpringMVC的Controller作为整个应用的控制器，完成用户请求的转发及对用户的响应。")]),r._v(" "),e("p",[r._v("MyBatis：作为 Dao层的实现者，完成对数据库的增、删、改、查功能。")]),r._v(" "),e("p",[r._v("Spring：以整个应用大管家的身份出现。整个应用中所有的Bean的生命周期行为，均由Spring来管理。即整个应用中所有对象的创建、初始化、销毁，及对象间关联关系的维护，均由Spring进行管理。")]),r._v(" "),e("p",[e("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203251647376.webp",alt:"img"}})]),r._v(" "),e("h3",{attrs:{id:"spring-mvc常用注解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-mvc常用注解"}},[r._v("#")]),r._v(" Spring MVC常用注解")]),r._v(" "),e("p",[r._v("@Controller, @RequestMapping, @ResponseBody, @RequestBody, @RestController, @PathVariable")]),r._v(" "),e("h4",{attrs:{id:"controller和-restcontroller区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#controller和-restcontroller区别"}},[r._v("#")]),r._v(" @Controller和@RestController区别")]),r._v(" "),e("ol",[e("li",[r._v("@RestController 是一个组合注解， 组合了@Controller和@ResponseBody")]),r._v(" "),e("li",[e("strong",[r._v("Controller")]),r._v(" "),e("strong",[r._v("返回一个页面")]),r._v("**。**单独使用 @Controller 不加 @ResponseBody的话一般使用在要返回一个视图的情况，这种情况属于比较传统的Spring MVC 的应用，对应于前后端不分离的情况。")])]),r._v(" "),e("p",[e("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203251647971.png",alt:"img"}})]),r._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[e("strong",[r._v("@RestController")]),r._v(" **返回JSON 或 XML 形式数据。**但@RestController只返回对象，对象数据直接以 JSON 或 XML 形式写入 HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是目前日常开发所接触的最常用的情况（前后端分离）。")])]),r._v(" "),e("p",[e("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203251648985.png",alt:"img"}})]),r._v(" "),e("ol",{attrs:{start:"4"}},[e("li",[e("p",[e("strong",[r._v("@Controller +@ResponseBody")]),r._v(" "),e("strong",[r._v("返回JSON 或 XML 形式数据")])]),r._v(" "),e("p",[e("strong",[r._v("@ResponseBody")]),r._v(" "),e("strong",[r._v("注解的作用是将")]),r._v(" "),e("strong",[r._v("Controller")]),r._v(" "),e("strong",[r._v("的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到HTTP 响应(Response)对象的 body 中，通常用来返回 JSON 或者 XML 数据，返回 JSON 数据的情况比较多。")])])])]),r._v(" "),e("h3",{attrs:{id:"spring-mvc拦截器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-mvc拦截器"}},[r._v("#")]),r._v(" Spring MVC拦截器")]),r._v(" "),e("ol",[e("li",[r._v("可让普通的Bean实现HanlderInterceptor接口或者继承HandlerInterceptorAdapter类来实现自定义拦截器。")]),r._v(" "),e("li",[r._v("重写preHandle方法，在请求发生前执行。重写postHandle方法，在请求完成后执行。")]),r._v(" "),e("li",[e("strong",[r._v("配置拦截器的Bean")]),r._v("。重写addInterceptors方法，"),e("strong",[r._v("注册拦截器")]),r._v("。")])]),r._v(" "),e("h2",{attrs:{id:"bo-entity-vo-po的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bo-entity-vo-po的区别"}},[r._v("#")]),r._v(" BO，entity，VO，PO的区别？")]),r._v(" "),e("p",[e("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203251647275.png",alt:"img"}})]),r._v(" "),e("h2",{attrs:{id:"restful规范"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#restful规范"}},[r._v("#")]),r._v(" RestFul规范")]),r._v(" "),e("p",[e("strong",[r._v("RESTful是目前最流行的API设计规范，它是用于Web数据接口的设计")]),r._v("。从字面可以看出，他是Rest式的接口，所以我们先了解下什么是Rest。")]),r._v(" "),e("p",[r._v('REST与技术无关，它代表的是一种软件架构风格，REST它是 Representational State Transfer的简称，中文的含义是: "表征状态转移" 或 "'),e("strong",[r._v("表现层状态转化")]),r._v('"。它是基于HTTP、URI、XML、JSON等标准和协议，支持轻量级、跨平台、跨语言的架构设计。')]),r._v(" "),e("h3",{attrs:{id:"一-理解为什么要使用restful-api设计规范"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一-理解为什么要使用restful-api设计规范"}},[r._v("#")]),r._v(" 一. 理解为什么要使用RESTful API设计规范？")]),r._v(" "),e("p",[r._v('在很久以前，工作时间长的同学肯定经历过使用velocity语法来编写html模板代码，也就是说我们的前端页面放在服务器端那边进行编译的，更准确的可以理解为 "前后端没有进行分离"，那么在那个时候，页面、数据及模板渲染操作都是放在服务器端进行的，但是这样做有一个很大的缺点是: 后期维护比较麻烦，前端开发人员还必须掌握velocity相关的语法。因此为了解决这个问题慢慢就出现了前后端分离的思想: 即后端负责数据接口, 前端负责数据渲染, 前端只需要请求下api接口拿到数据，然后再将数据显示出来。因此后端开发人员需要设计api接口，因此为了统一规范: 社区就出现了 RESTful API 规范，其实该规范很早就有的，只是最近慢慢流行起来，RESTful API 可以通过一套统一的接口为所有web相关提供服务，实现前后端分离。')]),r._v(" "),e("h3",{attrs:{id:"二-rest设计原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二-rest设计原则"}},[r._v("#")]),r._v(" 二. Rest设计原则")]),r._v(" "),e("p",[r._v("那么怎么样可以设计成REST的架构规范呢? 需要符合如下的一些原则：")]),r._v(" "),e("ol",[e("li",[r._v("每一个URI代表一种资源;")]),r._v(" "),e("li",[r._v("同一种资源有多种表现形式(xml/json);")]),r._v(" "),e("li",[r._v("所有的操作都是无状态的。")]),r._v(" "),e("li",[r._v("规范统一接口。")]),r._v(" "),e("li",[r._v("返回一致的数据格式。")]),r._v(" "),e("li",[r._v("可缓存(客户端可以缓存响应的内容)。")])]),r._v(" "),e("p",[r._v("符合上述REST原则的架构方式被称作为 RESTful 规范。")]),r._v(" "),e("h3",{attrs:{id:"参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[r._v("#")]),r._v(" 参考")]),r._v(" "),e("p",[e("a",{attrs:{href:"https://www.cnblogs.com/tugenhua0707/p/12153857.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("理解 RESTful API 设计规范 - 龙恩0707 - 博客园"),e("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=a.exports}}]);