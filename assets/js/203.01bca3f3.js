(window.webpackJsonp=window.webpackJsonp||[]).push([[203],{758:function(v,a,t){"use strict";t.r(a);var _=t(14),l=Object(_.a)({},(function(){var v=this,a=v.$createElement,t=v._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"java中有几类的编译"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java中有几类的编译"}},[v._v("#")]),v._v(" Java中有几类的编译？")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("Java属于解释类的语言，它主要包括三种编译器，分别是前端编译，即时编译和提前编译器。其中，即时编译器和提前编译器也被叫做后端编译器。")])]),v._v(" "),t("li",[t("p",[v._v("所谓的前端编译，指的是JDK的Javac等编译器，它的主要作用是将.java文件编译为class文件，更确切地说，它完成了从程序到抽象语法树或者中间字节码的过程。具体地，前端编译主要有三个主要的阶段，分别是：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("解析与填充符号表阶段：首先进行词法和语法的分析，生成抽象语法树，接着产生符号地址和符号信息，用于填充符号表。")])]),v._v(" "),t("li",[t("p",[v._v("注解处理阶段：主要是处理插入式注解，比如lombok工具。")])]),v._v(" "),t("li",[t("p",[v._v("语义分析与字节码生成阶段：该阶段会对程序流等进行分析，并且会解析自动拆装箱，泛型，内部类，foreach等语法糖。最后，编译器会把前面生成的各类信息，如语法树等生成字节码写入到磁盘中。这个阶段还会做一些其他的代码添加等工作，注入clint和init方法的生成以及String底层拼接的转换等。")])])])]),v._v(" "),t("li",[t("p",[v._v("所谓的后端编译，指的是编译器需要将class等中间代码转换为与操作系统底层相关的二进制机器码的过程。这里的后端编译主要包括两类，分别是即时编译器和提前编译器。")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("所谓的即时编译器，指的是在解释执行字节码时，当虚拟机发现某个地方的代码经常出现或者说经常被访问，那么这些代码会被认定为热点代码，虚拟机会把这些热点代码编译成本地机器码，并且会使用各种优化手段进行优化。完成这个任务的就叫做即时编译。")])]),v._v(" "),t("li",[t("p",[v._v("提前编译器，也分为两条路线，分别是类似于c或者C++等编译器的方法，在程序运行之前将字节码编译成系统本地二进制机器码的过程；另一种思路是，提前将即使编译器所要做的编译工作提前保存下来，下次运行时只需要将它们加载进来即可。")])])])])]),v._v(" "),t("h2",{attrs:{id:"即时编译中哪些代码会被编译为本地机器码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#即时编译中哪些代码会被编译为本地机器码"}},[v._v("#")]),v._v(" 即时编译中哪些代码会被编译为本地机器码？")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("所谓的热点代码主要包含两类，分别是：被多次调用的方法以及被多次执行的循环体。")])]),v._v(" "),t("li",[t("p",[v._v("需要说明的是，不管是方法也好，还是循环体也好，编译的对象都是整个方法，而不会是单独的一个循环体。")])])]),v._v(" "),t("h2",{attrs:{id:"即使编译被触发的条件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#即使编译被触发的条件"}},[v._v("#")]),v._v(" 即使编译被触发的条件？")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("上面也说到了，即时编译中出现的热点代码会被编译为本地机器码，但是怎么来衡量这个次数呢？换句话说，即时编译被触发的条件是什么？")])]),v._v(" "),t("li",[t("p",[v._v("为了解决这个问题，即时编译中有两种热点探测的方法，分别是基于采样的热点探测和基于计数器的热点探测。所谓的基于采样的热点探测，顾名思义，就是通过采样也就是周期性的方法去检测各个线程栈中的栈顶，如果发现某个方法经常被出现在栈顶，那么这个方法就被认为是热点代码。此外，所谓基于计数器的热点探测，意思是为方法建立一个计数器，这个计数器用于统计方法被执行的次数，如果次数超出一定阈值则会被认定为热点代码。在HotSpot虚拟机中，使用的是第二种方法，这种方法相对更加精准和严谨。")])])]),v._v(" "),t("h2",{attrs:{id:"什么是逃逸分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是逃逸分析"}},[v._v("#")]),v._v(" 什么是逃逸分析？")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("逃逸分析其实是编译器中的一种优化手段，它的基本原理是：分析对象的动态作用域，当一个对象在一个方法内被定义时，如果它有可能被其他方法所引用，则会称之为方法逃逸；更严重的是，如果这个对象还有可能被其他线程所访问，那么这个被称之为线程逃逸。")])]),v._v(" "),t("li",[t("p",[v._v("对于逃逸分析来说，如果可以确定一个对象不会逃逸到别的方法和线程，那么编译器就会对其进行不同程度的优化。这些优化手段主要分为：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("栈上分配：考虑到在堆上分配对象的内存空间会给垃圾收集等带来压力并会给处理器带来资源耗费，所以如果考虑到一个对象不会逃逸到别的方法和别的线程，那么该对象的内存空间会在栈上分配，并且会随栈帧的消失而释放空间。")])]),v._v(" "),t("li",[t("p",[v._v("标量替换：假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序真正执行的时候将可能不去创建这个对象，而改为直接创建它的若干个被这个方法使用的成员变量来代替。将对象拆分后，除了可以让对象的成员变量在栈上，但这要求它不允许逃逸出方法之外。")])]),v._v(" "),t("li",[t("p",[v._v("同步消除：如果确定一个对象不会逃逸到别的线程，那么可以对同步措施进行解除，因为对这些对象的写并不会发生竞争。")])])])]),v._v(" "),t("li",[t("p",[v._v("目前的逃逸分析其实还不太成熟，因为要判断逃逸分析可能会消耗大量的时间和资源，无法保证逃逸分析带来的性能收益会优于它的消耗。")])])])])}),[],!1,null,null,null);a.default=l.exports}}]);