(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{568:function(a,v,r){"use strict";r.r(v);var t=r(14),_=Object(t.a)({},(function(){var a=this,v=a.$createElement,r=a._self._c||v;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h2",{attrs:{id:"引言"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#引言"}},[a._v("#")]),a._v(" 引言")]),a._v(" "),r("p",[a._v("对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄漏和内存溢出问题，看起来由虚拟机管理内存一切都很美好。不过，也正是因为Java程序员把控制内存的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那排查错误、修正问题将会成为一项异常艰难的工作。")]),a._v(" "),r("h2",{attrs:{id:"运行时数据区域"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#运行时数据区域"}},[a._v("#")]),a._v(" 运行时数据区域")]),a._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231617798.png",alt:"img"}})]),a._v(" "),r("p",[a._v("Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。")]),a._v(" "),r("h3",{attrs:{id:"程序计数器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#程序计数器"}},[a._v("#")]),a._v(" 程序计数器")]),a._v(" "),r("p",[a._v("程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是"),r("strong",[a._v("当前线程所执行的字节码的行号指示器")]),a._v("。在Java虚拟机的概念模型里[1]，"),r("strong",[a._v("字节码解释器工作")]),a._v("时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。")]),a._v(" "),r("p",[a._v("由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，"),r("strong",[a._v("为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储")]),a._v("，我们称这类内存区域为“"),r("strong",[a._v("线程私有")]),a._v("”的内存。")]),a._v(" "),r("p",[a._v("如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。"),r("strong",[a._v("此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。")])]),a._v(" "),r("h3",{attrs:{id:"java虚拟机栈"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java虚拟机栈"}},[a._v("#")]),a._v(" Java虚拟机栈")]),a._v(" "),r("p",[a._v("与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：**每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧[1]（Stack Frame）用于存储"),r("strong",[r("strong",[a._v("局部变量表、操作数栈、动态连接、方法出口")])]),a._v("等信息。**每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。")]),a._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231617685.png",alt:"img"}})]),a._v(" "),r("p",[a._v("局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。")]),a._v(" "),r("p",[a._v("这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。")]),a._v(" "),r("p",[a._v("在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况："),r("strong",[a._v("如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展[2]，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。")])]),a._v(" "),r("h3",{attrs:{id:"本地方法栈"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈"}},[a._v("#")]),a._v(" 本地方法栈")]),a._v(" "),r("p",[a._v("本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。")]),a._v(" "),r("p",[r("strong",[a._v("与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。")])]),a._v(" "),r("h3",{attrs:{id:"java堆"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java堆"}},[a._v("#")]),a._v(" Java堆")]),a._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231617948.png",alt:"img"}})]),a._v(" "),r("p",[a._v("Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。")]),a._v(" "),r("p",[a._v("随着Java语言的发展，现在已经能看到些许迹象表明日后可能出现值类型的支持，即使只考虑现在，由于即时编译技术的进步，尤其是逃逸分析技术的日渐强大，栈上分配、标量替换[2]优化手段已经导致一些微妙的变化悄然发生，所以说"),r("strong",[a._v("Java对象实例都分配在堆上也渐渐变得不是那么绝对了")]),a._v("。")]),a._v(" "),r("p",[a._v("Java堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From Survivor空间”“To Survivor空间”等名词。这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已，"),r("strong",[a._v("而非某个Java虚拟机具体实现的固有内存布局，更不是《Java虚拟机规范》里对Java堆的进一步细致划分")]),a._v("。")]),a._v(" "),r("p",[a._v("根据《Java虚拟机规范》的规定，"),r("strong",[a._v("Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的")]),a._v("，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于大对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。")]),a._v(" "),r("p",[a._v("Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。"),r("strong",[a._v("如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。")])]),a._v(" "),r("h4",{attrs:{id:"对象在堆中的生命周期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对象在堆中的生命周期"}},[a._v("#")]),a._v(" 对象在堆中的生命周期")]),a._v(" "),r("ol",[r("li",[r("p",[a._v("在 JVM 内存模型的堆中，堆被划分为新生代和老年代")]),a._v(" "),r("ul",[r("li",[a._v("新生代又被进一步划分为 "),r("strong",[a._v("Eden区")]),a._v(" 和 "),r("strong",[a._v("Survivor区")]),a._v("，Survivor 区由 "),r("strong",[a._v("From Survivor")]),a._v(" 和 "),r("strong",[a._v("To Survivor")]),a._v(" 组成")])])]),a._v(" "),r("li",[r("p",[a._v("当创建一个对象时，对象会被优先分配到新生代的 Eden 区")]),a._v(" "),r("ul",[r("li",[a._v("此时 JVM 会给对象定义一个"),r("strong",[a._v("对象年轻计数器")]),a._v("（-XX:MaxTenuringThreshold）")])])]),a._v(" "),r("li",[r("p",[a._v("当 Eden 空间不足时，JVM 将执行新生代的垃圾回收（Minor GC）")]),a._v(" "),r("ul",[r("li",[a._v("JVM 会把存活的对象转移到 Survivor 中，并且"),r("strong",[a._v("对象年龄")]),a._v(" +1")]),a._v(" "),r("li",[a._v("对象在 Survivor 中同样也会经历 Minor GC，每经历一次 Minor GC，"),r("strong",[a._v("对象年龄")]),a._v("都会+1")])])]),a._v(" "),r("li",[r("p",[a._v("如果分配的对象超过了-XX:PetenureSizeThreshold，对象会"),r("strong",[a._v("直接被分配到老年代")])])])]),a._v(" "),r("h3",{attrs:{id:"方法区"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#方法区"}},[a._v("#")]),a._v(" 方法区")]),a._v(" "),r("p",[a._v("方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，**它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。**虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“"),r("strong",[a._v("非堆")]),a._v("”（Non-Heap），目的是与Java堆区分开来。")]),a._v(" "),r("p",[a._v("在JDK 8以前，许多Java程序员都习惯在HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为“永久代”（Permanent Generation），或将两者混为一谈。本质上这两者并不是等价的，因为"),r("strong",[a._v("仅仅是当时的HotSpot虚拟机设计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已")]),a._v("，这样使得HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。")]),a._v(" "),r("p",[a._v("原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。但现在回头来看，当年使用永久代来实现方法区的决定并不是一个好主意，这种设计导致了Java应用更容易遇到内存溢出的问题。")]),a._v(" "),r("p",[a._v("考虑到HotSpot未来的发展，在JDK 6的时候HotSpot开发团队就有放弃永久代，逐步改为采用"),r("strong",[a._v("本地内存")]),a._v("（Native Memory）来实现方法区的计划了[1]，到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而"),r("strong",[a._v("到了JDK 8，终于完全废弃了永久代的概念")]),a._v("，改用与JRockit、J9一样"),r("strong",[a._v("在本地内存中实现的元空间（Metaspace）来代替")]),a._v("，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。")]),a._v(" "),r("p",[a._v("《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的确是比较少出现的，**但并非数据进入了方法区就如永久代的名字一样“永久”存在了。****这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。**以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。")]),a._v(" "),r("p",[a._v("根据《Java虚拟机规范》的规定，"),r("strong",[a._v("如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。")])]),a._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231618362.png",alt:"img"}})]),a._v(" "),r("h4",{attrs:{id:"方法区在java8前后的变化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#方法区在java8前后的变化"}},[a._v("#")]),a._v(" 方法区在Java8前后的变化")]),a._v(" "),r("ol",[r("li",[a._v("移除了永久代（PermGen），替换为元空间（Metaspace）；")]),a._v(" "),r("li",[r("strong",[a._v("永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；")])]),a._v(" "),r("li",[r("strong",[a._v("永久代中的 interned Strings 和 class static variables 转移到了 Java heap；")])]),a._v(" "),r("li",[a._v("永久代参数 （PermSize MaxPermSize） -> 元空间参数（MetaspaceSize MaxMetaspaceSize）")])]),a._v(" "),r("p",[a._v("只有 HotSpot 才有永久代的概念")]),a._v(" "),r("table",[r("thead",[r("tr",[r("th",[a._v("jdk1.6及之前")]),a._v(" "),r("th",[a._v("有永久代，静态变量存放在永久代上")])])]),a._v(" "),r("tbody",[r("tr",[r("td",[a._v("jdk1.7")]),a._v(" "),r("td",[a._v("有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中")])]),a._v(" "),r("tr",[r("td",[a._v("jdk1.8及之后")]),a._v(" "),r("td",[a._v("取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，"),r("strong",[a._v("但字符串常量池、静态变量仍在堆中")])])])])]),a._v(" "),r("h4",{attrs:{id:"java8移除永久代的原因"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java8移除永久代的原因"}},[a._v("#")]),a._v(" Java8移除永久代的原因")]),a._v(" "),r("ol",[r("li",[r("p",[a._v("为永久代设置空间大小是很难确定的。")]),a._v(" "),r("ol",[r("li",[a._v("在某些场景下，如果动态加载类过多，容易产生 Perm 区的 OOM。如果某个实际 Web 工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现 OOM。"),r("strong",[a._v("而元空间和永久代最大的区别在于，元空间不在虚拟机中，而是使用本地内存，所以默认情况下，元空间的大小仅受本地内存限制")])])])]),a._v(" "),r("li",[r("p",[a._v("对永久代进行调优较困难")])])]),a._v(" "),r("h4",{attrs:{id:"方法区的垃圾回收"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#方法区的垃圾回收"}},[a._v("#")]),a._v(" 方法区的垃圾回收")]),a._v(" "),r("p",[a._v("方法区的垃圾收集主要回收两部分内容："),r("strong",[a._v("常量池中废弃的常量和不再使用的类")]),a._v("。")]),a._v(" "),r("p",[a._v("先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：")]),a._v(" "),r("ol",[r("li",[r("p",[a._v("类和接口的全限定名")])]),a._v(" "),r("li",[r("p",[a._v("字段的名称和描述符")])]),a._v(" "),r("li",[r("p",[a._v("方法的名称和描述符")])])]),a._v(" "),r("p",[a._v("HotSpot 虚拟机对常量池的回收策略是很明确的，"),r("strong",[a._v("只要常量池中的常量没有被任何地方引用，就可以被回收")])]),a._v(" "),r("p",[a._v("判定一个类型是否属于“"),r("strong",[a._v("不再被使用的类")]),a._v("”，需要同时满足三个条件：")]),a._v(" "),r("ol",[r("li",[r("p",[a._v("该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例")])]),a._v(" "),r("li",[r("p",[a._v("加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常很难达成")])]),a._v(" "),r("li",[r("p",[a._v("该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法")])])]),a._v(" "),r("p",[a._v("Java 虚拟机被允许堆满足上述三个条件的无用类进行回收，"),r("strong",[a._v("这里说的仅仅是“被允许”，而并不是和对象一样，不使用了就必然会回收")]),a._v("。是否对类进行回收，HotSpot 虚拟机提供了 -Xnoclassgc 参数进行控制，还可以使用 -verbose:class 以及 -XX:+TraceClassLoading 、-XX:+TraceClassUnLoading 查看类加载和卸载信息。")]),a._v(" "),r("p",[a._v("在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备"),r("strong",[a._v("类卸载的功能，以保证永久代不会溢出")]),a._v("。")]),a._v(" "),r("h4",{attrs:{id:"运行时常量池"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#运行时常量池"}},[a._v("#")]),a._v(" 运行时常量池")]),a._v(" "),r("p",[r("strong",[a._v("运行时常量池（Runtime Constant Pool）是方法区的一部分")]),a._v("。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，"),r("strong",[a._v("这部分内容将在类加载后存放到方法区的运行时常量池中。")])]),a._v(" "),r("p",[a._v("对于运行时常量池，《Java虚拟机规范》并没有做任何细节的要求，不同提供商实现的虚拟机可以按照自己的需要来实现这个内存区域，不过一般来说，"),r("strong",[a._v("除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中")]),a._v("[1]。")]),a._v(" "),r("p",[a._v("运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，"),r("strong",[a._v("运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。")])]),a._v(" "),r("p",[a._v("既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出"),r("strong",[a._v("OutOfMemoryError")]),a._v("异常。")]),a._v(" "),r("h3",{attrs:{id:"直接内存"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#直接内存"}},[a._v("#")]),a._v(" 直接内存")]),a._v(" "),r("p",[a._v("直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。")]),a._v(" "),r("p",[a._v("在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，**它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。**这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。")]),a._v(" "),r("p",[r("strong",[a._v("数据要输出到外部设备，必须先从用户空间复制到内核空间，再复制到输出设备，而 DirectBuffer 则是直接将步骤简化为从内核空间复制到外部设备，减少了数据拷贝")]),a._v("。详情参考：")]),a._v(" "),r("p",[a._v("此处为语雀内容卡片，点击链接查看："),r("a",{attrs:{href:"https://www.yuque.com/hanchanmingqi-zjjw3/kb/hu2i6p",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://www.yuque.com/hanchanmingqi-zjjw3/kb/hu2i6p"),r("OutboundLink")],1)]),a._v(" "),r("p",[a._v("显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致"),r("strong",[a._v("动态扩展时出现OutOfMemoryError异常。")])]),a._v(" "),r("h2",{attrs:{id:"java各类型变量存放位置"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java各类型变量存放位置"}},[a._v("#")]),a._v(" Java各类型变量存放位置")]),a._v(" "),r("h3",{attrs:{id:"字符串常量池位置"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#字符串常量池位置"}},[a._v("#")]),a._v(" 字符串常量池位置？")]),a._v(" "),r("p",[a._v("在JDK6.0及之前版本，字符串常量池是放在Perm Gen区(也就是方法区)中；")]),a._v(" "),r("p",[a._v("在JDK7.0版本，字符串常量池被移到了堆中了。至于为什么移到堆内，大概是由于方法区的内存空间太小了。），为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。")]),a._v(" "),r("h2",{attrs:{id:"内存划分与oom错误的情况"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内存划分与oom错误的情况"}},[a._v("#")]),a._v(" 内存划分与OOM错误的情况？")]),a._v(" "),r("p",[a._v("StackOverflow Error异常：Java虚拟机栈、本地方法栈；")]),a._v(" "),r("p",[a._v("OutOfMemory Error异常：除程序计数器外的其他四个区域，Java虚拟机栈、本地方法栈、Java堆、方法区；")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("StackOverFlowError: "),r("strong",[a._v("栈内存溢出")]),a._v("，用于深度方法调用（循环递归）")])]),a._v(" "),r("li",[r("p",[a._v("OutOfMemoryError: Java heap space。用于变量申请的空间大于jvm的最大值")])]),a._v(" "),r("li",[r("p",[a._v("OutOfMemoryError: GC overhead limit exceed。"),r("strong",[a._v("GC回收的过长时会抛出OutOfMemoryError")]),a._v("，过长的定义是，超过98%的时间用来做GC并且回收了不到2%的堆内存，连续多次GC都只回收了不到2%的极端情况下才会抛出。假如不抛出GC overhead limit 错误会发生什么情况？那就是GC清理的这么点内存很快会再次填满，迫使GC再次执行，这样就形成恶性循环，CPU使用率一直是100%，而GC却没有任何成果")])]),a._v(" "),r("li",[r("p",[a._v("OutOfMemoryError: Direct buffer memory。"),r("strong",[a._v("堆外内存溢出")]),a._v("，主要呈现在写NIO程序经常使用ByteBuffer来读取或者写入数据，这是一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，**它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。**这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据")])]),a._v(" "),r("li",[r("p",[a._v("OutOfMemoryError: unable to create new native thread。"),r("strong",[a._v("应用创建了太多线程")])])]),a._v(" "),r("li",[r("p",[a._v("OutOfMemoryError: Metaspace。元空间的本质和永久代类似，都是对JVM规范中方法区的实现，**不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。**因此默认情况下，元空间的大小仅受本地内存的限制。")])])]),a._v(" "),r("h2",{attrs:{id:"各内存区域的垃圾回收"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#各内存区域的垃圾回收"}},[a._v("#")]),a._v(" 各内存区域的垃圾回收？")]),a._v(" "),r("h3",{attrs:{id:"方法区的回收"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#方法区的回收"}},[a._v("#")]),a._v(" 方法区的回收")]),a._v(" "),r("p",[r("strong",[a._v("对于方法区（或者说HotSpot虚拟机中的永久代），垃圾回收的主要是回收两部分内容：废弃常量和无用的类。")])]),a._v(" "),r("p",[a._v("对于废弃常量，主要是判断"),r("strong",[a._v("当前系统中有没有对象引用这个常量")]),a._v('，例如一个字符串"abc"已经进入常量池中，但是当前系统没有任何一个String对象是叫做"abc"的，换句话说，就是没有任何String对象引用常量池中的"abc"常量，也没有其他地方引用了这个字面量，如果这时发生了内存回收，而且必要的话，这个"abc"常量就会被系统清理出常量池。')]),a._v(" "),r("p",[a._v("对于无用的类则比较严格，需要满足下面三个条件：")]),a._v(" "),r("ol",[r("li",[r("p",[a._v("该类的所有实例都已经被回收，即"),r("strong",[a._v("堆中不存在该类任何实例")]),a._v("；")])]),a._v(" "),r("li",[r("p",[a._v("加载该类的ClassLoader已经被回收；")])]),a._v(" "),r("li",[r("p",[a._v("类对应的java.lang.Class对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法；")])])]),a._v(" "),r("p",[a._v("满足了上面三个条件也仅仅是“可以”进行回收了，还要根据HotSpot的一些配置参数综合考虑。对于大量使用反射、动态代理、CGLib等字节码框架动态生成类及频繁自定义classLoader的场景，都需要虚拟机具备类卸载的功能，以保证方法区不会溢出。")]),a._v(" "),r("h3",{attrs:{id:"直接内存的回收"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#直接内存的回收"}},[a._v("#")]),a._v(" 直接内存的回收")]),a._v(" "),r("p",[a._v("需注意堆外内存并不直接控制于JVM，这些内存只有在DirectByteBuffer回收掉之后才有机会被回收，而 Young GC 的时候只会将年轻代里不可达的DirectByteBuffer对象及其直接内存回收，如果这些对象大部分都晋升到了年老代，那么只能等到Full GC的时候才能彻底地回收DirectByteBuffer对象及其关联的堆外内存。因此，堆外内存的回收依赖于 Full GC")]),a._v(" "),r("p",[a._v("Full GC一般发生在年老代垃圾回收或者代码调用System.gc的时候，依靠年老代垃圾回收触发 Full GC，进而实现堆外内存的回收显然具有太大的不确定性。**如果年老代一直不进行垃圾回收，那么堆外内存就得不到回收，机器的物理内存可能就会被慢慢耗光。**为了避免这种情况发生，可以通过参数-XX:MaxDirectMemorySize来指定最大的直接内存大小，当其使用达到了阈值的时候将调用System.gc来做一次Full GC，从而完成可控的堆外内存回收。这样做的问题在于，堆外内存的回收依赖于代码调用 System.gc，先捕获到异常，再在Catch块里面通过System.gc()命 令来触发垃圾收集。但如果Java虚拟机再打开了-XX：+DisableExplicitGC开关，禁止了人工触发垃圾 收集的话，根本不会触发Full GC，这样在使用Netty等 NIO 框架时需注意是否会因为这个参数导致直接内存的泄露")]),a._v(" "),r("p",[a._v("直接内存出现OutOfMemoryError的原因是对该区域进行内存分配时，其内存与其他内存加起来超过最大物理内存限制（包括物理的和操作系统级的限制），从而导致OutOfMemoryError。")]),a._v(" "),r("p",[a._v("另外，若我们通过参数“-XX:MaxDirectMemorySize”指定了直接内存的最大值，其超过指定的最大值时，也会抛出内存溢出异常。")])])}),[],!1,null,null,null);v.default=_.exports}}]);