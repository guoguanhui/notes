(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{572:function(t,a,r){"use strict";r.r(a);var v=r(14),s=Object(v.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"回收与引用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#回收与引用"}},[t._v("#")]),t._v(" 回收与引用")]),t._v(" "),r("h2",{attrs:{id:"判断对象是否存活"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#判断对象是否存活"}},[t._v("#")]),t._v(" 判断对象是否存活")]),t._v(" "),r("h3",{attrs:{id:"引用计数法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#引用计数法"}},[t._v("#")]),t._v(" 引用计数法")]),t._v(" "),r("p",[r("strong",[t._v("在对象中添加一个引用计数器")]),t._v("，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。")]),t._v(" "),r("p",[t._v("客观地说，引用计数算法（Reference Counting）虽然占用了一些额外的内存空间来进行计数，但它的原理简单，判定效率也很高，在大多数情况下它都是一个不错的算法。")]),t._v(" "),r("p",[t._v("但是，在Java领域，至少主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就"),r("strong",[t._v("很难解决对象之间相互循环引用的问题")]),t._v("。")]),t._v(" "),r("p",[t._v("对象objA和objB都有字段instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也就无法回收它们。")]),t._v(" "),r("h3",{attrs:{id:"可达性分析法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#可达性分析法"}},[t._v("#")]),t._v(" 可达性分析法")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231626629.png",alt:"img"}})]),t._v(" "),r("p",[t._v("当前主流的商用程序语言（Java、C#，上溯至前面提到的古老的Lisp）的内存管理子系统，都是通过可达性分析（Reachability Analysis）算法来判定对象是否存活的。这个算法的基本思路就是通过"),r("strong",[t._v("一系列称为“GC Roots”的根对象****（当前时刻一定存活的对象）作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。")])]),t._v(" "),r("p",[t._v("在Java技术体系里面，固定可作为"),r("strong",[t._v("GC Roots的对象")]),t._v("包括以下几种：")]),t._v(" "),r("p",[t._v("在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的"),r("strong",[t._v("方法堆栈中使用到的参数、局部变量、临时变量等")]),t._v("。")]),t._v(" "),r("p",[t._v("在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。")]),t._v(" "),r("p",[t._v("在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。")]),t._v(" "),r("p",[t._v("在本地方法栈中JNI（即通常所说的Native方法）引用的对象。")]),t._v(" "),r("p",[t._v("Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有"),r("strong",[t._v("系统类加载器")]),t._v("。")]),t._v(" "),r("p",[r("strong",[t._v("所有被同步锁（synchronized关键字）持有的对象。")])]),t._v(" "),r("p",[t._v("反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。")]),t._v(" "),r("p",[t._v("除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。")]),t._v(" "),r("h2",{attrs:{id:"引用及其分类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#引用及其分类"}},[t._v("#")]),t._v(" 引用及其分类")]),t._v(" "),r("h3",{attrs:{id:"引用的定义"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#引用的定义"}},[t._v("#")]),t._v(" 引用的定义")]),t._v(" "),r("p",[t._v("狭窄定义："),r("strong",[t._v("如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表某块内存、某个对象的引用。")])]),t._v(" "),r("p",[t._v("这种定义并没有什么不对，只是现在看来有些过于狭隘了，一个对象在这种定义下只有“被引用”或者“未被引用”两种状态，对于描述一些“食之无味，弃之可惜”的对象就显得无能为力。譬如我们希望能描述一类对象：当内存空间还足够时，能保留在内存之中，如果内存空间在进行垃圾收集后仍然非常紧张，那就可以抛弃这些对象——很多系统的缓存功能都符合这样的应用场景。")]),t._v(" "),r("h3",{attrs:{id:"引用的分类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#引用的分类"}},[t._v("#")]),t._v(" 引用的分类")]),t._v(" "),r("ol",[r("li",[r("p",[t._v("强引用：强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。")])]),t._v(" "),r("li",[r("p",[t._v("软引用：是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，"),r("strong",[t._v("在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常")]),t._v("。")]),t._v(" "),r("ol",[r("li",[t._v("软引用可以和一个引用队列（ReferenceQueue）联合使用，"),r("strong",[t._v("如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中")]),t._v("。")])])]),t._v(" "),r("li",[r("p",[t._v("弱引用：也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。")]),t._v(" "),r("ol",[r("li",[t._v("弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。")])])]),t._v(" "),r("li",[r("p",[t._v("虚引用：也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也"),r("strong",[t._v("无法通过虚引用来取得一个对象实例")]),t._v("。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。")]),t._v(" "),r("ol",[r("li",[r("p",[r("strong",[t._v("虚引用主要用来跟踪对象被垃圾回收的活动")]),t._v("。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("虚引用与软引用和弱引用的一个区别在于：")]),t._v(" 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。"),r("strong",[t._v("程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动")]),t._v("。")])]),t._v(" "),r("li",[r("p",[t._v("特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为"),r("strong",[t._v("软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生")]),t._v("。")])])])])]),t._v(" "),r("h2",{attrs:{id:"非死不可"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#非死不可"}},[t._v("#")]),t._v(" 非死不可？？")]),t._v(" "),r("p",[t._v("即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段，要真正宣告一个对象死亡，"),r("strong",[t._v("至少要经历两次标记过程")]),t._v("：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是"),r("strong",[t._v("此对象是否有必要执行finalize()方法")]),t._v("。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。")]),t._v(" "),r("p",[t._v("如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、"),r("strong",[t._v("低调度优先级的Finalizer线程去执行它们的finalize()方法")]),t._v("。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。")]),t._v(" "),r("p",[t._v("finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个"),r("strong",[t._v("类变量或者对象的成员变量")]),t._v("，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了")]),t._v(" "),r("p",[t._v("尽量避免使用它，因为它并不能等同于C和C++语言中的析构函数，而是Java刚诞生时为了使传统C、C++程序员更容易接受Java所做出的一项妥协。"),r("strong",[t._v("它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序")]),t._v("，如今已被官方明确声明为不推荐使用的语法。")]),t._v(" "),r("h2",{attrs:{id:"回收方法区"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#回收方法区"}},[t._v("#")]),t._v(" 回收方法区")]),t._v(" "),r("p",[t._v("有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，《Java虚拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集，"),r("strong",[t._v("事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在")]),t._v("（如JDK 11时期的ZGC收集器就不支持类卸载），方法区垃圾收集的“性价比”通常也是比较低的：在Java堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常可以回收70%至99%的内存空间，相比之下，"),r("strong",[t._v("方法区回收囿于苛刻的判定条件，其区域垃圾收集的回收成果往往远低于此。")])]),t._v(" "),r("p",[t._v("方法区的垃圾收集主要回收两部分内容："),r("strong",[t._v("废弃的常量和不再使用的类型")]),t._v("。")]),t._v(" "),r("p",[r("strong",[t._v("回收废弃常量")]),t._v("与回收Java堆中的对象非常类似。举个常量池中字面量回收的例子，假如一个字符串“java”曾经进入常量池中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，"),r("strong",[t._v("已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量")]),t._v("。如果在这时发生内存回收，而且垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类（接口）、方法、字段的符号引用也与此类似。")]),t._v(" "),r("p",[t._v("判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“"),r("strong",[t._v("不再被使用的类")]),t._v("”的条件就比较苛刻了。需要同时满足下面三个条件：")]),t._v(" "),r("p",[t._v("该类所有的实例都已经被回收，也就是"),r("strong",[t._v("Java堆中不存在该类及其任何派生子类的实例")]),t._v("。")]),t._v(" "),r("p",[r("strong",[t._v("加载该类的类加载器已经被回收")]),t._v("，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。")]),t._v(" "),r("p",[t._v("该类对应的"),r("strong",[t._v("java.lang.Class对象没有在任何地方被引用")]),t._v("，无法在任何地方通过反射访问该类的方法。")]),t._v(" "),r("p",[t._v("Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的"),r("strong",[t._v("仅仅是“被允许”")]),t._v("，而并不是和对象一样，没有引用了就必然会回收。")]),t._v(" "),r("p",[r("strong",[t._v("在大量使用反射、动态代理、CGLib等字节码框架")]),t._v("，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。")]),t._v(" "),r("h1",{attrs:{id:"垃圾收集算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集算法"}},[t._v("#")]),t._v(" 垃圾收集算法")]),t._v(" "),r("h2",{attrs:{id:"分代收集理论"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分代收集理论"}},[t._v("#")]),t._v(" 分代收集理论")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。")])]),t._v(" "),r("li",[r("p",[t._v("强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。")])]),t._v(" "),r("li",[r("p",[t._v("跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。")])])]),t._v(" "),r("p",[t._v("这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（"),r("strong",[t._v("年龄即对象熬过垃圾收集过程的次数")]),t._v("）分配到不同的区域之中存储。显而易见，"),r("strong",[t._v("如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。")])]),t._v(" "),r("p",[t._v("把分代收集理论具体放到现在的商用Java虚拟机里，设计者一般至少会把Java堆划分为新生代（Young Generation）和老年代（Old Generation）两个区域[2]。顾名思义，在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。")]),t._v(" "),r("p",[t._v("分代收集并非只是简单划分一下内存区域那么容易，它至少存在一个明显的困难："),r("strong",[t._v("对象不是孤立的，对象之间会存在跨代引用。但")]),t._v("存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。举个例子，如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。")]),t._v(" "),r("p",[t._v("部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：")]),t._v(" "),r("p",[t._v("新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。")]),t._v(" "),r("p",[t._v("老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。"),r("strong",[t._v("目前只有CMS收集器会有单独收集老年代的行为")]),t._v("。")]),t._v(" "),r("p",[t._v("混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。"),r("strong",[t._v("目前只有G1收集器会有这种行为")]),t._v("。")]),t._v(" "),r("p",[t._v("整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。")]),t._v(" "),r("h2",{attrs:{id:"标记清除算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#标记清除算法"}},[t._v("#")]),t._v(" 标记清除算法")]),t._v(" "),r("p",[t._v("算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，"),r("strong",[t._v("也可以反过来")]),t._v("，标记存活的对象，统一回收所有未被标记的对象。标记过程就是对象是否属于垃圾的判定过程。")]),t._v(" "),r("p",[t._v("之所以说它是最基础的收集算法，是因为后续的收集算法大多都是以标记-清除算法为基础，对其缺点进行改进而得到的。它的主要缺点有两个：")]),t._v(" "),r("p",[t._v("第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致"),r("strong",[t._v("标记和清除两个过程的执行效率都随对象数量增长而降低")]),t._v("；")]),t._v(" "),r("p",[t._v("第二个是"),r("strong",[t._v("内存空间的碎片化问题")]),t._v("，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231629578.png",alt:"img"}})]),t._v(" "),r("h2",{attrs:{id:"标记复制算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#标记复制算法"}},[t._v("#")]),t._v(" 标记复制算法")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231626098.png",alt:"img"}})]),t._v(" "),r("p",[t._v("标记-复制算法常被简称为复制算法。")]),t._v(" "),r("p",[t._v("为了解决标记-清除算法面对大量可回收对象时执行效率低的问题，1969年Fenichel提出了一种称为“半区复制”（Semispace Copying）的垃圾收集算法，它"),r("strong",[t._v("将可用内存按容量划分为大小相等的两块")]),t._v("，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，"),r("strong",[t._v("只要移动堆顶指针，按顺序分配即可")]),t._v("。")]),t._v(" "),r("p",[t._v("这样实现简单，运行高效，不过其缺陷也显而易见，这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一点。")]),t._v(" "),r("p",[t._v("现在的商用Java虚拟机大多都优先采用了这种收集算法去回收"),r("strong",[t._v("新生代")]),t._v("，IBM公司曾有一项专门研究对新生代“朝生夕灭”的特点做了更量化的诠释——"),r("strong",[t._v("新生代中的对象有98%熬不过第一轮收集")]),t._v("。因此并不需要按照1∶1的比例来划分新生代的内存空间。")]),t._v(" "),r("p",[t._v("在1989年，Andrew Appel针对具备“朝生夕灭”特点的对象，提出了一种"),r("strong",[t._v("更优化的半区复制分代策略")]),t._v("，现在称为“Appel式回收”。HotSpot虚拟机的Serial、ParNew等新生代收集器均采用了这种策略来设计新生代的内存布局[1]。Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。**HotSpot虚拟机默认Eden和Survivor的大小比例是****8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即10%的新生代是会被“浪费”的。**当然，98%的对象可被回收仅仅是“普通场景”下测得的数据，任何人都没有办法百分百保证每次回收都只有不多于10%的对象存活，因此Appel式回收还有一个充当罕见情况的“逃生门”的安全设计，当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）。")]),t._v(" "),r("h2",{attrs:{id:"标记整理算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#标记整理算法"}},[t._v("#")]),t._v(" 标记整理算法")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231629600.png",alt:"img"}})]),t._v(" "),r("p",[t._v("标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以"),r("strong",[t._v("在老年代一般不能直接选用这种算法。")])]),t._v(" "),r("p",[t._v("针对老年代对象的存亡特征，1974年Edward Lueders提出了另外一种有针对性的“标记-整理”（Mark-Compact）算法，"),r("strong",[t._v("其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让****所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存")]),t._v("。")]),t._v(" "),r("p",[t._v("标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策：")]),t._v(" "),r("p",[t._v("如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，"),r("strong",[t._v("移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行")]),t._v("[1]，这就更加让使用者不得不小心翼翼地权衡其弊端了，像这样的停顿被最初的虚拟机设计者形象地描述为“"),r("strong",[t._v("Stop The World")]),t._v("”[2]。")]),t._v(" "),r("p",[t._v("但如果跟标记-清除算法那样完全不考虑移动和整理存活对象的话，弥散于堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决。譬如通过“"),r("strong",[t._v("分区空闲分配链表")]),t._v("”来解决内存分配问题（计算机硬盘存储大文件就不要求物理连续的磁盘空间，能够在碎片化的硬盘上存储和访问就是通过硬盘分区表实现的）。内存的访问是用户程序最频繁的操作，甚至都没有之一，假如在这个环节上增加了额外的负担，势必"),r("strong",[t._v("会直接影响应用程序的吞吐量")]),t._v("。")]),t._v(" "),r("p",[t._v("基于以上两点，是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂。"),r("strong",[t._v("从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算")]),t._v("。")]),t._v(" "),r("p",[t._v("即使不移动对象会使得收集器的效率提升一些，但因内存分配和访问相比垃圾收集频率要高得多，这部分的耗时增加，总吞吐量仍然是下降的。"),r("strong",[t._v("HotSpot虚拟机里面关注吞吐量的ParallelScavenge收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的，这也从侧面印证这点。")])]),t._v(" "),r("p",[t._v("另外，还有一种“和稀泥式”解决方案可以不在内存分配和访问上增加太大额外负担，做法是让虚拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。"),r("strong",[t._v("前面提到的基于标记-清除算法的CMS收集器面临空间碎片过多时采用的就是这种处理办法")]),t._v("。")]),t._v(" "),r("h1",{attrs:{id:"jvm-内存分配与回收"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#jvm-内存分配与回收"}},[t._v("#")]),t._v(" JVM 内存分配与回收")]),t._v(" "),r("h3",{attrs:{id:"对象优先在eden分配"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对象优先在eden分配"}},[t._v("#")]),t._v(" 对象优先在Eden分配")]),t._v(" "),r("p",[t._v("当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC。现在的商业虚拟机一般都采用复制算法来回收新生代，将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。 当进行垃圾回收时，将Eden和Survivor中还存活的对象一次性地复制到另外一块空闲的Survivor空间上，最后处理掉Eden和刚才的Survivor空间。（HotSpot虚拟机默认Eden和Survivor的大小比例是8:1）当Survivor空间不够用时，需要依赖老年代进行分配担保。")]),t._v(" "),r("h3",{attrs:{id:"大对象直接进入老年代"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#大对象直接进入老年代"}},[t._v("#")]),t._v(" 大对象直接进入老年代")]),t._v(" "),r("p",[t._v("所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组，为了避免大对象在Eden和两个Survivor区之间进行来回复制，所以当对象超过-XX:+PrintTenuringDistribution参数设置的大小时，直接从老年代分配")]),t._v(" "),r("h3",{attrs:{id:"长期存活的对象将进入老年代"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#长期存活的对象将进入老年代"}},[t._v("#")]),t._v(" 长期存活的对象将进入老年代")]),t._v(" "),r("p",[t._v("当对象在新生代中经历过一定次数（XX:MaxTenuringThreshold参数设置的次数，默认为15）的Minor GC后，就会被晋升到老年代中。")]),t._v(" "),r("h3",{attrs:{id:"动态对象年龄判定"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#动态对象年龄判定"}},[t._v("#")]),t._v(" 动态对象年龄判定")]),t._v(" "),r("p",[t._v("为了更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中某个年龄所有对象大小的总和>Survivor空间的50%，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。")]),t._v(" "),r("p",[t._v("Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 "),r("strong",[t._v("堆")]),t._v(" 内存中对象的分配与回收。")]),t._v(" "),r("p",[t._v("Java 堆是垃圾收集器管理的主要区域，因此也被称作"),r("strong",[t._v("GC 堆（Garbage Collected Heap）")]),t._v(".从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。"),r("strong",[t._v("进一步划分的目的是更好地回收内存，或者更快地分配内存。")])]),t._v(" "),r("p",[r("strong",[t._v("堆空间的基本结构：")])]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231626490.png",alt:"img"}})]),t._v(" "),r("p",[t._v('上图所示的 Eden 区、From Survivor0("From") 区、To Survivor1("To") 区都属于新生代，Old Memory 区属于老年代。')]),t._v(" "),r("p",[t._v("大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 "),r("code",[t._v("-XX:MaxTenuringThreshold")]),t._v(" 来设置。")]),t._v(" "),r("p",[t._v("修正（"),r("a",{attrs:{href:"https://github.com/Snailclimb/JavaGuide/issues/552",target:"_blank",rel:"noopener noreferrer"}},[t._v("issue552"),r("OutboundLink")],1),t._v("）：“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。")]),t._v(" "),r("p",[r("strong",[t._v("动态年龄计算的代码如下")])]),t._v(" "),r("div",{staticClass:"language-JAVA extra-class"},[r("pre",{pre:!0,attrs:{class:"language-java"}},[r("code",[t._v("uint ageTable"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("compute_tenuring_threshold")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("size_t survivor_capacity"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),r("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//survivor_capacity是survivor空间的大小")]),t._v("\n  size_t desired_survivor_size "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("size_t"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" survivor_capacity"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),r("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TargetSurvivorRatio")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  size_t total "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  uint age "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("age "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" table_size"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    total "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" sizes"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("age"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),r("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//sizes数组是每个年龄段对象大小")]),t._v("\n    "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("total "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" desired_survivor_size"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    age"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  uint result "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" age "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MaxTenuringThreshold")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" age "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MaxTenuringThreshold")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),r("p",[t._v('经过这次 GC 后，Eden 区和"From"区已经被清空。这个时候，"From"和"To"会交换他们的角色，也就是新的"To"就是上次 GC 前的“From”，新的"From"就是上次 GC 前的"To"。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，直到“To”区被填满，"To"区被填满之后，会将所有对象移动到老年代中。')]),t._v(" "),r("p",[r("strong",[t._v("额外补充说明(")]),r("a",{attrs:{href:"https://github.com/Snailclimb/JavaGuide/issues/672",target:"_blank",rel:"noopener noreferrer"}},[t._v("issue672"),r("OutboundLink")],1),r("strong",[t._v(")：**"),r("strong",[t._v("关于默认的晋升年龄是 15，这个说法的来源大部分都是《深入理解 Java 虚拟机》这本书。")]),t._v(" "),r("strong",[t._v("如果你去 Oracle 的官网阅读")]),r("a",{attrs:{href:"https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("相关的虚拟机参数"),r("OutboundLink")],1)]),t._v("，你会发现****-XX:MaxTenuringThreshold=threshold这里有个说明：**")]),t._v(" "),r("p",[t._v("**Sets the maximum tenuring threshold for use in adaptive GC sizing. The largest value is 15. The default value is 15 for the parallel (throughput) collector, and 6 for the CMS collector.**"),r("strong",[t._v("默认晋升年龄并不都是 15，这个是要区分垃圾收集器的，CMS 就是 6.")])]),t._v(" "),r("h1",{attrs:{id:"minorgc和fullgc是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#minorgc和fullgc是什么"}},[t._v("#")]),t._v(" MinorGC和FullGC是什么？")]),t._v(" "),r("p",[t._v("Minor GC：对新生代进行回收，不会影响到年老代。因为新生代的 Java 对象大多死亡频繁，所以 Minor GC 非常频繁，一般在这里使用速度快、效率高的算法，使垃圾回收能尽快完成。")]),t._v(" "),r("p",[t._v("Full GC：也叫 Major GC，对整个堆进行回收，包括新生代和老年代。由于Full GC需要对整个堆进行回收，所以比Minor GC要慢，因此应该尽可能减少Full GC的次数，导致Full GC的原因包括：老年代被写满和System.gc()被显式调用等。")]),t._v(" "),r("h2",{attrs:{id:"触发minor-gc的条件有哪些"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#触发minor-gc的条件有哪些"}},[t._v("#")]),t._v(" 触发Minor GC的条件有哪些？")]),t._v(" "),r("p",[t._v("1.为新对象分配内存时，新生代的Eden区空间不足。 新生代回收日志：")]),t._v(" "),r("h2",{attrs:{id:"触发full-gc的条件有哪些"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#触发full-gc的条件有哪些"}},[t._v("#")]),t._v(" 触发Full GC的条件有哪些？")]),t._v(" "),r("p",[t._v("主要分为三种：")]),t._v(" "),r("h3",{attrs:{id:"_1-system-gc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-system-gc"}},[t._v("#")]),t._v(" 1.system.gc()")]),t._v(" "),r("p",[t._v("代码中调用system.gc()方法，建议JVM进行垃圾回收。")]),t._v(" "),r("h3",{attrs:{id:"_2-方法区空间不足"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-方法区空间不足"}},[t._v("#")]),t._v(" 2.方法区空间不足")]),t._v(" "),r("p",[t._v("方法区中存放的是一些类的信息，当系统中要加载的类、反射的类和调用的方法较多时，方法区可能会被占满，触发 Full GC")]),t._v(" "),r("h3",{attrs:{id:"_3-老年代空间不足"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-老年代空间不足"}},[t._v("#")]),t._v(" 3.老年代空间不足")]),t._v(" "),r("p",[t._v("而老年代空间不足又有很多种情况：")]),t._v(" "),r("p",[r("strong",[t._v("3.1 Minor GC后，老年代存放不下晋升对象")]),t._v(" 在进行 MinorGC 时， Survivor Space 放不下存活的对象，此时会让这些对象晋升，只能将它们放入老年代，而此时老年代也放不下时造成的。 还有一些情况也会导致新生代对象晋升，例如存活对象经历的垃圾回收次数超过一定次数（XX:MaxTenuringThreshold参数设置的次数，默认为15），那么会导致晋升， 或者在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。")]),t._v(" "),r("p",[r("strong",[t._v("3.2 Concurrent Mode Failure")]),t._v(" 在执行 CMS GC 的过程中，同时有对象要放入老年代，而此时老年代空间不足造成的。")]),t._v(" "),r("p",[r("strong",[t._v("3.3 历次晋升的对象平均大小>老年代的剩余空间")]),t._v(" 这是一个较为复杂的触发情况， HotSpot为了避免由于新生代对象晋升到老年代导致老年代空间不足的现象， 在进行 Minor GC时，做了一个判断，如果之前统计所得到的 MinorGC 晋升到老年代的平均大小大于老年代的剩余空间，那么就直接触发 Full GC。")]),t._v(" "),r("p",[r("strong",[t._v("3.4 老年代空间不足以为大对象分配内存")]),t._v(" 因为超过阀值(-XX:+PrintTenuringDistribution参数设置的大小时)的大对象，会直接分配到老年代，如果老年代空间不足，会触发Full GC。")])])}),[],!1,null,null,null);a.default=s.exports}}]);