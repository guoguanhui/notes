(window.webpackJsonp=window.webpackJsonp||[]).push([[190],{745:function(t,o,e){"use strict";e.r(o);var n=e(14),a=Object(n.a)({},(function(){var t=this,o=t.$createElement,e=t._self._c||o;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"总览"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总览"}},[t._v("#")]),t._v(" 总览")]),t._v(" "),e("p",[t._v("组合模式是"),e("strong",[t._v("将对象组合成树形结构")]),t._v("，以表示“部分-整体”的层次结构（一般是树形结构），用户可以像处理一个简单对象一样来处理一个复杂对象，从而使得调用者无须了解复杂元素的内部结构。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203281030044.png",alt:"img"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203281030995.png",alt:"img"}})]),t._v(" "),e("p",[t._v("组合模式中的角色如下所述。")]),t._v(" "),e("ul",[e("li",[t._v("抽象组件（Component）： Component接口定义了树形结构中所有类的公共行为，例如这里的operation（）方法。一般情况下，其中还会定义一些用于管理子组件的方法，例如这里的add（）、remove（）、getChild（）方法。")]),t._v(" "),e("li",[t._v("树叶（Leaf）： Leaf在树形结构中表示叶节点对象，叶节点没有子节点。")]),t._v(" "),e("li",[t._v("树枝（Composite）： 定义有子组件的那些组件的行为。该角色用于管理子组件，并通过operation（）方法调用其管理的子组件的相关操作。")]),t._v(" "),e("li",[t._v("调用者（Client）： 通过Component接口操纵整个树形结构。")])]),t._v(" "),e("p",[t._v("组合模式主要有两点好处：")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("首先组合模式可以帮助调用者屏蔽对象的复杂性。"),e("strong",[t._v("对于调用者来说，使用整个树形结构与使用单个Component对象没有任何区别， 也就是说， 调用者并不必关心自己处理的是单个Component对象还是整个树形结构")]),t._v("，这样就可以将调用者与复杂对象进行解耦。")])]),t._v(" "),e("li",[e("p",[t._v("另外，使用了组合模式之后，我们可以通过增加树中节点的方式，添加新的Component对象，从而实现功能上的扩展，这符合“开放-封闭”原则，也可以简化日后的维护工作。")])])]),t._v(" "),e("p",[t._v("组合模式在带来上述好处的同时，也会引入一些问题。例如，有些场景下程序希望一个组合结构中只能有某些特定的组件，此时就很难直接通过组件类型进行限制（因为都是Component接口的实现类），这就必须在运行时进行类型检测。而且，在递归程序中定位问题也是一件比较复杂的事情。")]),t._v(" "),e("p",[t._v("**MyBatis在处理动态SQL节点时，应用到了组合设计模式。**MyBatis会将动态SQL节点解析成对应的SqlNode实现。")])])}),[],!1,null,null,null);o.default=a.exports}}]);