(window.webpackJsonp=window.webpackJsonp||[]).push([[201],{756:function(v,_,r){"use strict";r.r(_);var a=r(14),t=Object(a.a)({},(function(){var v=this,_=v.$createElement,r=v._self._c||_;return r("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[r("h2",{attrs:{id:"cms垃圾收集器和g1垃圾收集器对比"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cms垃圾收集器和g1垃圾收集器对比"}},[v._v("#")]),v._v(" CMS垃圾收集器和G1垃圾收集器对比")]),v._v(" "),r("ol",[r("li",[r("p",[v._v("CMS垃圾收集器全称是concurrentMarkSweep，意思是并发标记清除垃圾收集。从名字可以可以知道，CMS使用的是并发清除的算法。实际上，这是一款老年代的垃圾收集器，它十分注重最短回收停顿时间，希望给用户带来良好的交互体验，这需要实现低延迟的目标。")])]),v._v(" "),r("li",[r("p",[v._v("CMS垃圾收集器主要有四个核心步骤，包括初始标记（标记GCRoots能直接到达的对象）、并发标记、重新标记和并发清除。其中，初始标记和重新标记都是需要“stop the world”的。")])]),v._v(" "),r("li",[r("p",[r("strong",[v._v("CMS主要有三个缺点：")])]),v._v(" "),r("ul",[r("li",[v._v("对处理器资源十分敏感，在并发阶段，CMS默认启动的回收线程数量是：（cpu数量 + 3）/ 4。当cpu数量很少时，垃圾回收线程占用大量的处理器运算资源，这会大大降低总吞吐量。")]),v._v(" "),r("li",[v._v("产生浮动垃圾。因为并发清除和并发清除两个阶段用户线程是并发在运行的，可能这期间会产生新的垃圾，但这部分垃圾在垃圾清除之后是无法被清除的，只有等到下一次垃圾收集进行处理。这一部分垃圾就叫做浮动垃圾。")]),v._v(" "),r("li",[v._v("前面也讲到了，CMS使用的是垃圾清除的算法进行垃圾收集的，所以这必然会产生大量的空间碎片，当碎片太多，将不利于大对象的内存分配，这会提前触发Full GC。")])])]),v._v(" "),r("li",[r("p",[v._v("G1垃圾收集器全称是Garbage First垃圾收集器，这是一款面向局部收集思路的收集器，它基于Region的内存布局。基于这两种思路，它希望可以实现“低停顿时间模型”。这种模型的意思是，他能够支持在一个给定长度的时间片段内，消耗在垃圾收集上的时间不超过N毫秒的目标。")])]),v._v(" "),r("li",[r("p",[v._v("为了实现这个目标，它并不是像CMS这些传统的垃圾收集器一样，将垃圾收集的范围限定在要么是新生代，要么是老年代，要么是full GC。G1可以面向堆内任何区域组成回收集进行回收，而不是该内存区域是否哪个分代。通过将Java堆划分为多个大小相等且独立的Region区域，每一个Region可以根据需要成为Eden，Survivor或者老年代。真实这种内存布局，使之可以建立起可预测的停顿时间模型，因为它将收集最小单位设置为Region，每次收集的空间都是Region的整数倍，这样可以有计划地避免全区域的垃圾收集。此外，它的垃圾收集是根据垃圾的价值大小来进行的，价值指的是回收所获得的空间和回收所需要的时间的比值，通过维护一个优先级链表，并且根据用户设置的收集停顿时间，可以优先处理回收收益大的Region。")])]),v._v(" "),r("li",[r("p",[v._v("G1可以说是基于标记整理收集算法的，它也有类似的四个核心步骤：初始标记，并发标记、最终标记、最终标记和筛选回收阶段。")])])]),v._v(" "),r("h2",{attrs:{id:"引用的类型-为什么要设置多种引用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#引用的类型-为什么要设置多种引用"}},[v._v("#")]),v._v(" 引用的类型？为什么要设置多种引用？")]),v._v(" "),r("ol",[r("li",[r("p",[v._v("引用分为强引用，软引用，弱引用和虚引用，这四种引用的强度依次降低。")])]),v._v(" "),r("li",[r("p",[v._v("其实在jdk1.2之前，一个对象只有已被引用和未被引用两种状态，这无法描述某种特殊情况下的对象，比如当内存充足时需要保留，而在内存不足时需要抛弃的这类对象。这和我们自己整理房间很相似，对于某一件物品的丢失会有食之无味，弃之可惜的感觉。对于Java虚拟机也是这样，如果在一段时间内，某对象没有被使用，就要被回收了，但是到下一秒的时候，发现已经被回收了，只能重新去new，这会降低JVM的效率。")])]),v._v(" "),r("li",[r("p",[v._v("所谓的强引用，就是垃圾回收期永远不会回收被引用的对象，哪怕内存不足，JVM也只会抛出OutofMemoryError异常，而不会去回收。")])]),v._v(" "),r("li",[r("p",[v._v("软引用的要求则更低一点，它在内存充足时，被引用的对象不会被回收，但是在内存不足时，系统会回收软引用对象。这种引用通常可以用来实现缓存技术。在Java中使用java.lang.SoftReference来表示软引用。")])]),v._v(" "),r("li",[r("p",[v._v("弱引用的语气则更弱，它也是一种可有可无的引用。对于弱引用指向的对象，无论内存是否充足，只要碰到了垃圾回收，都会被回收。它在java中使用java.lang.WeekReference来表示。")])]),v._v(" "),r("li",[r("p",[v._v("虚引用是最弱的一种引用，如果一个对象拥有一个虚引用（plantomReference），那它和没有任何引用时一样的，随时都有可能被回收。而且，我们无法通过这个引用来获取引用的对象，它通常与引用队列配合使用。")])]),v._v(" "),r("li",[r("p",[v._v("上面讲到的引用队列可以与软引用，弱引用以及虚引用配合使用，当垃圾收集器发现一个对象还有引用时，会在回收该对象之前将引用加入到与之相关的引用队列中，程序可以通过判断引用队列来判断引用的对象是否将要被垃圾回收。通过这种机制，可以在对象被回收之前采取一些必要的措施。")])])]),v._v(" "),r("h2",{attrs:{id:"介绍一下垃圾回收算法等"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下垃圾回收算法等"}},[v._v("#")]),v._v(" 介绍一下垃圾回收算法等？")]),v._v(" "),r("ol",[r("li",[r("p",[v._v("标记清除算法：标记清除算法的思路比较简单，它首先会先标记还存活的对象，接着将未标记的可回收对象直接清除。这种方法的优点是简单易实现，不需要移动对象等耗时的操作；缺点是容易造成内存碎片，而且这种方法会进行大量的标记和清除操作，而且执行效率随着对象数量的增长而降低。")])]),v._v(" "),r("li",[r("p",[v._v("标记复制算法：考虑到标记清除算法执行效率低下的问题，标记复制算法被提出。这种方法是先将内存空间等分为两份，每次的对象内存分配和回收都只在一个区域进行。首先，需要标记还存活的对象，接着将还存活的对象复制到另一半空闲的内存区域，并将原来的一般内存区域清空。这种算法对于每次回收后仅剩余少量对象的情况比较有利，因为这样每次都只需要移动少量的对象即可，但是对于回收后仍然剩余大量对象，这时如果使用复制算法，就会造成大量内存间复制的开销。此外，这种方法因为每次只能使用一半的区域，所以内存的利用率太低了。考虑到这种特性，在分代回收理论中，新生代一般都是使用标记复制算法进行垃圾回收。这也是为什么新生代会被再次细化分为Eden区和Survivor区。对于新生代中的对象，它们有一个特性，那就是朝生夕灭，即98%的对象熬不过第一轮的收集，所以每次仅需要移动少量存活的对象到survivor区。")])]),v._v(" "),r("li",[r("p",[v._v("标记整理算法：尽管标记复制法解决了垃圾回收效率低下的问题，但是因为它每次只使用一半的内存区域，导致内存利用率低下。所以，标记整理算法应运而生。这种算法的过程和标记清除算法十分接近，都需要先对存活的对象进行标记，但是他们并不是对其直接清除，而是将存活的对象移动到内存的一端，最后清除边界之外的区域。这种算法经常被应用在老年代中进行垃圾回收，因为老年代中每次回收后会残余大量的存活对象，这时不适合使用复制算法。但是这种方法有一个缺点，那就是在移动存活对象的过程中，需要更新这些对象的引用，这时一种负重的操作，而且这种操作会造成stop the world，会造成延迟的出现。")])]),v._v(" "),r("li",[r("p",[v._v("最后，需要提及的是分代收集理论，这不是一种具体的垃圾回收算法，更准确地说是一种收集理论。这种理论基于几个假说，包括绝大多数对象都是朝生夕灭的，以及熬过越多次垃圾收集过程的对象越难以消亡。基于这两个假说，现有的大多数垃圾收集器都遵从以下的原则：垃圾收集器应该将Java堆划分出不同的区域，然后将回收对象根据其年龄分配到不同的区域之中。这样做的原因是，如果一个区域内的绝大多数对象都是朝生夕灭的，它们很难熬过垃圾回收过程，那么把这些对象放在一起，每次回收都只需要关注保留的极少数存活对象，而不是去标记大量要被回收的对象，这样可以使用较低的代价回收到大量空间。如果剩下的都是难以消亡的对象，将它们集中在一起，JVM可以使用更低的频率来回收这个区域。")])])]),v._v(" "),r("h2",{attrs:{id:"jvm对象的内存分配和回收方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#jvm对象的内存分配和回收方法"}},[v._v("#")]),v._v(" JVM对象的内存分配和回收方法？")]),v._v(" "),r("ol",[r("li",[r("p",[v._v("对象优先分配在伊甸区。如果Eden区没有足够的内存进行分配，JVM将开启一次MinorGC。对于新生代的垃圾回收，大部分的垃圾回收器使用的都是复制算法。具体地说，当进行垃圾回收时，将Eden和Survivor中还存活的对象一次性地复制到另一块空闲的Survivor中，最后处理掉Eden和之前的Survivor，每次只使用一个Survivor。")])]),v._v(" "),r("li",[r("p",[v._v("大对象直接进入老年代。所谓的大对象指的是需要大量连续内存空间的Java对象，这类对象常见的有，数组，很长的字符串。")])]),v._v(" "),r("li",[r("p",[v._v("长期存活的对象将进入老年代：当对象在新生代中经历过一定次数的Minor GC后，就会被晋升到老年代中。这个晋升阈值可以通过：+XX:MaxTenuringThreshold来设置，默认是15。")])])]),v._v(" "),r("h2",{attrs:{id:"如何判断对象是否存活"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何判断对象是否存活"}},[v._v("#")]),v._v(" 如何判断对象是否存活？")]),v._v(" "),r("ol",[r("li",[r("p",[v._v("目前常用的判断对象存活的方法主要包括两类，即引用计数法和可达性分析法。")])]),v._v(" "),r("li",[r("p",[v._v("所谓的引用计数法是指为每一个对象都添加一个引用计数器，每次有地方引用它时对应的计数器会加一，当引用失效时计数器值减一。考虑到这种方法无法解决循环引用的问题，所以目前主流的Java虚拟机没有采用这种方法进行内存管理。")])]),v._v(" "),r("li",[r("p",[v._v("而可达性分析法则不同，该算法首先会选定当前时刻一定存活的对象即所谓的GCRoots作为初始节点集，接着从这些节点出发，根据引用关系向下搜索，搜索过程中所走过的路径被称之为引用链，如果某个对象到GCRoots没有任何的引用链相连，或者用图论的话来说叫做GCRoots到该对象不可达，则说明这个对象是不可能被使用的，可以被垃圾收集器收集。")])])]),v._v(" "),r("h2",{attrs:{id:"gcroots如何选取"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#gcroots如何选取"}},[v._v("#")]),v._v(" GCRoots如何选取？")]),v._v(" "),r("ol",[r("li",[v._v("虚拟机栈中的局部变量，临时变量以及参数等引用的对象。")]),v._v(" "),r("li",[v._v("本地方法栈中变量引用的对象。")]),v._v(" "),r("li",[v._v("方法区中的静态属性和常量引用的对象。")]),v._v(" "),r("li",[v._v("被synchronized关键字持有的对象。")])])])}),[],!1,null,null,null);_.default=t.exports}}]);