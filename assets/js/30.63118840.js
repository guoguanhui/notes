(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{586:function(t,a,s){"use strict";s.r(a);var n=s(14),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"异常"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异常"}},[t._v("#")]),t._v(" 异常")]),t._v(" "),s("h3",{attrs:{id:"异常的分类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异常的分类"}},[t._v("#")]),t._v(" 异常的分类？")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("在 Java 中，所有的异常都有一个共同的祖先 Throwable（可抛出）。Throwable 指定代码中可用异常传播机制通过 Java 应用程序传输的任何问题的共性。")])]),t._v(" "),s("li",[s("p",[t._v("Throwable： 有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。")])]),t._v(" "),s("li",[s("p",[t._v("异常和错误的区别是：异常能被程序本身可以处理，错误是无法处理。")])]),t._v(" "),s("li",[s("p",[t._v("Error（错误）😗*是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。**例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。 "),s("strong",[t._v("这些也是不检查异常。")])])]),t._v(" "),s("li",[s("p",[t._v("Exception（异常）:是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（NullPointerException、ArithmeticException）和 ArrayIndexOutOfBoundException。"),s("strong",[t._v("Exception（异常）分两大类：运行时异常和非运行时异常(编译异常)。程序中应当尽可能去处理这些异常。")])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("运行时异常：都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是"),s("strong",[t._v("不检查异常")]),t._v("，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。")])]),t._v(" "),s("li",[s("p",[t._v("非运行时异常 （编译异常）：是RuntimeException以外的异常，类型上都属于Exception类及其子类。**从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。**如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。")])])])])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203212124663.png",alt:"img"}})]),t._v(" "),s("h3",{attrs:{id:"可查的异常-checked-exceptions-和不可查的异常-unchecked-exceptions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#可查的异常-checked-exceptions-和不可查的异常-unchecked-exceptions"}},[t._v("#")]),t._v(" 可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("可查异常")]),t._v("（编译器要求必须处置的异常）：")])]),t._v(" "),s("p",[t._v("正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。")]),t._v(" "),s("p",[s("strong",[t._v("除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常")]),t._v("。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("不可查异常")]),t._v("(编译器不要求强制处置的异常)")])]),t._v(" "),s("p",[t._v("包括运行时异常（RuntimeException与其子类）和错误（Error）。")]),t._v(" "),s("h3",{attrs:{id:"继承类时的异常范围确定"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#继承类时的异常范围确定"}},[t._v("#")]),t._v(" 继承类时的异常范围确定？")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("子类覆盖了基类方法时，"),s("strong",[t._v("子类方法抛出异常的范围不能大于基类方法抛出的异常范围")]),t._v("**。**")])]),t._v(" "),s("li",[s("p",[t._v("子类方法可以不抛出异常，也可以只抛出基类方法的部分异常，但不可以抛出基类方法以外的异常。")])]),t._v(" "),s("li",[s("p",[t._v("需要注意的是，这与"),s("strong",[t._v("继承时访问修饰符不一样，子类的访问权限一定要大于父类的访问权限")]),t._v("，这两类情况都是为了满足里式替换原则。此外，"),s("strong",[t._v("子类方法的返回值应该小于父类方法的返回值类型")]),t._v("。")])])]),t._v(" "),s("h2",{attrs:{id:"jvm处理异常机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jvm处理异常机制"}},[t._v("#")]),t._v(" JVM处理异常机制")]),t._v(" "),s("p",[t._v("提到JVM处理异常的机制，就需要提及"),s("strong",[t._v("Exception Table")]),t._v("，以下称为异常表。我们暂且不急于介绍异常表，先看一个简单的 Java 处理异常的小例子。")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("simpleTryCatch")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n       "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("testNPE")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("catch")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Exception")]),t._v(" e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n       e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("printStackTrace")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("上面的代码是一个很简单的例子，用来捕获处理一个潜在的空指针异常。")]),t._v(" "),s("p",[t._v("当然如果只是看简简单单的代码，我们很难看出什么高深之处，更没有了今天文章要谈论的内容。")]),t._v(" "),s("p",[t._v("所以这里我们需要借助一把神兵利器，它就是javap,一个用来拆解class文件的工具，和javac一样由JDK提供。然后我们使用javap来分析这段代码（需要先使用javac编译）")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//javap -c Main")]),t._v("\n "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("simpleTryCatch")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Code")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n       "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" invokestatic  #"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("                  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Method testNPE:()V")]),t._v("\n       "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("goto")]),t._v("          "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("11")]),t._v("\n       "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" astore_0\n       "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("7")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" aload_0\n       "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" invokevirtual #"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v("                  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Method java/lang/Exception.printStackTrace:()V")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("11")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Exception")]),t._v(" table"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n       from    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("to")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("target")]),t._v(" type\n           "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Class")]),t._v(" java"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("lang"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Exception")]),t._v("\n")])])]),s("p",[t._v("看到上面的代码，应该会有会心一笑，因为终于看到了Exception table，也就是我们要研究的异常表。")]),t._v(" "),s("p",[t._v("异常表中包含了一个或多个异常处理者(Exception Handler)的信息，这些信息包含如下")]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("from")]),t._v(" 可能发生异常的起始点")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("to")]),t._v(" 可能发生异常的结束点")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("target")]),t._v(" 上述from和to之前发生异常后的异常处理者的位置")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("type")]),t._v(" 异常处理者处理的异常的类信息")])])]),t._v(" "),s("p",[s("strong",[t._v("那么异常表用在什么时候呢")])]),t._v(" "),s("p",[t._v("答案是异常发生的时候，当一个异常发生时")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("JVM会在当前出现异常的方法中，查找异常表，是否有合适的处理者来处理")])]),t._v(" "),s("li",[s("p",[t._v("如果当前方法异常表不为空，并且异常符合处理者的from和to节点，并且type也匹配，则JVM调用位于target的调用者来处理。")])]),t._v(" "),s("li",[s("p",[t._v("如果上一条未找到合理的处理者，则继续查找异常表中的剩余条目")])]),t._v(" "),s("li",[s("p",[t._v("如果当前方法的异常表无法处理，则向上查找（弹栈处理）刚刚调用该方法的调用处，并重复上面的操作。")])]),t._v(" "),s("li",[s("p",[t._v("如果所有的栈帧被弹出，仍然没有处理，则抛给当前的Thread，Thread则会终止。")])]),t._v(" "),s("li",[s("p",[t._v("如果当前Thread为最后一个非守护线程，且未处理异常，则会导致JVM终止运行。")])])]),t._v(" "),s("p",[t._v("以上就是JVM处理异常的一些机制。")]),t._v(" "),s("h2",{attrs:{id:"为什么不使用异常来判断string是否是整数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么不使用异常来判断string是否是整数"}},[t._v("#")]),t._v(" 为什么不使用异常来判断String是否是整数？")]),t._v(" "),s("ol",[s("li",[t._v("使用异常处理的本质是基于java自身对于字符串定义而实现的，如果我们的字符串能够被转换为数字，那么这个字符串就是数字，如果转换失败则会抛出异常，所以我们如果能够捕获异常，就可以认为它不是数字，这个方案很简单：")])]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("isNumeric1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" str"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Double")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("parseDouble")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("str"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("catch")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Exception")]),t._v(" e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("ol",{attrs:{start:"2"}},[s("li",[s("p",[t._v("如果我们的业务只要求判断字符串是否为整数，那么只需要将Double.parseDouble(str);换成Integer.parseInt(str);即可。但是这个方案有个致命缺陷，由于判断失败会抛异常出来，当判断失败的频率比较高，将产生较大的性能损耗。")])]),t._v(" "),s("li",[s("p",[t._v("建立一个异常对象，是建立一个普通Object耗时的约20倍（实际上差距会比这个数字更大一些，因为循环也占用了时间，追求精确的读者可以再测一下空循环的耗时然后在对比前减掉这部分），而抛出、接住一个异常对象，所花费时间大约是建立异常对象的4倍。")])])]),t._v(" "),s("h2",{attrs:{id:"参考"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://blog.csdn.net/mryang125/article/details/113146057",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java判断字符串是否为数字的多种方式，你用对了吗_Alphathur的博客-CSDN博客_java判断字符串是否为数字"),s("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=e.exports}}]);