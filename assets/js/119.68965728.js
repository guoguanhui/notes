(window.webpackJsonp=window.webpackJsonp||[]).push([[119],{673:function(t,a,r){"use strict";r.r(a);var e=r(14),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"git原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git原理"}},[t._v("#")]),t._v(" git原理")]),t._v(" "),r("h3",{attrs:{id:"直接记录快照-而非差异比较"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#直接记录快照-而非差异比较"}},[t._v("#")]),t._v(" 直接记录快照，而非差异比较")]),t._v(" "),r("p",[t._v("Git 和其它版本控制系统（包括 Subversion 和近似工具）的主要差别在于 Git 对待数据的方法。概念上来区分，其它大部分系统以文件变更列表的方式存储信息。"),r("strong",[t._v("这类系统（CVS、Subversion、Perforce、Bazaar 等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。")])]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919205.png",alt:"img"}})]),t._v(" "),r("p",[t._v("Git 不按照以上方式对待或保存数据。反之，Git 更像是把数据看作是对小型文件系统的一组快照。每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。"),r("strong",[t._v("Git 对待数据更像是一个 快照流")]),t._v("。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919218.png",alt:"img"}})]),t._v(" "),r("h3",{attrs:{id:"近乎所有操作都是本地执行"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#近乎所有操作都是本地执行"}},[t._v("#")]),t._v(" 近乎所有操作都是本地执行")]),t._v(" "),r("p",[t._v("在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。如果你习惯于所有操作都有网络延时开销的集中式版本控制系统，Git 在这方面会让你感到速度之神赐给了 Git 超凡的能量。"),r("strong",[t._v("因为你在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。")])]),t._v(" "),r("p",[t._v("如果你想查看当前版本与一个月前的版本之间引入的修改，Git会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。")]),t._v(" "),r("h3",{attrs:{id:"git保证完整性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git保证完整性"}},[t._v("#")]),t._v(" git保证完整性")]),t._v(" "),r("p",[t._v("Git 中所有数据在存储前都计算校验和，然后以校验和来引用。这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。")]),t._v(" "),r("p",[t._v("Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来。")]),t._v(" "),r("p",[t._v("Git 中使用这种哈希值的情况很多，你将经常看到这种哈希值。"),r("strong",[t._v("实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名")]),t._v("。")]),t._v(" "),r("h3",{attrs:{id:"git一般只添加数据"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git一般只添加数据"}},[t._v("#")]),t._v(" git一般只添加数据")]),t._v(" "),r("p",[t._v("你执行的 Git 操作，几乎只往 Git 数据库中增加数据。很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据。同别的 VCS 一样，未提交更新时有可能丢失或弄乱修改的内容；但是一旦你提交快照到 Git 中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。")]),t._v(" "),r("h3",{attrs:{id:"三种状态及三个工作区域"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#三种状态及三个工作区域"}},[t._v("#")]),t._v(" 三种状态及三个工作区域")]),t._v(" "),r("p",[t._v("Git 有三种状态，你的文件可能处于其中之一："),r("strong",[t._v("已提交（committed）、已修改（modified）和已暂存（staged）")]),t._v("。已提交表示数据已经安全的保存在本地数据库中。已修改表示修改了文件，但还没保存到数据库中。已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。")]),t._v(" "),r("p",[t._v("由此引入 Git 项目的三个工作区域的概念：Git 仓库、工作目录以及暂存区域。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919230.png",alt:"img"}})]),t._v(" "),r("ul",[r("li",[t._v("Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。")]),t._v(" "),r("li",[t._v("工作目录是对项目的某个版本独立提取出来的内容。这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。")]),t._v(" "),r("li",[r("strong",[t._v("暂存区域是一个文件，保存了下次将提交的文件列表信息")]),t._v("，一般在 Git 仓库目录中。有时候也被称作`‘索引’'，不过一般说法还是叫暂存区域。")])]),t._v(" "),r("p",[t._v("如果 Git 目录中保存着的特定版本文件，就属于已提交状态。如果作了修改并已放入暂存区域，就属于已暂存状态。如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。")]),t._v(" "),r("h2",{attrs:{id:"核心命令"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#核心命令"}},[t._v("#")]),t._v(" 核心命令")]),t._v(" "),r("h3",{attrs:{id:"记录每次更新到仓库命令相关"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#记录每次更新到仓库命令相关"}},[t._v("#")]),t._v(" 记录每次更新到仓库命令相关")]),t._v(" "),r("h4",{attrs:{id:"git-status"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-status"}},[t._v("#")]),t._v(" git status")]),t._v(" "),r("p",[t._v("该命令用于检查当前仓库的状态，比如当前各文件处于三种状态的什么状态。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919497.png",alt:"img"}})]),t._v(" "),r("h4",{attrs:{id:"git-add"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-add"}},[t._v("#")]),t._v(" git add")]),t._v(" "),r("ol",[r("li",[t._v("该命令首先可以用来跟踪新文件即将第一次创建的文件"),r("strong",[t._v("加入暂存区。")])]),t._v(" "),r("li",[t._v("其次，该命令还可以暂存已修改的文件。")]),t._v(" "),r("li",[t._v("这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。")])]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919506.png",alt:"img"}})]),t._v(" "),r("h4",{attrs:{id:"忽略文件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#忽略文件"}},[t._v("#")]),t._v(" 忽略文件")]),t._v(" "),r("p",[t._v("一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。在这种情况下，我们可以创建一个名为 .gitignore的文件，列出要忽略的文件模式。")]),t._v(" "),r("h4",{attrs:{id:"git-diff"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-diff"}},[t._v("#")]),t._v(" git diff")]),t._v(" "),r("ol",[r("li",[t._v("查看已暂存和未暂存的修改。")]),t._v(" "),r("li",[t._v("直接运行不加参数的"),r("code",[t._v("git diff")]),t._v("命令，"),r("strong",[t._v("比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容")]),t._v("。")])]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919171.png",alt:"img"}})]),t._v(" "),r("p",[r("code",[t._v("git diff --staged")]),t._v("：该命令查看已暂存的将要添加到下次提交的内容，显示"),r("strong",[t._v("已暂存的与本地仓库中已提交的最新版本比较")]),t._v("。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919836.png",alt:"img"}})]),t._v(" "),r("h4",{attrs:{id:"git-commit"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-commit"}},[t._v("#")]),t._v(" git commit")]),t._v(" "),r("p",[t._v("现在的暂存区域已经准备妥当可以提交了。在此之前，请一定要确认还有什么修改过的或新建的文件还没有 git add 过，否则提交的时候不会记录这些还没暂存起来的变化。这些修改过的文件只保留在本地磁盘。所以，每次准备提交前，先用 git status 看下，是不是都已暂存起来了，然后再运行提交命令 git commit。")]),t._v(" "),r("p",[t._v("可以直接运行"),r("code",[t._v("git commit")]),t._v("也可以运行"),r("code",[t._v('git commit -m ""')]),t._v("来添加提交信息。")]),t._v(" "),r("p",[t._v('git commit -a -m ""`：Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给 git commit 加上 -a 选项，'),r("strong",[t._v("Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤")]),t._v("。")]),t._v(" "),r("h4",{attrs:{id:"git-rm-移除文件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-rm-移除文件"}},[t._v("#")]),t._v(" git rm - 移除文件")]),t._v(" "),r("p",[t._v("要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是"),r("strong",[t._v("从暂存区域移除")]),t._v("），然后提交。可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。")]),t._v(" "),r("p",[t._v("如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 “Changes not staged for commit” 部分（也就是 未暂存清单）。")]),t._v(" "),r("p",[r("code",[t._v("git rm -r --cached")]),t._v("：把文件从 Git 仓库中删除（"),r("strong",[t._v("亦即从暂存区域移除")]),t._v("），但仍然希望保留在当前工作目录中。换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919850.png",alt:"img"}})]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919160.png",alt:"img"}})]),t._v(" "),r("h3",{attrs:{id:"查看提交历史"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#查看提交历史"}},[t._v("#")]),t._v(" 查看提交历史")]),t._v(" "),r("h4",{attrs:{id:"git-log"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-log"}},[t._v("#")]),t._v(" git log")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919241.png",alt:"img"}})]),t._v(" "),r("p",[t._v("**不加任何参数：**git log 会按提交时间列出所有的更新，最近的更新排在最上面。正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919228.png",alt:"img"}})]),t._v(" "),r("p",[r("code",[t._v("git log -p [-2]")]),t._v("：一个常用的选项是 -p，用来显示每次提交的内容差异。你也可以加上 -2 来仅显示最近两次提交。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919375.png",alt:"img"}})]),t._v(" "),r("h3",{attrs:{id:"撤销操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#撤销操作"}},[t._v("#")]),t._v(" 撤销操作")]),t._v(" "),r("h4",{attrs:{id:"git-reset-head-file"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-reset-head-file"}},[t._v("#")]),t._v(" git reset HEAD file")]),t._v(" "),r("p",[t._v("该命令可以用于取消暂存的文件，即"),r("strong",[t._v("撤销处于暂存区的文件。")])]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919649.png",alt:"img"}})]),t._v(" "),r("h4",{attrs:{id:"git-restore-file"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-restore-file"}},[t._v("#")]),t._v(" git restore file")]),t._v(" "),r("p",[t._v("该命令可以"),r("strong",[t._v("将未保存至暂存区的文件的修改撤销")]),t._v("，将它还原成上次提交时的样子。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919661.png",alt:"img"}})]),t._v(" "),r("h4",{attrs:{id:"git-checkout-file"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-checkout-file"}},[t._v("#")]),t._v(" git checkout -- file")]),t._v(" "),r("ol",[r("li",[t._v("与git restore命令一样的作用，可以用于"),r("strong",[t._v("撤销未保存至暂存区的文件的修改")]),t._v("。")])]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919677.png",alt:"img"}})]),t._v(" "),r("h3",{attrs:{id:"从远程仓库抓取与拉取"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#从远程仓库抓取与拉取"}},[t._v("#")]),t._v(" 从远程仓库抓取与拉取")]),t._v(" "),r("h4",{attrs:{id:"git-fetch-remote-name-remote-branch"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-fetch-remote-name-remote-branch"}},[t._v("#")]),t._v(" git fetch [remote-name] [remote_branch]")]),t._v(" "),r("p",[r("code",[t._v("git fetch origin")]),t._v(" 这个命令会访问远程仓库，从中拉取所有你还没有的数据。执行完成后，你将会拥有那个"),r("strong",[t._v("远程仓库中所有分支的引用（注意是有所有的远程分支）")]),t._v("，可以随时合并或查看。")]),t._v(" "),r("p",[t._v("如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。所以，"),r("code",[t._v("git fetch origin")]),t._v(" 会抓取克隆（或上一次抓取）后新推送的所有工作。")]),t._v(" "),r("p",[t._v("必须注意 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。当准备好时你必须手动将其合并入你的工作**。")]),t._v(" "),r("p",[r("strong",[t._v("git fetch origin [branch]可以拉取指定的远程分支，而git fetch origin则默认拉取远程的master分支。")])]),t._v(" "),r("p",[t._v("如果你有一个分支设置为跟踪一个远程分支，可以使用 git pull 命令来自动的抓取然后合并远程分支到当前分支。")]),t._v(" "),r("p",[t._v("默认情况下，"),r("strong",[t._v("git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支")]),t._v("（或不管是什么名字的默认分支）。运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919169.png",alt:"img"}})]),t._v(" "),r("p",[t._v("要特别注意的一点是当抓取到"),r("strong",[t._v("新的远程跟踪分支")]),t._v("时，"),r("strong",[t._v("本地不会自动生成一份可编辑的副本（拷贝）")]),t._v("。换一句话说，这种情况下，不会有一个新的 serverfix 分支 - 只有一个不可以修改的 origin/serverfix 指针。")]),t._v(" "),r("p",[r("strong",[t._v("可以运行")]),t._v(" "),r("code",[t._v("**git merge origin/serverfix**")]),t._v(" "),r("strong",[t._v("将这些工作合并到当前所在的分支")]),t._v("。如果想要在自己的serverfix 分支上工作，可以将其建立在远程跟踪分支之上："),r("code",[t._v("git checkout -b serverfix origin/serverfix")]),t._v("。这会给你一个用于工作的本地分支，并且起点位于 origin/serverfix。")]),t._v(" "),r("h4",{attrs:{id:"git-pull"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-pull"}},[t._v("#")]),t._v(" git pull")]),t._v(" "),r("p",[t._v("当 git fetch 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。它只会获取数据然后让你自己合并。然而，有一个命令叫作 git pull 在大多数情况下它的含义是"),r("strong",[t._v("一个 git fetch 紧接着一个git merge 命令")]),t._v("。如果有一个设置好的"),r("strong",[t._v("跟踪分支")]),t._v("，不管它是式地设置还是通过 clone 或checkout 命令为你创建的，"),r("strong",[t._v("git pull 都会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并那个远程分支")]),t._v("。")]),t._v(" "),r("p",[t._v("由于 git pull 的魔法经常令人困惑所以通常"),r("strong",[t._v("单独显式地使用 fetch 与 merge 命令会更好一些。")])]),t._v(" "),r("h4",{attrs:{id:"git-push-remote-name-branchname"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-push-remote-name-branchname"}},[t._v("#")]),t._v(" git push [remote-name] [branchname]")]),t._v(" "),r("p",[t._v("当你想要将 master 分支推送到 origin 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器："),r("code",[t._v("git push origin master")]),t._v("。")]),t._v(" "),r("p",[t._v("只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。"),r("strong",[t._v("你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送")]),t._v("。")]),t._v(" "),r("p",[t._v("比如："),r("code",[t._v("git push origin serverfix")]),t._v("，表示推送本地的 serverfix 分支来更新远程仓库上的 serverfix 分支。你也可以运行 "),r("code",[t._v("git push origin serverfix:serverfix")]),t._v("，它会做同样的事 - 相当于它说，“"),r("strong",[t._v("推送本地的 serverfix 分支，将其作为远程仓库的 serverfix 分支")]),t._v("”可以通过这种格式来推送本地分支到一个命名不相同的远程分支。如果并不想让远程仓库上的分支叫做 serverfix，可以运行 "),r("code",[t._v("git push origin serverfix:awesomebranch")]),t._v(" "),r("strong",[t._v("来将本地的 serverfix 分支推送到远程仓库上的 awesomebranch 分支。")])]),t._v(" "),r("h3",{attrs:{id:"标签"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#标签"}},[t._v("#")]),t._v(" 标签")]),t._v(" "),r("p",[t._v("Git 可以给历史中的某一个提交打上标签，以示重要。比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。")]),t._v(" "),r("h4",{attrs:{id:"git-tag"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-tag"}},[t._v("#")]),t._v(" git tag")]),t._v(" "),r("p",[t._v("这个命令以字母顺序列出标签；但是它们出现的顺序并不重要。")]),t._v(" "),r("h4",{attrs:{id:"git-tag-a-tagname-m-tagmes"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-tag-a-tagname-m-tagmes"}},[t._v("#")]),t._v(" git tag -a [tagname] -m '[tagmes]'")]),t._v(" "),r("p",[t._v("在 Git 中创建一个附注标签是很简单的。最简单的方式是当你在运行 tag 命令时指定 -a 选项，-m 选项指定了一条将会存储在标签中的信息。如果没有为附注标签指定一条信息，Git 会运行编辑器要求你输入信息。")]),t._v(" "),r("h2",{attrs:{id:"分支"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分支"}},[t._v("#")]),t._v(" 分支")]),t._v(" "),r("p",[t._v("Git 的分支，其实本质上仅仅是"),r("strong",[t._v("指向提交对象的可变指针")]),t._v("。Git 的默认分支名字是 master。在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。它会在每次的提交操作中自动向前移动。")]),t._v(" "),r("p",[t._v("在进行提交操作时，Git 会保存一个"),r("strong",[t._v("提交对象")]),t._v("（commit object）。知道了 Git 保存数据的方式，我们可以很自然的想到——"),r("strong",[t._v("该提交对象会包含一个指向暂存内容快照的指针")]),t._v("。但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象。")]),t._v(" "),r("p",[t._v("**Git 的分支，其实本质上仅仅是指向提交对象的可变指针。**Git 的默认分支名字是 master。在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。它会在每次的提交操作中自动向前移动。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919404.png",alt:"img"}})]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919392.png",alt:"img"}})]),t._v(" "),r("h3",{attrs:{id:"分支新建、切换与删除"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分支新建、切换与删除"}},[t._v("#")]),t._v(" 分支新建、切换与删除")]),t._v(" "),r("h4",{attrs:{id:"git-branch-branch-name"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-branch-branch-name"}},[t._v("#")]),t._v(" git branch <branch_name>")]),t._v(" "),r("p",[t._v("该命令用于创建一个新的分支。很简单，它只是为你创建了一个可以移动的新的指针。git branch 命令"),r("strong",[t._v("仅仅 创建 一个新分支，并不会自动切换到新分支中去")]),t._v("。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919464.png",alt:"img"}})]),t._v(" "),r("p",[t._v("那么，Git 又是怎么知道当前在哪一个分支上呢？也很简单，它有一个名为 HEAD 的特殊指针。请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 HEAD 概念完全不同。在 Git 中，它是一个指针，指向当前所在的本地分支（译注："),r("strong",[t._v("将 HEAD 想象为当前分支的别名")]),t._v("）。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919487.png",alt:"img"}})]),t._v(" "),r("h4",{attrs:{id:"git-checkout-branch-name"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-checkout-branch-name"}},[t._v("#")]),t._v(" git checkout <branch_name>")]),t._v(" "),r("p",[t._v("该命令用于切换到指定已经存在的分区。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919469.png",alt:"img"}})]),t._v(" "),r("h4",{attrs:{id:"git-checkout-b-branch-name"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-checkout-b-branch-name"}},[t._v("#")]),t._v(" git checkout -b <branch_name>")]),t._v(" "),r("p",[t._v("带有-b参数的git checkout命令是git branch 和 git checkout无参数命令的结合，用于创建一个分支并切换到这个刚创建的分支上。")]),t._v(" "),r("h4",{attrs:{id:"git-branch-d-branch-name"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-branch-d-branch-name"}},[t._v("#")]),t._v(" git branch -d <branch_name>")]),t._v(" "),r("p",[t._v("该命令用于删除本地分支。")]),t._v(" "),r("h4",{attrs:{id:"git-push-origin-delete-remote-branch"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-push-origin-delete-remote-branch"}},[t._v("#")]),t._v(" git push origin --delete [remote_branch]")]),t._v(" "),r("ol",[r("li",[t._v("该命令用于删除远程分支。")]),t._v(" "),r("li",[t._v("可以运行带有 --delete 选项的 git push 命令来删除一个远程分支。")]),t._v(" "),r("li",[t._v("基本上这个命令做的只是从服务器上移除这个指针。Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。")])]),t._v(" "),r("h3",{attrs:{id:"合并分支"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#合并分支"}},[t._v("#")]),t._v(" 合并分支")]),t._v(" "),r("h4",{attrs:{id:"git-merge-branch-name"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-merge-branch-name"}},[t._v("#")]),t._v(" git merge <branch_name>")]),t._v(" "),r("p",[r("strong",[t._v("该命令将<branch_name>的内容合并到当前分支。")])]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919836.png",alt:"img"}})]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919250.png",alt:"img"}})]),t._v(" "),r("h4",{attrs:{id:"遇到冲突的分支合并"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#遇到冲突的分支合并"}},[t._v("#")]),t._v(" 遇到冲突的分支合并")]),t._v(" "),r("div",{staticClass:"language-c extra-class"},[r("pre",{pre:!0,attrs:{class:"language-c"}},[r("code",[r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" HEAD"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("index"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("html\n"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div id"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),r("span",{pre:!0,attrs:{class:"token string"}},[t._v('"footer"')]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("contact "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" email"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("support@github"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("com"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("div"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div id"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),r("span",{pre:!0,attrs:{class:"token string"}},[t._v('"footer"')]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\nplease contact us at support@github"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("com\n"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("div"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" iss53"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("index"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("html\n")])])]),r("p",[t._v("这表示 HEAD 所指示的版本（也就是你的 master 分支所在的位置，因为你在运行 merge 命令的时候已经检出到了这个分支）在这个区段的上半部分（======= 的上半部分），而 iss53 分支所指示的版本在 ======= 的下半部分。为了解决冲突，你必须选择使用由 ======= 分割的两部分中的一个，或者你也可以自行合并这些内容。例如下面的解决方案：")]),t._v(" "),r("div",{staticClass:"language-c extra-class"},[r("pre",{pre:!0,attrs:{class:"language-c"}},[r("code",[r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div id"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),r("span",{pre:!0,attrs:{class:"token string"}},[t._v('"footer"')]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\nplease contact us at email"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("support@github"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("com\n"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("div"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),r("p",[t._v("上述的冲突解决方案仅保留了其中一个分支的修改，并且 <<<<<<< , ======= , 和 >>>>>>> 这些行被完全删除了。"),r("strong",[t._v("在你解决了所有文件里的冲突之后，对每个文件使用 git add 命令来将其标记为冲突已解决")]),t._v("。"),r("strong",[t._v("一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决")]),t._v("。")]),t._v(" "),r("h3",{attrs:{id:"跟踪分支"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#跟踪分支"}},[t._v("#")]),t._v(" 跟踪分支")]),t._v(" "),r("h4",{attrs:{id:"git-checkout-b-branch-remotename-branch"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-checkout-b-branch-remotename-branch"}},[t._v("#")]),t._v(" git checkout -b [branch] [remotename]/[branch]")]),t._v(" "),r("ol",[r("li",[t._v("该命令用于从一个远程跟踪分支检出一个本地分支会自动创建一个叫做 “跟踪分支”（有时候也叫做 “上游分支”）。"),r("strong",[t._v("跟踪分支")]),t._v("是与远程分支有直接关系的本地分支。如果在一个跟踪分支上输入 git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。")]),t._v(" "),r("li",[r("code",[t._v("git checkout --track origin/serverfix")]),t._v("是同样的作用，用于跟踪远程分支。该命令将新建一个跟踪对应远程分支的本地分支。")])]),t._v(" "),r("h4",{attrs:{id:"git-checkout-u-remotename-branch"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-checkout-u-remotename-branch"}},[t._v("#")]),t._v(" git checkout -u [remotename]/[branch]")]),t._v(" "),r("ol",[r("li",[t._v("前面的命令只能在本地还没有跟踪远程分支的时候创建一个跟踪分支，当本地已经存在分支或者本地的分支已经跟踪了另一个远程分支，此时可以使用该命令来显示表示跟踪哪个远程分支。")]),t._v(" "),r("li",[t._v("设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用 -u 或 "),r("code",[t._v("git branch --set-upstream-to=origin/<branch> branch")]),t._v(" 选项运行 git branch 来显式地设置。")])]),t._v(" "),r("h4",{attrs:{id:"git-branch-vv"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-branch-vv"}},[t._v("#")]),t._v(" git branch -vv")]),t._v(" "),r("ol",[r("li",[t._v("该命令用于显示分支的跟踪信息，即与远程分支的对应关系。")]),t._v(" "),r("li",[t._v("如果想要查看设置的所有跟踪分支，可以使用 git branch 的 -vv 选项。这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。")])]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919229.png",alt:"img"}})]),t._v(" "),r("h3",{attrs:{id:"变基"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#变基"}},[t._v("#")]),t._v(" 变基")]),t._v(" "),r("h4",{attrs:{id:"git-rebase-branch"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-rebase-branch"}},[t._v("#")]),t._v(" git rebase [branch]")]),t._v(" "),r("p",[t._v("我们可以使用git merge将一个分支合并到当前分支，它会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919276.png",alt:"img"}})]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919272.png",alt:"img"}})]),t._v(" "),r("p",[t._v("其实，还有一种方法：你可以提取在 C4 中引入的补丁和修改，然后在 C3 的基础上应用一次。在 Git 中，这种操作就叫做 变基。你可以使用 rebase 命令"),r("strong",[t._v("将提交到某一分支上的所有修改都移至另一分支上")]),t._v("，就好像“重新播放”一样。")]),t._v(" "),r("p",[t._v("语法：")]),t._v(" "),r("div",{staticClass:"language-git extra-class"},[r("pre",{pre:!0,attrs:{class:"language-git"}},[r("code",[t._v("git checkout experiment\ngit rebase master\n")])])]),r("p",[r("strong",[t._v("原理："),r("strong",[t._v("首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master）的")]),t._v("最近共同祖先")]),t._v(" C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919344.png",alt:"img"}})]),t._v(" "),r("p",[t._v("但是，仅仅使用rebase命令并不意味着达到了最终的目的，此时experiment和master并不指向同一个对象，此时还需要使用一次merge命令来进行分支的合并。")]),t._v(" "),r("div",{staticClass:"language-git extra-class"},[r("pre",{pre:!0,attrs:{class:"language-git"}},[r("code",[t._v("git checkout master\ngit merge experiment\n")])])]),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919461.png",alt:"img"}})]),t._v(" "),r("p",[t._v("此时，C4' 指向的快照就和上面使用 merge 命令的例子中 C5 指向的快照一模一样了。**这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。**你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。")]),t._v(" "),r("p",[t._v("一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。在这种情况下，"),r("strong",[t._v("你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到origin/master 上，然后再向主项目提交修改。这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可")]),t._v("。")]),t._v(" "),r("h4",{attrs:{id:"git-rebase-onto-master-server-client"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-rebase-onto-master-server-client"}},[t._v("#")]),t._v(" git rebase --onto master server client")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919127.png",alt:"img"}})]),t._v(" "),r("p",[t._v("假设你希望将 client 中的修改合并到主分支并发布，但暂时并不想合并 server 中的修改，因为它们还需要经过更全面的测试。这时，你就可以使用 git rebase 命令的 --onto 选项，"),r("strong",[t._v("选中在 client 分支里但不在server 分支里的修改")]),t._v("（即 C8 和 C9），将它们在 master 分支上重放："),r("code",[t._v("git rebase --onto master server client")])]),t._v(" "),r("p",[t._v("以上命令的意思是：“取出 client 分支，找出处于 client 分支和 server 分支的共同祖先之后的修改，然后把它们在 master 分支上重放一遍”。这理解起来有一点复杂，不过效果非常酷。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919107.png",alt:"img"}})]),t._v(" "),r("p",[t._v("现在可以快进合并 master 分支了。")]),t._v(" "),r("div",{staticClass:"language-git extra-class"},[r("pre",{pre:!0,attrs:{class:"language-git"}},[r("code",[t._v("git checkout master\ngit merge client\n")])])]),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203291919096.png",alt:"img"}})])])}),[],!1,null,null,null);a.default=s.exports}}]);