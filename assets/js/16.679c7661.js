(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{570:function(a,e,r){"use strict";r.r(e);var t=r(14),v=Object(t.a)({},(function(){var a=this,e=a.$createElement,r=a._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h2",{attrs:{id:"概览"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#概览"}},[a._v("#")]),a._v(" 概览")]),a._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231632448.png",alt:"img"}})]),a._v(" "),r("p",[a._v("注：如果两个收集器之间存在连线，就说明它们可以"),r("strong",[a._v("搭配使用")]),a._v("[3]，图中收集器所处的区域，则表示它是属于新生代收集器抑或是老年代收集器。")]),a._v(" "),r("h2",{attrs:{id:"serial收集器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#serial收集器"}},[a._v("#")]),a._v(" Serial收集器")]),a._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231632003.png",alt:"img"}})]),a._v(" "),r("p",[a._v("Serial收集器是最基础、历史最悠久的收集器，曾经（在JDK 1.3.1之前）是HotSpot虚拟机新生代收集器的唯一选择。大家只看名字就能够猜到，这个收集器是一个单线程工作的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是"),r("strong",[a._v("强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束")]),a._v("。")]),a._v(" "),r("p",[a._v("“Stop The World”这个词语也许听起来很酷，但这项工作是由虚拟机在后台自动发起和自动完成的，在用户不可知、不可控的情况下把用户的正常工作的线程全部停掉，这对很多应用来说都是不能接受的。")]),a._v(" "),r("p",[a._v("从JDK 1.3开始，一直到现在最新的JDK 13，HotSpot虚拟机开发团队为消除或者降低用户线程因垃圾收集而导致停顿的努力一直持续进行着，从Serial收集器到Parallel收集器，再到Concurrent Mark Sweep（CMS）和Garbage First（G1）收集器，最终至现在垃圾收集器的最前沿成果Shenandoah和ZGC等，我们看到了一个个越来越构思精巧，越来越优秀，也越来越复杂的垃圾收集器不断涌现，"),r("strong",[a._v("用户线程的停顿时间在持续缩短，但是仍然没有办法彻底消除")]),a._v("。")]),a._v(" "),r("p",[a._v("迄今为止，它依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器，有着优于其他收集器的地方，那就是"),r("strong",[a._v("简单而高效（与其他收集器的单线程相比）")]),a._v("，对于内存资源受限的环境，它是所有收集器里额外内存消耗（Memory Footprint）[1]最小的；"),r("strong",[a._v("对于单核处理器或处理器核心数较少的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。")])]),a._v(" "),r("p",[a._v("在用户桌面的应用场景以及近年来流行的部分微服务应用中，分配给虚拟机管理的内存一般来说并不会特别大，收集几十兆甚至一两百兆的新生代（仅仅是指新生代使用的内存，桌面应用甚少超过这个容量），垃圾收集的停顿时间完全可以控制在十几、几十毫秒，最多一百多毫秒以内，只要不是频繁发生收集，这点停顿时间对许多用户来说是完全可以接受的。所以，"),r("strong",[a._v("Serial收集器对于运行在客户端模式下的虚拟机来说是一个很好的选择")]),a._v("。")]),a._v(" "),r("h2",{attrs:{id:"parnew收集器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#parnew收集器"}},[a._v("#")]),a._v(" ParNew收集器")]),a._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231632114.png",alt:"img"}})]),a._v(" "),r("p",[a._v("ParNew收集器"),r("strong",[a._v("实质上是Serial收集器的多线程并行版本")]),a._v("，除了同时使用多条线程进行垃圾收集之外，其余的行为包括Serial收集器可用的所有控制参数（例如：-XX：SurvivorRatio、-XX：PretenureSizeThreshold、-XX：HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致，在实现上这两种收集器也共用了相当多的代码。")]),a._v(" "),r("p",[a._v("ParNew收集器除了支持多线程并行收集之外，其他与Serial收集器相比并没有太多创新之处，但它却是不少运行在"),r("strong",[a._v("服务端模式")]),a._v("下的HotSpot虚拟机，尤其是JDK 7之前的遗留系统中首选的新生代收集器，其中有一个与功能、性能无关但其实很重要的原因是："),r("strong",[a._v("除了Serial收集器外，目前只有它能与CMS收集器配合工作")]),a._v("。")]),a._v(" "),r("p",[a._v("在JDK 5发布时，HotSpot推出了一款在强交互应用中几乎可称为具有划时代意义的垃圾收集器——CMS收集器。这款收集器是HotSpot虚拟机中第一款真正意义上支持并发的垃圾收集器，它首次实现了让垃圾收集线程与用户线程（基本上）同时工作。")]),a._v(" "),r("p",[a._v("遗憾的是，"),r("strong",[a._v("CMS作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作")]),a._v("[1]，所以在JDK 5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。ParNew收集器是激活CMS后（使用-XX：+UseConcMarkSweepGC选项）的默认新生代收集器。")]),a._v(" "),r("p",[a._v("可以说直到CMS的出现才巩固了ParNew的地位，但成也萧何败也萧何，随着垃圾收集器技术的不断改进，更先进的G1收集器带着CMS继承者和替代者的光环登场。"),r("strong",[a._v("G1是一个面向全堆的收集器，不再需要其他新生代收集器的配合工作")]),a._v("。所以自JDK 9开始，ParNew加CMS收集器的组合就不再是官方推荐的服务端模式下的收集器解决方案了。官方希望它能完全被G1所取代，甚至还取消了ParNew加Serial Old以及Serial加CMS这两组收集器组合的支持。")]),a._v(" "),r("p",[a._v("这意味着ParNew和CMS从此只能互相搭配使用，再也没有其他收集器能够和它们配合了。读者也可以理解为从此以后，ParNew合并入CMS，成为它专门处理新生代的组成部分。"),r("strong",[a._v("ParNew可以说是HotSpot虚拟机中第一款退出历史舞台的垃圾收集器。")])]),a._v(" "),r("p",[a._v("ParNew收集器在单核心处理器的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程（Hyper-Threading）技术实现的伪双核处理器环境中都不能百分之百保证超越Serial收集器。"),r("strong",[a._v("当然，随着可以被使用的处理器核心数量的增加，ParNew对于垃圾收集时系统资源的高效利用还是很有好处的。")])]),a._v(" "),r("h2",{attrs:{id:"parallel-scavenge收集器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#parallel-scavenge收集器"}},[a._v("#")]),a._v(" Parallel Scavenge收集器")]),a._v(" "),r("p",[a._v("Parallel Scavenge收集器也是一款新生代收集器，"),r("strong",[a._v("它同样是基于复制算法实现的收集器")]),a._v("，也是能够并行收集的多线程收集器……Parallel Scavenge的诸多特性从表面上看和ParNew非常相似。"),r("strong",[a._v("新生代采用复制算法，老年代采用标记-整理算法。")])]),a._v(" "),r("p",[a._v("Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，"),r("strong",[a._v("CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）")]),a._v("。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值。")]),a._v(" "),r("p",[a._v("如果虚拟机完成某个任务，用户代码加上垃圾收集总共耗费了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，良好的响应速度能提升用户体验；"),r("strong",[a._v("而高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务")]),a._v("。")]),a._v(" "),r("p",[a._v("Parallel Scavenge收集器提供了两个参数用于"),r("strong",[a._v("精确控制吞吐量")]),a._v("，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数。")]),a._v(" "),r("p",[a._v("**这是 JDK1.8 默认收集器：**使用java -XX:+PrintCommandLineFlags -version命令查看。")]),a._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231632709.png",alt:"img"}})]),a._v(" "),r("p",[a._v("JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old，如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能")]),a._v(" "),r("h2",{attrs:{id:"serial-old收集器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#serial-old收集器"}},[a._v("#")]),a._v(" Serial Old收集器")]),a._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231633815.png",alt:"img"}})]),a._v(" "),r("p",[a._v("Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用"),r("strong",[a._v("标记-整理")]),a._v("算法。这个收集器的主要意义也是"),r("strong",[a._v("供客户端模式下的HotSpot虚拟机使用")]),a._v("。如果在服务端模式下，它也可能有两种用途：一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用[1]，另外一种就是作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。")]),a._v(" "),r("h2",{attrs:{id:"parallel-old收集器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#parallel-old收集器"}},[a._v("#")]),a._v(" Parallel Old收集器")]),a._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231633592.png",alt:"img"}})]),a._v(" "),r("p",[r("strong",[a._v("Parallel Old是Parallel Scavenge收集器的老年代版本")]),a._v("，支持多线程并发收集，基于"),r("strong",[a._v("标记-整理")]),a._v("算法实现。这个收集器是直到JDK 6时才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于相当尴尬的状态，原因是如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old（PSMarkSweep）收集器以外别无选择，其他表现良好的老年代收集器，如CMS无法与它配合工作。")]),a._v(" "),r("p",[a._v("由于老年代Serial Old收集器在服务端应用性能上的“拖累”，使用Parallel Scavenge收集器也未必能在整体上获得吞吐量最大化的效果。同样，由于单线程的老年代收集中无法充分利用服务器多处理器的并行处理能力，在老年代内存空间很大而且硬件规格比较高级的运行环境中，这种组合的总吞吐量甚至不一定比ParNew加CMS的组合来得优秀。")]),a._v(" "),r("p",[a._v("直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的搭配组合，在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。")]),a._v(" "),r("h2",{attrs:{id:"cms收集器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cms收集器"}},[a._v("#")]),a._v(" CMS收集器")]),a._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231632961.png",alt:"img"}})]),a._v(" "),r("p",[a._v("CMS（Concurrent Mark Sweep）收集器是一种"),r("strong",[a._v("以获取最短回收停顿时间为目标")]),a._v("的收集器。目前很大一部分的Java应用集中在互联网网站或者基于浏览器的B/S系统的服务端上，这类应用通常都会较为关注服务的响应速度，希望系统停顿时间尽可能短，以"),r("strong",[a._v("给用户带来良好的交互体验")]),a._v("。CMS收集器就非常符合这类应用的需求。")]),a._v(" "),r("p",[a._v("从名字（包含“Mark Sweep”）上就可以看出CMS收集器是"),r("strong",[a._v("基于标记-清除算法")]),a._v("实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为四个步骤，包括：")]),a._v(" "),r("p",[a._v("1）初始标记（CMS initial mark）")]),a._v(" "),r("p",[a._v("2）并发标记（CMS concurrent mark）")]),a._v(" "),r("p",[a._v("3）重新标记（CMS remark）")]),a._v(" "),r("p",[a._v("4）并发清除（CMS concurrent sweep）")]),a._v(" "),r("p",[a._v("其中"),r("strong",[a._v("初始标记、重新标记这两个步骤仍然需要“Stop The World”")]),a._v("。初始标记仅仅只是标记一下GCRoots能直接关联到的对象，速度很快；并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；最后是"),r("strong",[a._v("并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的")]),a._v("。")]),a._v(" "),r("p",[a._v("由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。")]),a._v(" "),r("p",[a._v("CMS是一款优秀的收集器，它最主要的优点在名字上已经体现出来：并发收集、低停顿，一些官方公开文档里面也称之为“"),r("strong",[a._v("并发低停顿收集器")]),a._v("”（Concurrent Low Pause Collector）。CMS收集器是HotSpot虚拟机追求低停顿的第一次成功尝试，但是它还远达不到完美的程度，至少有以下三个明显的缺点：")]),a._v(" "),r("ol",[r("li",[r("p",[a._v("首先，CMS收集器"),r("strong",[a._v("对处理器资源非常敏感")]),a._v("。事实上，面向并发设计的程序都对处理器资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量。"),r("strong",[a._v("CMS默认启动的回收线程数是（处理器核心数量+3）/4")]),a._v("，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过25%的处理器运算资源，并且会随着处理器核心数量的增加而下降。但是"),r("strong",[a._v("当处理器核心数量不足四个时，CMS对用户程序的影响就可能变得很大")]),a._v("。如果应用本来的处理器负载就很高，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然大幅降低。为了缓解这种情况，虚拟机提供了一种称为“增量式并发收集器”（Incremental Concurrent Mark Sweep/i-CMS）的CMS收集器变种，所做的事情和以前单核处理器年代PC机操作系统靠抢占式多任务来模拟多核并行多任务的思想一样，是"),r("strong",[a._v("在并发标记、清理的时候让收集器线程、用户线程交替运行，尽量减少垃圾收集线程的独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得较少一些")]),a._v("，直观感受是速度变慢的时间更多了，但速度下降幅度就没有那么明显。实践证明增量式的CMS收集器效果很一般，从JDK 7开始，i-CMS模式已经被声明为“deprecated”，即已过时不再提倡用户使用，到JDK 9发布后i-CMS模式被完全废弃。")])]),a._v(" "),r("li",[r("p",[a._v("然后，由于CMS收集器无法处理“浮动垃圾”（Floating Garbage），有可能出现“Con-current Mode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生。在CMS的"),r("strong",[a._v("并发标记和并发清理阶段")]),a._v("，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，"),r("strong",[a._v("只好留待下一次垃圾收集时再清理掉")]),a._v("。这一部分垃圾就称为“浮动垃圾”。同样也是由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。在JDK5的默认设置下，"),r("strong",[a._v("CMS收集器当老年代使用了68%的空间后就会被激活")]),a._v("。")])]),a._v(" "),r("li",[r("p",[a._v("还有最后一个缺点，在本节的开头曾提到，CMS是一款基于“标记-清除”算法实现的收集器，如果读者对前面这部分介绍还有印象的话，就可能想到这意味着"),r("strong",[a._v("收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC的情况")]),a._v("。")])])]),a._v(" "),r("h2",{attrs:{id:"garbage-first-g1-收集器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#garbage-first-g1-收集器"}},[a._v("#")]),a._v(" Garbage First（G1）收集器")]),a._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231633178.png",alt:"img"}})]),a._v(" "),r("p",[a._v("Garbage First（简称G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。")]),a._v(" "),r("p",[a._v("G1是一款主要"),r("strong",[a._v("面向服务端应用的垃圾收集器")]),a._v("。HotSpot开发团队最初赋予它的期望是（在比较长期的）未来可以替换掉JDK 5中发布的CMS收集器。现在这个期望目标已经实现过半了，"),r("strong",[a._v("JDK 9发布之日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器，而CMS则沦落至被声明为不推荐使用（Deprecate）的收集器")]),a._v("[1]。")]),a._v(" "),r("p",[a._v("作为CMS收集器的替代者和继承人，设计者们希望做出一款能够建立起“停顿时间模型”（Pause Prediction Model）的收集器，"),r("strong",[a._v("停顿时间模型的意思是能够支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标")]),a._v("，这几乎已经是实时Java（RTSJ）的中软实时垃圾收集器特征了。")]),a._v(" "),r("p",[a._v("那具体要怎么做才能实现这个目标呢？首先要有一个思想上的改变，在G1收集器出现之前的所有其他收集器，包括CMS在内，垃圾收集的目标范围要么是整个新生代（Minor GC），要么就是整个老年代（Major GC），再要么就是整个Java堆（Full GC）。"),r("strong",[a._v("而G1跳出了这个樊笼，它可以面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。")])]),a._v(" "),r("p",[a._v("G1开创的基于Region的堆内存布局是它能够实现这个目标的关键。虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异："),r("strong",[a._v("G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间")]),a._v("。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。")]),a._v(" "),r("p",[a._v("虽然G1仍然保留新生代和老年代的概念，但"),r("strong",[a._v("新生代和老年代不再是固定的了，它们都是一系列区域（不需要连续）的动态集合")]),a._v("。G1收集器之所以能建立可预测的停顿时间模型，是因为"),r("strong",[a._v("它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集")]),a._v("。更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，"),r("strong",[a._v("价值即回收所获得的空间大小以及回收所需时间的经验值")]),a._v("，然后"),r("strong",[a._v("在后台维护一个优先级列表")]),a._v("，每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默认值是200毫秒），"),r("strong",[a._v("优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名字的由来")]),a._v("。这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。")]),a._v(" "),r("p",[a._v("如果我们不去计算用户线程运行过程中的动作（如使用写屏障维护记忆集的操作），G1收集器的运作过程大致可划分为以下四个步骤：")]),a._v(" "),r("ol",[r("li",[r("p",[a._v("初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。")])]),a._v(" "),r("li",[r("p",[a._v("并发标记（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。")])]),a._v(" "),r("li",[r("p",[a._v("最终标记（Final Marking）：对用户线程做另一个"),r("strong",[a._v("短暂的暂停")]),a._v("，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。")])]),a._v(" "),r("li",[r("p",[a._v("筛选回收（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后"),r("strong",[a._v("把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间")]),a._v("。"),r("strong",[a._v("这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的")]),a._v("。")])])]),a._v(" "),r("p",[a._v("从上述阶段的描述可以看出，"),r("strong",[a._v("G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的")]),a._v("，换言之，它并非纯粹地追求低延迟，官方给它设定的目标是"),r("strong",[a._v("在延迟可控的情况下获得尽可能高的吞吐量")]),a._v("，所以才能担当起“全功能收集器”的重任与期望。")]),a._v(" "),r("p",[a._v("毫无疑问，可以由用户指定期望的停顿时间是G1收集器很强大的一个功能，"),r("strong",[a._v("设置不同的期望停顿时间，可使得G1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡")]),a._v("。不过，这里设置的“期望值”必须是符合实际的，不能异想天开，毕竟G1是要冻结用户线程来复制对象的，这个停顿时间再怎么低也得有个限度。它默认的停顿目标为两百毫秒，一般来说，回收阶段占到几十到一百甚至接近两百毫秒都很正常，但如果我们把停顿时间调得非常低，譬如设置为二十毫秒，很可能出现的结果就是由于停顿目标时间太短，导致每次选出来的回收集只占堆内存很小的一部分，收集器收集的速度逐渐跟不上分配器分配的速度，导致垃圾慢慢堆积。很可能一开始收集器还能从空闲的堆内存中获得一些喘息的时间，但应用运行时间一长就不行了，最终占满堆引发Full GC反而降低性能，所以通常把期望停顿时间设置为一两百毫秒或者两三百毫秒会是比较合理的。")]),a._v(" "),r("p",[a._v("G1收集器常会被拿来与CMS收集器互相比较，毕竟它们都非常关注停顿时间的控制。G1相对于CMS仍然不是占全方位、压倒性优势的，从它出现几年仍不能在所有应用场景中代替CMS就可以得知这个结论。比起CMS，G1的弱项也可以列举出不少，如在用户程序运行过程中，"),r("strong",[a._v("G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高")]),a._v("。")]),a._v(" "),r("ol",[r("li",[r("p",[a._v("就内存占用来说，虽然G1和CMS都使用卡表来处理"),r("strong",[a._v("跨代指针")]),a._v("，但G1的卡表实现更为复杂，而且堆中每个Region，无论扮演的是新生代还是老年代角色，都必须有一份卡表，这导致G1的记忆集（和其他内存消耗）可能会占整个堆容量的20%乃至更多的内存空间；相比起来CMS的卡表就相当简单，只有唯一一份，而且只需要处理老年代到新生代的引用，反过来则不需要，由于新生代的对象具有朝生夕灭的不稳定性，引用变化频繁，能省下这个区域的维护开销是很划算的[6]。")])]),a._v(" "),r("li",[r("p",[a._v("在执行负载的角度上，同样由于两个收集器各自的细节实现特点导致了用户程序运行时的负载会有不同，譬如它们都使用到写屏障，CMS用写后屏障来更新维护卡表；而G1除了使用写后屏障来进行同样的（由于G1的卡表结构复杂，其实是更烦琐的）卡表维护操作外，为了实现原始快照搜索（SATB）算法，还需要使用写前屏障来跟踪并发时的指针变化情况。相比起增量更新算法，原始快照搜索能够减少并发标记和重新标记阶段的消耗，避免CMS那样在最终标记阶段停顿时间过长的缺点，但是在用户程序运行过程中确实会产生由跟踪引用变化带来的额外负担。由于G1对写屏障的复杂操作要比CMS消耗更多的运算资源，所以CMS的写屏障实现是直接的同步操作，而G1就不得不将其实现为类似于消息队列的结构，把写前屏障和写后屏障中要做的事情都放到队列里，然后再异步处理。")])])]),a._v(" "),r("p",[a._v("以上的优缺点对比仅仅是针对G1和CMS两款垃圾收集器单独某方面的实现细节的定性分析，通常我们说哪款收集器要更好、要好上多少，往往是针对具体场景才能做的定量比较。按照笔者的实践经验，目前在小内存应用上CMS的表现大概率仍然要会优于G1，而在大内存应用上G1则大多能发挥其优势，这个优劣势的Java堆容量平衡点通常在6GB至8GB之间，当然，以上这些也仅是经验之谈，不同应用需要量体裁衣地实际测试才能得出最合适的结论，随着HotSpot的开发者对G1的不断优化，也会让对比结果继续向G1倾斜。")]),a._v(" "),r("h2",{attrs:{id:"垃圾收集器相关的参数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集器相关的参数"}},[a._v("#")]),a._v(" 垃圾收集器相关的参数")]),a._v(" "),r("p",[a._v("-XX:+UseSerialGC，虚拟机运行在Client 模式下的默认值，打开此开关后，使用Serial + Serial Old 的收集器组合进行内存回收")]),a._v(" "),r("p",[a._v("-XX:+UseConcMarkSweepGC，打开此开关后，使用"),r("strong",[a._v("ParNew + CMS + Serial Old")]),a._v(" 的收集器组合进行内存回收。Serial Old 收集器将作为CMS 收集器出现Concurrent Mode Failure失败后的后备收集器使用。（我们的线上服务用的都是这个）")]),a._v(" "),r("p",[a._v("-XX:+UseParallelGC，虚拟机运行在Server 模式下的默认值，打开此开关后，使用"),r("strong",[a._v("Parallel Scavenge + Serial Old")]),a._v("（PS MarkSweep）的收集器组合进行内存回收。")]),a._v(" "),r("p",[a._v("-XX:+UseParallelOldGC，打开此开关后，使用Parallel Scavenge + Parallel Old 的收集器组合进行内存回收。")]),a._v(" "),r("p",[a._v("-XX:+UseG1GC，打开此开关后，采用 Garbage First (G1) 收集器")]),a._v(" "),r("p",[a._v("-XX:+UseParNewGC，在JDK1.8被废弃，在JDK1.7还可以使用。打开此开关后，使用ParNew + Serial Old 的收集器组合进行内存回收")]),a._v(" "),r("p",[a._v("参考链接：")]),a._v(" "),r("p",[a._v("https://www.pianshen.com/article/7390335728/")]),a._v(" "),r("h2",{attrs:{id:"目前通常使用的是什么垃圾收集器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#目前通常使用的是什么垃圾收集器"}},[a._v("#")]),a._v(" 目前通常使用的是什么垃圾收集器？")]),a._v(" "),r("h3",{attrs:{id:"怎么查询当前jvm使用的垃圾收集器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#怎么查询当前jvm使用的垃圾收集器"}},[a._v("#")]),a._v(" 怎么查询当前JVM使用的垃圾收集器？")]),a._v(" "),r("p",[a._v("使用这个命令可以查询当前使用的垃圾收集器 java -XX:+PrintCommandLineFlags -version")]),a._v(" "),r("p",[a._v("另外这个命令可以查询到更加详细的信息")]),a._v(" "),r("p",[a._v("java -XX:+PrintFlagsFinal -version | grep GC")]),a._v(" "),r("p",[a._v("我们在IDEA中启动的一个Springboot的项目，默认使用的垃圾收集器参数是 -XX:+UseParallelGC")]),a._v(" "),r("div",{staticClass:"language-shell extra-class"},[r("pre",{pre:!0,attrs:{class:"language-shell"}},[r("code",[a._v("-XX:InitialHeapSize"),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),r("span",{pre:!0,attrs:{class:"token number"}},[a._v("134217728")]),a._v(" \n-XX:MaxHeapSize"),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),r("span",{pre:!0,attrs:{class:"token number"}},[a._v("2147483648")]),a._v(" \n-XX:+PrintCommandLineFlags \n-XX:+UseCompressedClassPointers \n-XX:+UseCompressedOops \n-XX:+UseParallelGC  java version "),r("span",{pre:!0,attrs:{class:"token string"}},[a._v('"1.8.0_73"')]),a._v(" \nJava"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("TM"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" SE Runtime Environment "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("build "),r("span",{pre:!0,attrs:{class:"token number"}},[a._v("1.8")]),a._v(".0_73-b02"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" \nJava HotSpot"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("TM"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[a._v("64")]),a._v("-Bit Server VM "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("build "),r("span",{pre:!0,attrs:{class:"token number"}},[a._v("25.73")]),a._v("-b02, mixed mode"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("点\n")])])]),r("h3",{attrs:{id:"parallel-scavenge-serial-old"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#parallel-scavenge-serial-old"}},[a._v("#")]),a._v(" Parallel Scavenge+Serial Old")]),a._v(" "),r("p",[a._v("JDK8默认情况下服务端模式下JVM垃圾回收参数是-XX:+UseParallelGC参数，也就是会使用"),r("strong",[a._v("Parallel Scavenge+Serial Old")]),a._v("的收集器组合，进行内存回收。")]),a._v(" "),r("h3",{attrs:{id:"parnew-cms"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#parnew-cms"}},[a._v("#")]),a._v(" ParNew+CMS")]),a._v(" "),r("p",[a._v("但是一般如果我们的后端应用不是那种需要进行大量计算的应用，基于低延迟的考虑，可以考虑使用-XX:+UseConcMarkSweepGC进行垃圾收集，这种配置下会使用ParNew来收集新生代内存，CMS垃圾回收器收集老年代内存。")]),a._v(" "),r("h3",{attrs:{id:"g1"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#g1"}},[a._v("#")]),a._v(" G1")]),a._v(" "),r("p",[a._v("在JDK9时，默认的垃圾收集器是G1收集器，也可以使用-XX:+UseG1GC参数来启动G1垃圾收集器。")]),a._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231633259.png",alt:"img"}})])])}),[],!1,null,null,null);e.default=v.exports}}]);