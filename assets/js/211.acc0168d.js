(window.webpackJsonp=window.webpackJsonp||[]).push([[211],{766:function(a,t,s){"use strict";s.r(t);var e=s(14),n=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"hashset的value存放的是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashset的value存放的是什么"}},[a._v("#")]),a._v(" HashSet的value存放的是什么？")]),a._v(" "),s("ol",[s("li",[a._v("HashSet底层依赖的是HashMap，它组合了一个HashMap作为其成员变量。")]),a._v(" "),s("li",[a._v("它的value是设置为一个静态常量对象。")])]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("transient")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("HashMap")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("E")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" map"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// Dummy value to associate with an Object in the backing Map")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" PRESENT "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("h2",{attrs:{id:"hashmap-和-hashtable-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap-和-hashtable-的区别"}},[a._v("#")]),a._v(" HashMap 和 Hashtable 的区别")]),a._v(" "),s("ol",[s("li",[s("strong",[a._v("线程是否安全：")]),a._v(" HashMap 是非线程安全的，HashTable 是线程安全的,因为 HashTable 内部的方法都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；")]),a._v(" "),s("li",[s("strong",[a._v("效率：")]),a._v(" 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；")]),a._v(" "),s("li",[s("strong",[a._v("对 Null key 和 Null value 的支持：")]),a._v(" HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；HashTable 不允许有 null 键和 null 值，否则会抛出 NullPointerException。")]),a._v(" "),s("li",[s("strong",[a._v("初始容量大小和每次扩充容量大小的不同 ：")]),a._v(" "),s("ul",[s("li",[a._v("创建时如果不指定容量初始值，Hashtable 默认的"),s("strong",[a._v("初始大小为 11")]),a._v("，之后"),s("strong",[a._v("每次扩充，容量变为原来的 2n+1")]),a._v("。HashMap 默认的"),s("strong",[a._v("初始化大小为 16")]),a._v("。之后"),s("strong",[a._v("每次扩充，容量变为原来的 2 倍")]),a._v("。")]),a._v(" "),s("li",[a._v("创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小（HashMap 中的tableSizeFor()方法保证，下面给出了源代码）。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小，后面会介绍到为什么是 2 的幂次方。")])])]),a._v(" "),s("li",[s("strong",[a._v("底层数据结构：")]),a._v(" JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。")])]),a._v(" "),s("h2",{attrs:{id:"hashmap扰动函数的作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap扰动函数的作用"}},[a._v("#")]),a._v(" HashMap扰动函数的作用？")]),a._v(" "),s("ol",[s("li",[a._v("往HashMap中存放新元素时，需要使用上述讲到的 (n - 1) & hash计算元素在哈希桶的位置，但是源码中并没有直接使用这个公式，而是先将hash进行了一些额外的计算和设置。")])]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("hash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" h"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("key "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("?")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("h "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("hashCode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("^")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("h "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">>>")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("16")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// >>>表示无符号右移")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("ol",{attrs:{start:"2"}},[s("li",[a._v("可以看到这个方法大概的作用就是："),s("strong",[a._v("高 16bit 不变，低 16bit 和高 16bit 做了一个异或。")])]),a._v(" "),s("li",[a._v("在设计 hash 方法时，因为目前的 table 长度 n 为 2 的幂，而计算下标的时候，是这样实现的(使用 & 位操作，而非 % 求余)：(n - 1) & hash")]),a._v(" "),s("li",[a._v("设计者认为这方法很容易发生碰撞。为什么这么说呢？不妨思考一下，在 n - 1 为 15(0x1111) 时，"),s("strong",[a._v("其实散列真正生效的只是低 4bit 的有效位，当然容易碰撞了")]),a._v("。")]),a._v(" "),s("li",[a._v("因此，设计者想了一个顾全大局的方法(综合考虑了速度、作用、质量)，就是把高 16bit 和低 16bit 异或了一下。设计者还解释到因为现在大多数的 hashCode 的分布已经很不错了，就算是发生了碰撞也用 O(logn)的 tree 去做了。仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table 长度比较小时)，从而引起的碰撞。")]),a._v(" "),s("li",[s("strong",[a._v("说白了，使用扰动函数就是为了增加随机性，让数据元素更加均衡的散列，减少碰撞。")])]),a._v(" "),s("li",[a._v("如果还是产生了频繁的碰撞，会发生什么问题呢？作者注释说，他们使用树来处理频繁的碰撞(we use trees to handle large sets of collisions in bins)。")])]),a._v(" "),s("h2",{attrs:{id:"哈希桶长度为什么设置为2的幂次方"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#哈希桶长度为什么设置为2的幂次方"}},[a._v("#")]),a._v(" 哈希桶长度为什么设置为2的幂次方？")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("由tableSizeFor方法我们可以看到，HashMap将初始化容量设置为2的幂次方。")])]),a._v(" "),s("li",[s("p",[a._v("为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。**所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。**这个数组下标的计算方法是“ (n - 1) & hash”。（n 代表数组长度）。")])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("只有当n是2的幂次方时，n-1转换为2进制时，每一位都是1，再和hash进行与运算时，能够很好地打散加入hashmap的元素，使其均匀分布到每个桶中。")])])]),a._v(" "),s("li",[s("p",[a._v("这也就解释了 HashMap 的长度为什么是 2 的幂次方。")])])]),a._v(" "),s("h2",{attrs:{id:"hashmap扩容原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap扩容原理"}},[a._v("#")]),a._v(" HashMap扩容原理")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("当 put 时，如果发现目前的 bucket 占用程度已经超过了 Load Factor 所希望的比例，那么就会发生 resize。在 resize 的过程，简单的说就是把 bucket 扩充为 2 倍，之后重新计算 index，把节点再放到新的 bucket 中。")])]),a._v(" "),s("li",[s("p",[a._v("当超过限制的时候会 resize，然而又因为我们使用的是 2 次幂的扩展(指长度扩为原来 2 倍)，所以，"),s("strong",[a._v("元素的位置要么是在原位置，要么是在原位置加上原容量的位置。")])])]),a._v(" "),s("li",[s("p",[a._v("元素在重新计算 hash 之后，因为 n 变为 2 倍，那么 n-1 的 mask 范围在高位多 1bit(红色)，因此新的 index 就会发生这样的变化：")])])]),a._v(" "),s("p",[s("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203211920025.png",alt:"img"}})]),a._v(" "),s("ol",{attrs:{start:"4"}},[s("li",[a._v("因此，我们在扩充 HashMap 的时候，不需要重新计算 hash，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就好了（"),s("strong",[a._v("代码中使用")]),a._v(" "),s("strong",[a._v("hash & oldCap == 0来实现")]),a._v("），是 0 的话索引没变，是 1 的话索引变成“原索引+oldCap”。")])]),a._v(" "),s("h2",{attrs:{id:"arraylist的扩容机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#arraylist的扩容机制"}},[a._v("#")]),a._v(" ArrayList的扩容机制？")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("判断长度充足： ensureCapacityInternal(size + 1);")])]),a._v(" "),s("li",[s("p",[a._v("当判断长度不足时，则通过扩大函数，进行扩容： grow(int minCapacity)")])]),a._v(" "),s("li",[s("p",[a._v("扩容的长度计算： int newCapacity = oldCapacity +\n(oldCapacity >> 1)。旧容量 + 旧容量右移 1 位，这相当于**扩容了原来容\n**"),s("strong",[a._v("量的 (int)3/2，即1.5倍")]),a._v(" 。")])]),a._v(" "),s("li",[s("p",[a._v("当扩容完以后，就需要进行把数组中的数据拷贝到新数组中，这个过程会用到\nArrays.copyOf(elementData, newCapacity)，但他的底层用到的\n是System. arraycopy")])])]),a._v(" "),s("h2",{attrs:{id:"有哪些集合是线程不安全的-怎么解决呢"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#有哪些集合是线程不安全的-怎么解决呢"}},[a._v("#")]),a._v(" 有哪些集合是线程不安全的？怎么解决呢？")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("我们常用的 Arraylist ,LinkedList,Hashmap,HashSet,TreeSet,TreeMap，PriorityQueue 都不是线程安全的。解决办法很简单，可以使用线程安全的集合来代替。"),s("strong",[a._v("但是Vector，Hashtable是线程安全的，这些线程安全的容器也叫做同步容器。")])])]),a._v(" "),s("li",[s("p",[a._v("除了Vector，Hashtable等重量级的同步容器，也可以使用Collections工具类下的Collections.synchronizedXX类，比如Collections.synchronizedList等，它们里面对所有的集合方法都进行了一层封装，即都使用synchronized进行修饰以实现同步。")])]),a._v(" "),s("li",[s("p",[a._v("如果你要使用线程安全的集合的话， "),s("strong",[a._v("java.util.concurrent")]),a._v(" 包中提供了很多并发容器供你使用：")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("ConcurrentHashMap: 可以看作是线程安全的 HashMap")])]),a._v(" "),s("li",[s("p",[a._v("CopyOnWriteArrayList:可以看作是线程安全的 ArrayList，在读多写少的场合性能非常好，远远好于 Vector.")])]),a._v(" "),s("li",[s("p",[a._v("ConcurrentLinkedQueue:高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，"),s("strong",[a._v("这是一个非阻塞队列。")])])]),a._v(" "),s("li",[s("p",[a._v("BlockingQueue: 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。"),s("strong",[a._v("表示阻塞队列，非常适合用于作为数据共享的通道，使用ReentrantLock的await和signal等机制实现阻塞等待。")])])]),a._v(" "),s("li",[s("p",[a._v("ConcurrentSkipListMap :跳表的实现。这是一个Map，使用跳表的数据结构进行快速查找。")])])])])]),a._v(" "),s("h2",{attrs:{id:"什么是快速失败"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是快速失败"}},[a._v("#")]),a._v(" 什么是快速失败？")]),a._v(" "),s("ol",[s("li",[a._v("ArrayList的父类AbstarctList中有一个域"),s("strong",[a._v("modCount")]),a._v("，每次对集合进行修改（增添元素，删除元素……）时都会modCount++。")]),a._v(" "),s("li",[a._v("而foreach的背后实现原理其实就是Iterator（关于Iterator可以看"),s("a",{attrs:{href:"https://link.jianshu.com?t=http://www.programcreek.com/2013/02/java-design-pattern-iterator/",target:"_blank",rel:"noopener noreferrer"}},[a._v("Java Design Pattern: Iterator"),s("OutboundLink")],1),a._v("），等同于注释部分代码。在这里，"),s("strong",[a._v("迭代ArrayList的Iterator中有一个变量expectedModCount，该变量会初始化和modCount相等，但如果接下来如果集合进行修改modCount改变，就会造成expectedModCount!=modCount")]),a._v("，此时就会抛出java.util.ConcurrentModificationException异常。")])]),a._v(" "),s("h2",{attrs:{id:"如何在遍历过程中修改容器-但保证不会抛出concurrentmodificationexception"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何在遍历过程中修改容器-但保证不会抛出concurrentmodificationexception"}},[a._v("#")]),a._v(" 如何在遍历过程中修改容器，但保证不会抛出ConcurrentModificationException？")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("在单线程环境下，直接使用list的remove方法会导致modcount变量的自增，但是，使用迭代器的remove方法虽然也是调用list的remove方法，因此也会导致modcount的自增，但是它会将expectedmodcount的值赋值为modcount的值，因此不会导致并发修改的异常的抛出。")])]),a._v(" "),s("li",[s("p",[a._v("在多线程环境下，可以借助一些并发容器，如CopyOnWriteList来实现容器的并发修改，这也可以实现遍历过程中修改容器的目的。")])]),a._v(" "),s("li",[s("p",[a._v("此外，在多线程环境下，可以使用加锁的方法实现线程安全，它可以防止一个线程修改容器结构，而另一个线程在遍历容器的情况。但是无法达到迭代情况下的add等问题。")])])]),a._v(" "),s("h2",{attrs:{id:"为什么有快速失败这种机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么有快速失败这种机制"}},[a._v("#")]),a._v(" 为什么有快速失败这种机制？")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("ArrayList使用fail-fast机制自然是因为它增强了"),s("strong",[a._v("数据的安全性")]),a._v("，当多个线程同时对一个对象进行高频率的增删改查时，可能会出现"),s("strong",[a._v("数据异常")]),a._v("。")])]),a._v(" "),s("li",[s("p",[a._v("迭代器的fail-fast行为是不一定能够得到保证的。一般来说，存在非同步的并发修改时，是不能够保证错误一定被抛出的。但是会做出最大的努力来抛出ConcurrentModificationException。")])])]),a._v(" "),s("h2",{attrs:{id:"比如arraylist和linkedlist的区别-优劣势比较"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#比如arraylist和linkedlist的区别-优劣势比较"}},[a._v("#")]),a._v(" 比如ArrayList和LinkedList的区别，优劣势比较？")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("ArrayList和LinkedList都实现了List接口，但是它们的底层数据结构是不同的，ArrayList底层是数组实现的，而LinkedList是通过双向链表来实现的。")])]),a._v(" "),s("li",[s("p",[a._v("说到底层的数据结构，这也是它们两者的不同之处的来源。通过数组来实现，十分有利于随机的读取，但是不利于插入等操作。对于使用双向链表的实现方式，比较有利于数据的插入和删除，但是不利于数据的随机查询。")])])])])}),[],!1,null,null,null);t.default=n.exports}}]);