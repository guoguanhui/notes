(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{638:function(_,v,t){"use strict";t.r(v);var e=t(14),s=Object(e.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"数据库"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据库"}},[_._v("#")]),_._v(" 数据库")]),_._v(" "),t("p",[_._v("有16个数据库，默认选择第一个数据库（编号为0）进行数据读写。")]),_._v(" "),t("p",[_._v("切换数据库："),t("code",[_._v("select n")])]),_._v(" "),t("p",[_._v("Redis是一个键值对（key-value pair）数据库服务器，服务器中的每个数据库都由一个redis.h/redisDb结构表示，其中，"),t("strong",[_._v("redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间（key space）")]),_._v("：")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203282200349.png",alt:"img"}})]),_._v(" "),t("h3",{attrs:{id:"数据库键的删除策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据库键的删除策略"}},[_._v("#")]),_._v(" 数据库键的删除策略")]),_._v(" "),t("p",[t("strong",[_._v("Redis服务器实际使用的是惰性删除和定期删除两种策略")]),_._v("：通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡。")]),_._v(" "),t("h4",{attrs:{id:"定时删除-主动删除策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定时删除-主动删除策略"}},[_._v("#")]),_._v(" 定时删除（主动删除策略）")]),_._v(" "),t("p",[_._v("在设置键的过期时间的同时，"),t("strong",[_._v("创建一个定时器")]),_._v("（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。")]),_._v(" "),t("p",[_._v("优点：定时删除策略"),t("strong",[_._v("对内存是最友好的")]),_._v("：通过使用定时器，定时删除策略可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存。")]),_._v(" "),t("p",[_._v("缺点：")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("它对CPU时间是最不友好的："),t("strong",[_._v("在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间")]),_._v("，在内存不紧张但是CPU时间非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。")])]),_._v(" "),t("li",[t("p",[_._v("除此之外，"),t("strong",[_._v("创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表")]),_._v("，查找一个事件的时间复杂度为O（N）——并不能高效地处理大量时间事件。")])])]),_._v(" "),t("h4",{attrs:{id:"惰性删除-被动删除策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#惰性删除-被动删除策略"}},[_._v("#")]),_._v(" 惰性删除（被动删除策略）")]),_._v(" "),t("p",[_._v("放任键过期不管，但是"),t("strong",[_._v("每次从键空间中获取键时，都检查取得的键是否过期")]),_._v("，如果过期的话，就删除该键；如果没有过期，就返回该键。")]),_._v(" "),t("p",[_._v("优点：惰性删除策略对CPU时间来说是最友好的：程序只会在取出键时才对键进行过期检查，这可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何CPU时间。")]),_._v(" "),t("p",[_._v("缺点：")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("它"),t("strong",[_._v("对内存是最不友好")]),_._v("的：如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放。")])]),_._v(" "),t("li",[t("p",[_._v("在使用惰性删除策略时，如果数据库中有非常多的过期键，而这些过期键又恰好没有被访问到的话，那么它们也许永远也不会被删除（除非用户手动执行FLUSHDB），我们甚至可以将这种情况看作是一种"),t("strong",[_._v("内存泄漏")]),_._v("——无用的垃圾数据占用了大量的内存，而服务器却不会自己去释放它们，这对于运行状态非常依赖于内存的Redis服务器来说，肯定不是一个好消息。")])])]),_._v(" "),t("h4",{attrs:{id:"定期删除-主动删除策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定期删除-主动删除策略"}},[_._v("#")]),_._v(" 定期删除（主动删除策略）")]),_._v(" "),t("p",[t("strong",[_._v("每隔一段时间")]),_._v("，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。")]),_._v(" "),t("p",[_._v("优点：定期删除策略是前两种策略的一种整合和折中。")]),_._v(" "),t("p",[_._v("难点：如何确定删除操作执行的时长和执行频率，操作太少或者太频繁都不是合适的。")]),_._v(" "),t("h2",{attrs:{id:"rdb持久化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rdb持久化"}},[_._v("#")]),_._v(" RDB持久化")]),_._v(" "),t("p",[_._v("因为Redis是内存数据库，它将自己的数据库状态储存在内存里面，所以如果不想办法将储存在内存中的数据库状态保存到磁盘里面，那么"),t("strong",[_._v("一旦服务器进程退出，服务器中的数据库状态也会消失不见")]),_._v("。")]),_._v(" "),t("p",[_._v("为了解决这个问题，Redis提供了RDB持久化功能，这个功能可以将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失。")]),_._v(" "),t("p",[t("strong",[_._v("RDB持久化既可以手动执行，也可以根据服务器配置选项定期执行")]),_._v("，该功能可以将某个时间点上的数据库状态保存到一个RDB文件中。该文件是一个经过压缩的"),t("strong",[_._v("二进制文件，通过该文件可以还原生成RDB文件时的数据库状态")]),_._v("。")]),_._v(" "),t("p",[_._v("因为RDB文件是保存在硬盘里面的，所以即使Redis服务器进程退出，甚至运行Redis服务器的计算机停机，但只要RDB文件仍然存在，Redis服务器就可以用它来还原数据库状态。")]),_._v(" "),t("h3",{attrs:{id:"rdb文件的创建和载入"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rdb文件的创建和载入"}},[_._v("#")]),_._v(" RDB文件的创建和载入")]),_._v(" "),t("p",[_._v("有两个Redis命令可以用于生成RDB文件（dump.rdb文件），一个是SAVE，另一个是BGSAVE。")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求。")])]),_._v(" "),t("li",[t("p",[_._v("BGSAVE命令会"),t("strong",[_._v("派生出一个子进程")]),_._v("，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。")])])]),_._v(" "),t("p",[_._v("RDB文件的载入工作是在服务器启动时自动执行的，所以Redis并没有专门用于载入RDB文件的命令，只要Redis服务器在启动时检测到RDB文件存在，它就会自动载入RDB文件。")]),_._v(" "),t("p",[_._v("另外值得一提的是，因为AOF文件的更新频率通常比RDB文件的更新频率高，所以：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("如果服务器开启了AOF持久化功能，那么服务器会"),t("strong",[_._v("优先使用AOF文件来还原数据库状态")]),_._v("。")])]),_._v(" "),t("li",[t("p",[_._v("只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。")])])]),_._v(" "),t("h3",{attrs:{id:"自动间隔性保存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自动间隔性保存"}},[_._v("#")]),_._v(" 自动间隔性保存")]),_._v(" "),t("p",[_._v("因为BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以Redis允许用户通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令。")]),_._v(" "),t("p",[_._v("Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足的话，就执行BGSAVE命令。")]),_._v(" "),t("p",[t("strong",[_._v("自动保存的条件")])]),_._v(" "),t("ol",[t("li",[t("p",[_._v("服务器正常关闭时 "),t("code",[_._v("./bin/redis-cli shutdown")])])]),_._v(" "),t("li",[t("p",[_._v("key 满足一定条件会进行快照 "),t("code",[_._v("vim redis.conf (搜索 save)")])])])]),_._v(" "),t("p",[_._v("save 60 10000 # 60秒内有10000次修改时会触发自动保存")]),_._v(" "),t("h2",{attrs:{id:"aof持久化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aof持久化"}},[_._v("#")]),_._v(" AOF持久化")]),_._v(" "),t("p",[_._v("除了RDB持久化功能之外，Redis还提供了AOF（Append Only File）持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，"),t("strong",[_._v("AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的")]),_._v("。")]),_._v(" "),t("p",[_._v("被写入AOF文件的所有命令都是以Redis的命令请求协议格式保存的，因为Redis的命令请求协议是纯文本格式。")]),_._v(" "),t("p",[_._v("服务器在启动时，可以通过载入和执行AOF文件中保存的命令来还原服务器关闭之前的数据库状态。")]),_._v(" "),t("h3",{attrs:{id:"aof持久化的实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aof持久化的实现"}},[_._v("#")]),_._v(" AOF持久化的实现")]),_._v(" "),t("p",[_._v("命令追加：当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾。")]),_._v(" "),t("p",[_._v("AOF文件的写入与同步：")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("Redis的服务器进程就是一个事件循环（loop），这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复。")])]),_._v(" "),t("li",[t("p",[_._v("因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲区里面，所以在服务器每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，"),t("strong",[_._v("考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面")]),_._v("。")])]),_._v(" "),t("li",[t("p",[_._v("flushAppendOnlyFile函数的行为由服务器配置的appendfsync选项的值来决定。"),t("strong",[_._v("默认是everysec模式。")])])])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203282200420.png",alt:"img"}})]),_._v(" "),t("h3",{attrs:{id:"aof文件的载入和还原"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aof文件的载入和还原"}},[_._v("#")]),_._v(" AOF文件的载入和还原")]),_._v(" "),t("p",[_._v("因为AOF文件里面包含了重建数据库状态所需的所有写命令，所以"),t("strong",[_._v("服务器只要读入并重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态")]),_._v("。")]),_._v(" "),t("p",[_._v("Redis读取AOF文件并还原数据库状态的详细步骤如下：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("创建一个不带网络连接的"),t("strong",[_._v("伪客户端")]),_._v("（fake client）：因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行AOF文件保存的写命令，伪客户端执行命令的效果和带网络连接的客户端执行命令的效果完全一样。")])]),_._v(" "),t("li",[t("p",[_._v("从AOF文件中分析并读取出一条写命令。")])]),_._v(" "),t("li",[t("p",[_._v("使用伪客户端执行被读出的写命令。")])]),_._v(" "),t("li",[t("p",[_._v("一直执行步骤2和步骤3，直到AOF文件中的所有写命令都被处理完毕为止。")])])]),_._v(" "),t("h3",{attrs:{id:"aof重写"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aof重写"}},[_._v("#")]),_._v(" AOF重写")]),_._v(" "),t("p",[_._v("因为AOF持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器运行时间的流逝，"),t("strong",[_._v("AOF文件中的内容会越来越多，文件的体积也会越来越大")]),_._v("，如果不加以控制的话，体积过大的AOF文件很可能对Redis服务器、甚至整个宿主计算机造成影响，并且AOF文件的体积越大，使用AOF文件来进行数据还原所需的时间就越多。")]),_._v(" "),t("p",[_._v("为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写（rewrite）功能。通过该功能，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，"),t("strong",[_._v("新旧两个AOF文件所保存的数据库状态相同，但新AOF文件不会包含任何浪费空间的冗余命令")]),_._v("，所以新AOF文件的体积通常会比旧AOF文件的体积要小得多。")]),_._v(" "),t("h4",{attrs:{id:"文件重写实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#文件重写实现"}},[_._v("#")]),_._v(" 文件重写实现")]),_._v(" "),t("p",[_._v("虽然Redis将生成新AOF文件替换旧AOF文件的功能命名为“AOF文件重写”，但实际上，"),t("strong",[_._v("AOF文件重写并不需要对现有的AOF文件进行任何读取、分析或者写入操作")]),_._v("，这个功能是通过读取服务器当前的数据库状态来实现的。")]),_._v(" "),t("p",[_._v('如果服务器想要用尽量少的命令来记录list键的状态，那么最简单高效的办法不是去读取和分析现有AOF文件的内容，而是直接从数据库中读取键list的值，然后用一条RPUSH list"C""D""E""F""G"命令来代替保存在AOF文件中的六条命令，这样就可以将保存list键所需的命令从六条减少为一条了。')]),_._v(" "),t("h4",{attrs:{id:"aof后台重写"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aof后台重写"}},[_._v("#")]),_._v(" AOF后台重写")]),_._v(" "),t("p",[_._v("AOF重写程序aof_rewrite函数可以很好地完成创建一个新AOF文件的任务，但是，因为"),t("strong",[_._v("这个函数会进行大量的写入操作，所以调用这个函数的线程将被长时间阻塞")]),_._v("，因为Redis服务器使用单个线程来处理命令请求，所以如果由服务器直接调用aof_rewrite函数的话，那么在重写AOF文件期间，服务期将无法处理客户端发来的命令请求。")]),_._v(" "),t("p",[_._v("很明显，作为一种辅佐性的维护手段，Redis不希望AOF重写造成服务器无法处理请求，所以Redis决定将AOF重写程序放到子进程里执行，这样做可以同时达到两个目的：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("子进程进行AOF重写期间，服务器进程（父进程）可以继续处理命令请求。")])]),_._v(" "),t("li",[t("p",[_._v("子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。")])])]),_._v(" "),t("p",[_._v("不过，"),t("strong",[_._v("使用子进程也有一个问题需要解决，因为子进程在进行AOF重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致")]),_._v("。")]),_._v(" "),t("p",[_._v("为了解决这种数据不一致问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会"),t("strong",[_._v("同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区")]),_._v("。")]),_._v(" "),t("p",[_._v("当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作：")]),_._v(" "),t("ul",[t("li",[t("p",[t("strong",[_._v("将AOF重写缓冲区中的所有内容写入到新AOF文件中")]),_._v("，这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致。")])]),_._v(" "),t("li",[t("p",[_._v("对新的AOF文件进行改名，"),t("strong",[_._v("原子地（atomic）覆盖现有的AOF文件")]),_._v("，完成新旧两个AOF文件的替换。")])])]),_._v(" "),t("h2",{attrs:{id:"主从复制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#主从复制"}},[_._v("#")]),_._v(" 主从复制")]),_._v(" "),t("p",[_._v("在Redis中，用户可以通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制（replicate）另一个服务器，我们称呼被复制的服务器为主服务器（master），而对主服务器进行复制的服务器则被称为从服务器（slave）。")]),_._v(" "),t("h3",{attrs:{id:"同步"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#同步"}},[_._v("#")]),_._v(" 同步")]),_._v(" "),t("p",[_._v("当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器首先需要执行同步操作，也即是，将从服务器的数据库状态更新至主服务器当前所处的数据库状态。")]),_._v(" "),t("p",[_._v("从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成，以下是SYNC命令的执行步骤：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("从服务器向主服务器发送SYNC命令。")])]),_._v(" "),t("li",[t("p",[_._v("收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令。")])]),_._v(" "),t("li",[t("p",[_._v("当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件，将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态。")])]),_._v(" "),t("li",[t("p",[_._v("主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态。")])])]),_._v(" "),t("h3",{attrs:{id:"命令传播"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#命令传播"}},[_._v("#")]),_._v(" 命令传播")]),_._v(" "),t("p",[_._v("在同步操作执行完毕之后，主从服务器两者的数据库将达到一致状态，但这种一致并不是一成不变的，"),t("strong",[_._v("每当主服务器执行客户端发送的写命令时，主服务器的数据库就有可能会被修改，并导致主从服务器状态不再一致")]),_._v("。")]),_._v(" "),t("p",[_._v("为了让主从服务器再次回到一致状态，主服务器需要对从服务器执行命令传播操作："),t("strong",[_._v("主服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态")]),_._v("。")]),_._v(" "),t("h3",{attrs:{id:"旧功能的缺陷"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#旧功能的缺陷"}},[_._v("#")]),_._v(" 旧功能的缺陷")]),_._v(" "),t("p",[_._v("对于初次复制来说，旧版复制功能能够很好地完成任务，但对于"),t("strong",[_._v("断线后重复制")]),_._v("来说，旧版复制功能虽然也能让主从服务器重新回到一致状态，但效率却非常低。")]),_._v(" "),t("p",[_._v("虽然再次发送SYNC命令可以让主从服务器重新回到一致状态，但如果我们仔细研究这个断线重复制过程，就会发现传送RDB文件这一步实际上并不是非做不可的。")]),_._v(" "),t("p",[_._v("从服务器让主服务器生成并向从服务器发送包含键k1至键k10089的RDB文件，但实际上RDB文件包含的键k1至键k10086的数据对于从服务器来说都是不必要的。")]),_._v(" "),t("p",[_._v("而且SYNC是一个耗费资源的操作：")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("主服务器需要执行BGSAVE命令来生成RDB文件，这个生成操作会耗费主服务器大量的CPU、内存和磁盘I/O资源。")])]),_._v(" "),t("li",[t("p",[_._v("主服务器需要将自己生成的RDB文件发送给从服务器，这个发送操作会耗费主从服务器大量的"),t("strong",[_._v("网络资源")]),_._v("（带宽和流量），并对主服务器响应命令请求的时间产生影响。")])]),_._v(" "),t("li",[t("p",[_._v("接收到RDB文件的从服务器需要载入主服务器发来的RDB文件，并且在载入期间，从服务器会因为阻塞而没办法处理命令请求。")])])]),_._v(" "),t("h3",{attrs:{id:"部分重同步的实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#部分重同步的实现"}},[_._v("#")]),_._v(" 部分重同步的实现")]),_._v(" "),t("p",[_._v("为了解决旧版复制功能在处理断线重复制情况时的低效问题，Redis从2.8版本开始，"),t("strong",[_._v("使用PSYNC命令代替SYNC命令来执行复制时的同步操作")]),_._v("。")]),_._v(" "),t("p",[_._v("PSYNC命令具有"),t("strong",[_._v("完整重同步")]),_._v("（full resynchronization）和"),t("strong",[_._v("部分重同步")]),_._v("（partial resynchronization）两种模式：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("其中完整重同步用于处理初次复制情况：完整重同步的执行步骤和SYNC命令的执行步骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步。")])]),_._v(" "),t("li",[t("p",[_._v("而部分重同步则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，"),t("strong",[_._v("如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器")]),_._v("，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。")])])]),_._v(" "),t("h4",{attrs:{id:"复制偏移量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#复制偏移量"}},[_._v("#")]),_._v(" 复制偏移量")]),_._v(" "),t("p",[_._v("执行复制的双方——主服务器和从服务器会分别维护一个复制偏移量：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N。")])]),_._v(" "),t("li",[t("p",[_._v("从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N。")])])]),_._v(" "),t("p",[_._v("假设从服务器A在断线之后就立即重新连接主服务器，并且成功，那么接下来，从服务器将向主服务器发送PSYNC命令，报告从服务器A当前的复制偏移量为10086，那么这时，主服务器应该对从服务器执行完整重同步还是部分重同步呢？如果执行部分重同步的话，主服务器又如何补偿从服务器A在断线期间丢失的那部分数据呢？以上问题的答案都和复制积压缓冲区有关。")]),_._v(" "),t("h4",{attrs:{id:"复制积压缓冲区"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#复制积压缓冲区"}},[_._v("#")]),_._v(" 复制积压缓冲区")]),_._v(" "),t("p",[_._v("复制积压缓冲区是由主服务器维护的一个固定长度（fixed-size）先进先出（FIFO）队列，默认大小为1MB。")]),_._v(" "),t("p",[t("strong",[_._v("当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面")]),_._v("。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203282200367.png",alt:"img"}})]),_._v(" "),t("p",[_._v("因此，主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量。")]),_._v(" "),t("p",[_._v("当从服务器重新连上主服务器时，从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作：")]),_._v(" "),t("ul",[t("li",[t("p",[t("strong",[_._v("如果offset偏移量之后的数据（也即是偏移量offset+1开始的数据）仍然存在于复制积压缓冲区里面，那么主服务器将对从服务器执行部分重同步操作。")])])]),_._v(" "),t("li",[t("p",[_._v("相反，如果offset偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器将对从服务器执行完整重同步操作。")])])]),_._v(" "),t("h4",{attrs:{id:"服务器运行id"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#服务器运行id"}},[_._v("#")]),_._v(" 服务器运行ID")]),_._v(" "),t("p",[_._v("每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID。运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成，例如53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3。")]),_._v(" "),t("p",[_._v("当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传送给从服务器，而从服务器则会将这个运行ID保存起来。")]),_._v(" "),t("p",[_._v("当从服务器断线并重新连上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行ID：")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("如果从服务器保存的运行ID和当前连接的主服务器的运行ID相同，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行"),t("strong",[_._v("部分重同步操作")]),_._v("。")])]),_._v(" "),t("li",[t("p",[_._v("相反地，如果从服务器保存的运行ID和当前连接的主服务器的运行ID并不相同，那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行"),t("strong",[_._v("完整重同步操作")]),_._v("。")])])]),_._v(" "),t("h2",{attrs:{id:"哨兵机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#哨兵机制"}},[_._v("#")]),_._v(" 哨兵机制")]),_._v(" "),t("p",[_._v("Sentinel（哨岗、哨兵）是Redis的**高可用性（high availability）**解决方案：由一个或多个Sentinel实例（instance）组成的Sentinel系统（system）可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203282200488.png",alt:"img"}})]),_._v(" "),t("p",[_._v("当server1的下线时长超过用户设定的下线时长上限时，Sentinel系统就会对server1执行故障转移操作：")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("首先，Sentinel系统会挑选server1属下的其中一个从服务器，并将这个被选中的从服务器升级为新的主服务器。")])]),_._v(" "),t("li",[t("p",[_._v("之后，Sentinel系统会向server1属下的所有从服务器发送新的复制指令，让它们成为新的主服务器的从服务器，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完毕。")])]),_._v(" "),t("li",[t("p",[_._v("另外，Sentinel还会继续监视已下线的server1，并在它重新上线时，将它设置为新的主服务器的从服务器。")])]),_._v(" "),t("li",[t("p",[_._v("之后，如果server1重新上线的话，它将被Sentinel系统降级为server2的从服务器。")])])]),_._v(" "),t("p",[t("strong",[_._v("Sentinel本质上只是一个运行在特殊模式下的Redis服务器。")])]),_._v(" "),t("h3",{attrs:{id:"选举领头哨兵-类似于raft的领导者选举"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#选举领头哨兵-类似于raft的领导者选举"}},[_._v("#")]),_._v(" 选举领头哨兵-类似于RAFT的领导者选举")]),_._v(" "),t("p",[_._v("当一个主服务器被判断为客观下线时，"),t("strong",[_._v("监视这个下线主服务器的各个Sentinel会进行协商，选举出一个领头Sentinel，并由领头Sentinel对下线主服务器执行故障转移操作")]),_._v("。")]),_._v(" "),t("p",[_._v("以下是Redis选举领头Sentinel的规则和方法：")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("所有在线的Sentinel都有被选为领头Sentinel的资格，换句话说，监视同一个主服务器的多个在线Sentinel中的任意一个都有可能成为领头Sentinel。")])]),_._v(" "),t("li",[t("p",[_._v("每次进行领头Sentinel选举之后，不论选举是否成功，所有Sentinel的配置纪元（configuration epoch）的值都会自增一次。配置纪元实际上就是一个计数器，并没有什么特别的。")])]),_._v(" "),t("li",[t("p",[_._v("在一个配置纪元里面，所有Sentinel都有一次将某个Sentinel设置为局部领头Sentinel的机会，并且局部领头一旦设置，在这个配置纪元里面就不能再更改。")])]),_._v(" "),t("li",[t("p",[_._v("每个发现主服务器进入客观下线的Sentinel都会要求其他Sentinel将自己设置为局部领头Sentinel。")])]),_._v(" "),t("li",[t("p",[_._v("当一个Sentinel（源Sentinel）向另一个Sentinel（目标Sentinel）发送SENTINEL is-master-down-by-addr命令，并且命令中的runid参数不是*符号而是源Sentinel的运行ID时，这表示源Sentinel要求目标Sentinel将前者设置为后者的局部领头Sentinel。")])]),_._v(" "),t("li",[t("p",[_._v("Sentinel设置局部领头Sentinel的规则是先到先得：最先向目标Sentinel发送设置要求的源Sentinel将成为目标Sentinel的局部领头Sentinel，而之后接收到的所有设置要求都会被目标Sentinel拒绝。")])]),_._v(" "),t("li",[t("p",[_._v("目标Sentinel在接收到SENTINEL is-master-down-by-addr命令之后，将向源Sentinel返回一条命令回复，回复中的leader_runid参数和leader_epoch参数分别记录了目标Sentinel的局部领头Sentinel的运行ID和配置纪元。")])]),_._v(" "),t("li",[t("p",[_._v("源Sentinel在接收到目标Sentinel返回的命令回复之后，会检查回复中leader_epoch参数的值和自己的配置纪元是否相同，如果相同的话，那么源Sentinel继续取出回复中的leader_runid参数，如果leader_runid参数的值和源Sentinel的运行ID一致，那么表示目标Sentinel将源Sentinel设置成了局部领头Sentinel。")])]),_._v(" "),t("li",[t("p",[_._v("**如果有某个Sentinel被半数以上的Sentinel设置成了局部领头Sentinel，那么这个Sentinel成为领头Sentinel。**举个例子，在一个由10个Sentinel组成的Sentinel系统里面，只要有大于等于10/2+1=6个Sentinel将某个Sentinel设置为局部领头Sentinel，那么被设置的那个Sentinel就会成为领头Sentinel。")])]),_._v(" "),t("li",[t("p",[_._v("因为领头Sentinel的产生需要半数以上Sentinel的支持，并且每个Sentinel在每个配置纪元里面只能设置一次局部领头Sentinel，所以在一个配置纪元里面，只会出现一个领头Sentinel。")])]),_._v(" "),t("li",[t("p",[_._v("如果在给定时限内，没有一个Sentinel被选举为领头Sentinel，那么各个Sentinel将在一段时间之后再次进行选举，直到选出领头Sentinel为止。")])])]),_._v(" "),t("h3",{attrs:{id:"故障转移"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#故障转移"}},[_._v("#")]),_._v(" 故障转移")]),_._v(" "),t("p",[_._v("在选举产生出领头Sentinel之后，领头Sentinel将对已下线的主服务器执行故障转移操作，该操作包含以下三个步骤：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("在已下线主服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器。")])]),_._v(" "),t("li",[t("p",[_._v("让已下线主服务器属下的所有从服务器改为复制新的主服务器。")])]),_._v(" "),t("li",[t("p",[_._v("将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器。")])])]),_._v(" "),t("p",[t("strong",[_._v("选择新的主服务器规则：")])]),_._v(" "),t("ol",[t("li",[t("p",[_._v("领头Sentinel会将已下线主服务器的所有从服务器保存到一个列表里面，然后按照以下规则，一项一项地对列表进行过滤：")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("删除列表中所有处于下线或者断线状态的从服务器，这可以"),t("strong",[_._v("保证列表中剩余的从服务器都是正常在线的")]),_._v("。")])]),_._v(" "),t("li",[t("p",[_._v("删除列表中所有最近五秒内没有回复过领头Sentinel的INFO命令的从服务器，这可以"),t("strong",[_._v("保证列表中剩余的从服务器都是最近成功进行过通信的")]),_._v("。")])]),_._v(" "),t("li",[t("p",[_._v("删除所有与已下线主服务器连接断开超过down-aftermilliseconds_10毫秒的从服务器：down-after-milliseconds选项指定了判断主服务器下线所需的时间，而删除断开时长超过down-aftermilliseconds_10毫秒的从服务器，则可以"),t("strong",[_._v("保证列表中剩余的从服务器都没有过早地与主服务器断开连接")]),_._v("，换句话说，列表中剩余的从服务器保存的数据都是比较新的。")])])])]),_._v(" "),t("li",[t("p",[_._v("之后，领头Sentinel将根据从服务器的优先级，对列表中剩余的从服务器进行排序，并"),t("strong",[_._v("选出其中优先级最高的从服务器")]),_._v("。")])]),_._v(" "),t("li",[t("p",[_._v("如果有多个具有相同最高优先级的从服务器，那么领头Sentinel将按照从服务器的复制偏移量，对具有相同最高优先级的所有从服务器进行排序，并"),t("strong",[_._v("选出其中偏移量最大的从服务器")]),_._v("（复制偏移量最大的从服务器就是保存着最新数据的从服务器）。")])]),_._v(" "),t("li",[t("p",[_._v("最后，如果有多个优先级最高、复制偏移量最大的从服务器，那么领头Sentinel将按照运行ID对这些从服务器进行排序，并选出其中运行ID最小的从服务器。")])])]),_._v(" "),t("h2",{attrs:{id:"redis集群"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis集群"}},[_._v("#")]),_._v(" Redis集群")]),_._v(" "),t("p",[t("strong",[_._v("哨兵模式主要解决了高可用的问题，而集群则实现了可扩展性")]),_._v("。")]),_._v(" "),t("p",[_._v("Redis集群是Redis提供的分布式数据库方案，"),t("strong",[_._v("集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能")]),_._v("。")]),_._v(" "),t("h3",{attrs:{id:"槽指派-分片"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#槽指派-分片"}},[_._v("#")]),_._v(" 槽指派-分片")]),_._v(" "),t("p",[_._v("Redis集群"),t("strong",[_._v("通过分片的方式来保存数据库中的键值对")]),_._v("：集群的整个数据库被分为16384个槽（slot），数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽。")]),_._v(" "),t("p",[_._v("当数据库中的16384个槽都有节点在处理时，集群处于上线状态（ok）；相反地，如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态（fail）。")]),_._v(" "),t("p",[_._v("在对数据库中的16384个槽都进行了指派之后，集群就会进入上线状态，这时客户端就可以向集群中的节点发送数据命令了。")]),_._v(" "),t("p",[_._v("当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己：")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令。")])]),_._v(" "),t("li",[t("p",[_._v("如果键所在的槽并没有指派给当前节点，那么节点会向客户端返回一个MOVED错误，"),t("strong",[_._v("指引客户端转向（redirect）至正确的节点，并再次发送之前想要执行的命令")]),_._v("。")])])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203282200398.png",alt:"img"}})]),_._v(" "),t("h3",{attrs:{id:"复制与故障转移"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#复制与故障转移"}},[_._v("#")]),_._v(" 复制与故障转移")]),_._v(" "),t("p",[_._v("Redis集群中的节点分为主节点（master）和从节点（slave），其中"),t("strong",[_._v("主节点用于处理槽，而从节点则用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求")]),_._v("。")]),_._v(" "),t("p",[_._v("举个例子，对于包含7000、7001、7002、7003四个主节点的集群来说，我们可以将7004、7005两个节点添加到集群里面，并将这两个节点设定为节点7000的从节点，如图17-32所示（图中以双圆形表示主节点，单圆形表示从节点）。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203282200612.png",alt:"img"}})]),_._v(" "),t("h4",{attrs:{id:"故障检测"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#故障检测"}},[_._v("#")]),_._v(" 故障检测")]),_._v(" "),t("p",[_._v("集群中的每个节点都会定期地向集群中的其他节点发送PING消息，以此来检测对方是否在线，如果接收PING消息的节点没有在规定的时间内，向发送PING消息的节点返回PONG消息，那么发送PING消息的节点就会将接收PING消息的节点标记为"),t("strong",[_._v("疑似下线")]),_._v("（probable fail，PFAIL）。")]),_._v(" "),t("p",[_._v("集群中的各个节点会通过互相发送消息的方式来交换集群中各个节点的状态信息，例如某个节点是处于在线状态、疑似下线状态（PFAIL），还是已下线状态（FAIL）。")]),_._v(" "),t("p",[_._v("如果在一个集群里面，"),t("strong",[_._v("半数以上负责处理槽的主节点都将某个主节点x报告为疑似下线，那么这个主节点x将被标记为已下线（FAIL）")]),_._v("，将主节点x标记为已下线的节点会向集群广播一条关于主节点x的FAIL消息，所有收到这条FAIL消息的节点都会立即将主节点x标记为已下线。")]),_._v(" "),t("h4",{attrs:{id:"故障转移-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#故障转移-2"}},[_._v("#")]),_._v(" 故障转移")]),_._v(" "),t("p",[_._v("当一个从节点发现自己正在复制的主节点进入了已下线状态时，从节点将开始对下线主节点进行故障转移，以下是故障转移的执行步骤：")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("复制下线主节点的所有从节点里面，会有一个从节点被选中。")])]),_._v(" "),t("li",[t("p",[_._v("被选中的从节点会执行SLAVEOF no one命令，成为新的主节点。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己")]),_._v("。")])]),_._v(" "),t("li",[t("p",[_._v("新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。")])]),_._v(" "),t("li",[t("p",[_._v("新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。")])])]),_._v(" "),t("h4",{attrs:{id:"选举新的主节点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#选举新的主节点"}},[_._v("#")]),_._v(" 选举新的主节点")]),_._v(" "),t("p",[t("strong",[_._v("注：这个选举新主节点的方法和前面介绍的选举领头Sentinel的方法非常相似，因为两者都是基于Raft算法的领头选举（leader election）方法来实现的。")])]),_._v(" "),t("ol",[t("li",[t("p",[_._v("集群的配置纪元是一个自增计数器，它的初始值为0。")])]),_._v(" "),t("li",[t("p",[_._v("当集群里的某个节点开始一次故障转移操作时，集群配置纪元的值会被增一。")])]),_._v(" "),t("li",[t("p",[_._v("对于每个配置纪元，"),t("strong",[_._v("集群里每个负责处理槽的主节点都有一次投票的机会")]),_._v("，而第一个向主节点要求投票的从节点将获得主节点的投票。")])]),_._v(" "),t("li",[t("p",[_._v("当从节点发现自己正在复制的主节点进入已下线状态时，从节点会向集群广播一条CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息，要求所有收到这条消息、并且"),t("strong",[_._v("具有投票权的主节点向这个从节点投票")]),_._v("。")])]),_._v(" "),t("li",[t("p",[_._v("如果一个主节点具有投票权（它正在负责处理槽），并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，表示这个主节点支持从节点成为新的主节点。")])]),_._v(" "),t("li",[t("p",[_._v("每个参与选举的从节点都会接收CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，并根据自己收到了多少条这种消息来统计自己获得了多少主节点的支持。")])]),_._v(" "),t("li",[t("p",[_._v("如果集群里有N个具有投票权的主节点，那么当一个从节点收集到"),t("strong",[_._v("大于等于N/2+1张支持票")]),_._v("时，这个从节点就会当选为新的主节点。")])]),_._v(" "),t("li",[t("p",[_._v("因为在每一个配置纪元里面，每个具有投票权的主节点只能投一次票，所以如果有N个主节点进行投票，那么具有大于等于N/2+1张支持票的从节点只会有一个，这确保了新的主节点只会有一个。")])]),_._v(" "),t("li",[t("p",[_._v("如果在一个配置纪元里面没有从节点能收集到足够多的支持票，那么集群进入一个新的配置纪元，并再次进行选举，直到选出新的主节点为止。")])])]),_._v(" "),t("h2",{attrs:{id:"发布与订阅"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发布与订阅"}},[_._v("#")]),_._v(" 发布与订阅")]),_._v(" "),t("p",[_._v("Redis的发布与订阅功能由PUBLISH、SUBSCRIBE、PSUBSCRIBE等命令组成。")]),_._v(" "),t("p",[_._v("通过执行SUBSCRIBE命令，客户端可以订阅一个或多个"),t("strong",[_._v("频道")]),_._v("，从而成为这些频道的订阅者（subscriber）："),t("strong",[_._v("每当有其他客户端向被订阅的频道发送消息（message）时，频道的所有订阅者都会收到这条消息。")])]),_._v(" "),t("p",[_._v("除了订阅频道之外，客户端还可以通过执行PSUBSCRIBE命令订阅一个或多个"),t("strong",[_._v("模式")]),_._v("，从而成为这些模式的订阅者：每当有其他客户端向某个频道发送消息时，消息不仅会被发送给这个频道的所有订阅者，它还会被发送给所有与这个频道相匹配的模式的订阅者。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203282200024.png",alt:"img"}})]),_._v(" "),t("h3",{attrs:{id:"频道的订阅与退订"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#频道的订阅与退订"}},[_._v("#")]),_._v(" 频道的订阅与退订")]),_._v(" "),t("p",[_._v("Redis将所有频道的订阅关系都保存在服务器状态的pubsub_channels字典里面，"),t("strong",[_._v("这个字典的键是某个被订阅的频道，而键的值则是一个链表，链表里面记录了所有订阅这个频道的客户端")]),_._v("。")]),_._v(" "),t("p",[_._v("UNSUBSCRIBE命令的行为和SUBSCRIBE命令的行为正好相反，当一个客户端退订某个或某些频道的时候，服务器将从pubsub_channels中解除客户端与被退订频道之间的关联。")]),_._v(" "),t("h3",{attrs:{id:"模式的订阅与退订"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模式的订阅与退订"}},[_._v("#")]),_._v(" 模式的订阅与退订")]),_._v(" "),t("p",[_._v("前面说过，服务器将所有频道的订阅关系都保存在服务器状态的pubsub_channels属性里面，与此类似，服务器也将所有模式的订阅关系都保存在服务器状态的pubsub_patterns属性里面。")]),_._v(" "),t("p",[_._v("pubsub_patterns属性是一个链表，链表中的每个节点都包含着一个pubsub Pattern结构，这个结构的pattern属性记录了被订阅的模式，而client属性则记录了订阅模式的客户端。")]),_._v(" "),t("p",[_._v("模式的退订命令PUNSUBSCRIBE是PSUBSCRIBE命令的反操作：当一个客户端退订某个或某些模式的时候，服务器将在pubsub_patterns链表中查找并删除那些pattern属性为被退订模式，并且client属性为执行退订命令的客户端的pubsubPattern结构。")]),_._v(" "),t("h3",{attrs:{id:"发送消息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发送消息"}},[_._v("#")]),_._v(" 发送消息")]),_._v(" "),t("p",[_._v("当一个Redis客户端执行PUBLISH<channel><message>命令将消息message发送给频道channel的时候，服务器需要执行以下两个动作：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("将消息message发送给channel频道的所有订阅者。")])]),_._v(" "),t("li",[t("p",[_._v("如果有一个或多个模式pattern与频道channel相匹配，那么将消息message发送给pattern模式的订阅者。")])])]),_._v(" "),t("h2",{attrs:{id:"事务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事务"}},[_._v("#")]),_._v(" 事务")]),_._v(" "),t("p",[_._v("Redis通过MULTI、EXEC、WATCH等命令来实现事务（transaction）功能。事务提供了一种"),t("strong",[_._v("将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求")]),_._v("。")]),_._v(" "),t("p",[_._v("事务首先以一个MULTI命令为开始，接着将多个命令放入事务当中，最后由EXEC命令将这个事务提交（commit）给服务器执行。")]),_._v(" "),t("p",[_._v("一个事务从开始到结束通常会经历以下三个阶段：")]),_._v(" "),t("p",[_._v("1）事务开始。")]),_._v(" "),t("p",[_._v("2）命令入队。")]),_._v(" "),t("p",[_._v("3）事务执行。")]),_._v(" "),t("h3",{attrs:{id:"watch命令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#watch命令"}},[_._v("#")]),_._v(" WATCH命令")]),_._v(" "),t("p",[_._v("WATCH命令是一个乐观锁（optimistic locking），它可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复。")]),_._v(" "),t("p",[_._v("所有对数据库进行修改的命令，"),t("strong",[_._v("比如SET、LPUSH、SADD、ZREM、DEL、FLUSHDB等等")]),_._v("，在执行之后都会调用multi.c/touchWatchKey函数对watched_keys字典进行检查，查看是否有客户端正在监视刚刚被命令修改过的数据库键，如果有的话，那么touchWatchKey函数会将监视被修改键的客户端的REDIS_DIRTY_CAS标识打开，表示该客户端的事务安全性已经被破坏。")]),_._v(" "),t("h3",{attrs:{id:"事务出现错误的处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事务出现错误的处理"}},[_._v("#")]),_._v(" 事务出现错误的处理")]),_._v(" "),t("ol",[t("li",[t("p",[t("strong",[_._v("语法错误（编译器错误）")])]),_._v(" "),t("p",[_._v("在开启事务后，修改k1值为11，k2值为22，但k2语法错误，"),t("strong",[_._v("最终导致事务提交失败，k1、k2保留原值")]),_._v("。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("Redis类型错误（运行时错误）")])]),_._v(" "),t("p",[_._v("在开启事务后，修改k1值为11，k2值为22，但将k2的类型作为List，在运行时检测类型错误，最终导致事务提交失败，"),t("strong",[_._v("此时事务并没有回滚，而是跳过错误命令继续执行， 结果k1值改变、k2保留原值")])])])]),_._v(" "),t("h3",{attrs:{id:"事务的acid性质"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事务的acid性质"}},[_._v("#")]),_._v(" 事务的ACID性质")]),_._v(" "),t("ol",[t("li",[t("p",[t("strong",[_._v("原子性atomicity")])]),_._v(" "),t("p",[_._v("首先通过上文知道 运行期的错误是不会回滚的，很多文章由此说Redis事务违背原子性的；而官方文档认为是遵从原子性的。")]),_._v(" "),t("p",[_._v("Redis官方文档给的理解是，"),t("strong",[_._v("Redis的事务是原子性的：所有的命令，要么全部执行，要么全部不执行")]),_._v("。而不是完全成功。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("一致性consistency")])]),_._v(" "),t("p",[_._v("redis事务可以保证命令失败的情况下得以回滚，数据能恢复到没有执行之前的样子，是保证一致性的，除非redis进程意外终结。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("隔离性Isolation")])]),_._v(" "),t("p",[_._v("redis事务是严格遵守隔离性的，原因是redis是单进程单线程模式(v6.0之前），可以保证命令执行过程中不会被其他客户端命令打断。")]),_._v(" "),t("p",[_._v("但是，Redis不像其它结构化数据库有隔离级别这种设计。")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("持久性Durability")])]),_._v(" "),t("p",[t("strong",[_._v("redis事务是不保证持久性的")]),_._v("，这是因为redis持久化策略中不管是RDB还是AOF都是异步执行的，不保证持久性是出于对性能的考虑。")])])])])}),[],!1,null,null,null);v.default=s.exports}}]);