(window.webpackJsonp=window.webpackJsonp||[]).push([[137],{693:function(t,v,_){"use strict";_.r(v);var a=_(14),s=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"死锁概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#死锁概念"}},[t._v("#")]),t._v(" 死锁概念")]),t._v(" "),_("h3",{attrs:{id:"引起死锁的原因"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#引起死锁的原因"}},[t._v("#")]),t._v(" 引起死锁的原因")]),t._v(" "),_("ol",[_("li",[t._v("竞争不可抢占性资源")]),t._v(" "),_("li",[t._v("竞争可消耗资源")]),t._v(" "),_("li",[t._v("进程推进顺序不当")])]),t._v(" "),_("h3",{attrs:{id:"死锁产生的四个条件-有一个条件不成立-则不会产生死锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#死锁产生的四个条件-有一个条件不成立-则不会产生死锁"}},[t._v("#")]),t._v(" 死锁产生的四个条件（有一个条件不成立，则不会产生死锁）")]),t._v(" "),_("ol",[_("li",[t._v("互斥条件：一个资源一次只能被一个进程使用")]),t._v(" "),_("li",[t._v("请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放")]),t._v(" "),_("li",[t._v("不可剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺")]),t._v(" "),_("li",[t._v("循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系")])]),t._v(" "),_("h2",{attrs:{id:"处理死锁的方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#处理死锁的方法"}},[t._v("#")]),t._v(" 处理死锁的方法")]),t._v(" "),_("h3",{attrs:{id:"预防死锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#预防死锁"}},[t._v("#")]),t._v(" 预防死锁")]),t._v(" "),_("p",[t._v("破坏四个条件之一")]),t._v(" "),_("ol",[_("li",[t._v("破坏不可抢占性：进程已经占有的资源被短暂地释放")]),t._v(" "),_("li",[t._v("破坏请求和保持条件：一个进程在请求资源时，不能持有不可抢占性资源。")]),t._v(" "),_("li",[t._v("破坏循环等待条件：对系统的所有资源进行线性排序，并且赋予不同的序号。规定每个进程必须按照序号递增的顺序请求资源。"),_("strong",[t._v("每个线程以相同的顺序申请自己想要的资源。")])])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203281129613.png",alt:"img"}})]),t._v(" "),_("h3",{attrs:{id:"避免死锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#避免死锁"}},[t._v("#")]),t._v(" 避免死锁")]),t._v(" "),_("p",[t._v("在资源动态分配的过程中，防止系统进入不安全状态。银行家算法")]),t._v(" "),_("ul",[_("li",[t._v("安全序列：按照某种进程推进顺序为每个进程分配其所需要的资源，直至满足每个进程对资源的最大需求，使得每个进程都可以顺利地完成。")]),t._v(" "),_("li",[t._v("可利用资源向量：")]),t._v(" "),_("li",[t._v("最大需求矩阵")]),t._v(" "),_("li",[t._v("分配矩阵：已分配的资源数")]),t._v(" "),_("li",[t._v("需求矩阵")]),t._v(" "),_("li",[t._v("请求向量")]),t._v(" "),_("li",[t._v("工作向量：系统可以提供给进程继续运行所需要的资源数目。初始化为Avaliable向量")]),t._v(" "),_("li",[t._v("Finish：系统是否有足够的资源分配给进程")])]),t._v(" "),_("h3",{attrs:{id:"检测死锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#检测死锁"}},[t._v("#")]),t._v(" 检测死锁")]),t._v(" "),_("ol",[_("li",[t._v("保存有关资源的请求和分配信息")]),t._v(" "),_("li",[t._v("提供算法检测是否发生死锁")])]),t._v(" "),_("h3",{attrs:{id:"解除死锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解除死锁"}},[t._v("#")]),t._v(" 解除死锁")]),t._v(" "),_("ol",[_("li",[_("strong",[t._v("抢占资源：从一个或者多个进程中抢占足够数量的资源，分配给死锁进程，解除死锁状态")])]),t._v(" "),_("li",[_("strong",[t._v("终止进程：终止一个或者多个进程，直至打破循环环路，使得系统从死锁状态中解脱出来。")])])])])}),[],!1,null,null,null);v.default=s.exports}}]);