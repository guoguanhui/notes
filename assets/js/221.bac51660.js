(window.webpackJsonp=window.webpackJsonp||[]).push([[221],{776:function(v,_,t){"use strict";t.r(_);var s=t(14),r=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"输入网址到网页显示的过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#输入网址到网页显示的过程"}},[v._v("#")]),v._v(" 输入网址到网页显示的过程？")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("首先浏览器做的第一步工作就是要对 URL 进行解析，从而产生发送给 Web 服务器的请求信息。")])]),v._v(" "),t("li",[t("p",[v._v("对 URL 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来"),t("strong",[v._v("生成 HTTP 请求消息")]),v._v("了。")])]),v._v(" "),t("li",[t("p",[v._v("通过浏览器解析 URL 并生成 HTTP 消息后，需要"),t("strong",[v._v("委托操作系统将消息发送给")]),v._v(" "),t("strong",[v._v("Web")]),v._v(" "),t("strong",[v._v("服务器")]),v._v("。但在发送之前，还有一项工作需要完成，那就是"),t("strong",[v._v("查询服务器域名对应的 IP 地址")]),v._v("，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。所以，有一种服务器就专门保存了 Web 服务器域名与 IP 的对应关系，它就是 DNS 服务器。")])]),v._v(" "),t("li",[t("p",[v._v("HTTP 是基于 TCP 协议传输的，所以客户机需要和目标服务器建立TCP连接，这里要经过三次握手的过程。")])]),v._v(" "),t("li",[t("p",[v._v("经过TCP三次握手后，双方即可开始通信了，在这个过程中会依次经过协议栈的传输层，网络层，数据链路层，并在每次加上相应的报文头。")])]),v._v(" "),t("li",[t("p",[v._v("网卡驱动从 IP 模块获取到包之后，会将其"),t("strong",[v._v("复制")]),v._v("到网卡内的缓存区中，接着会其"),t("strong",[v._v("开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列")]),v._v("。最后网卡会将包转为电信号，通过网线发送出去。")])]),v._v(" "),t("li",[t("p",[v._v("数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来。接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。于是，扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP头部里面还有端口号， HTTP 的服务器正在监听这个端口号。如是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。")])]),v._v(" "),t("li",[t("p",[v._v("服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就"),t("strong",[v._v("把这个网页封装在 HTTP 响应报文里")]),v._v("。HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址。")])]),v._v(" "),t("li",[t("p",[v._v("客户端收到了服务器的响应数据包后，同样也非常的高兴，客户能拆快递了！于是，客户端开始扒皮，"),t("strong",[v._v("把收到的数据包的皮扒剩 HTTP 响应报文后，交给浏览器去渲染页面")]),v._v("，一份特别的数据包快递，就这样显示出来了！")])]),v._v(" "),t("li",[t("p",[v._v("最后，客户端要离开了，向服务器发起了 TCP 四次挥手，至此双方的连接就断开了。")])])]),v._v(" "),t("h2",{attrs:{id:"http协议和https协议的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http协议和https协议的区别"}},[v._v("#")]),v._v(" HTTP协议和HTTPS协议的区别？")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("http协议是超文本传输协议，它的信息是明文传输的，存在安全风险。http在安全上存在三个风险，分别是：窃听风险（通信链路上可以获取通信内容）；篡改风险（通信内容被篡改，或者强制植入广告）；冒充风险（冒充淘宝网站等）。")])]),v._v(" "),t("li",[t("p",[v._v("https是基于http协议，但是它在http协议之上套了一层SSL/TLS协议，可以保证加密传输。")])]),v._v(" "),t("li",[t("p",[v._v("HTTP的建立相对简单，需要先建立TCP三次握手建立连接，而HTTPs除了TCP的三次握手，还需要进行SSL的四次握手（1.2是六次握手，1.3是三次握手）来协商一些加密相关的参数。")])]),v._v(" "),t("li",[t("p",[v._v("HTTP的端口号为80，HTTPS的端口号为443。")])]),v._v(" "),t("li",[t("p",[v._v("为了验证通信双方的身份，需要验证服务器的ca身份，这需要一些额外的费用。")])]),v._v(" "),t("li",[t("p",[v._v("由于HTTPS是建立在SSL/TLS之上的HTTP协议，所以会影响连接速度和消耗一些额外的资源。")])])]),v._v(" "),t("h2",{attrs:{id:"https的tls握手过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#https的tls握手过程"}},[v._v("#")]),v._v(" HTTPS的TLS握手过程？")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203212024746.png",alt:"img"}})]),v._v(" "),t("ol",[t("li",[t("p",[v._v("传统的TLS握手过程通过都是使用RSA来实现密钥交换的，在将TLS证书部署到服务端时，证书文件中包含公私钥对，其中公钥会在TLS握手过程中传递给客户端，而私钥则一直留在服务端。在握手过程中，客户端也会生成随机密钥，并且使用服务端的公钥加密后再传给服务端，使用此密钥可对信息进行对称加密。")])]),v._v(" "),t("li",[t("p",[v._v("TLS中有四次握手，分别是：")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("第一次握手")]),v._v("：客户端会发送一个【"),t("strong",[v._v("Client Hello")]),v._v("】消息，这是跟服务端打招呼，这个消息中含有客户端使用的TLS版本号，支持的密码套件列表以及生成的[【**Client Random】**随机数，这个随机数适用于生成对称密钥的材料之一。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("第二次握手")]),v._v("：服务端收到客户端的Client Hello后，会确定TLS版本是否支持，并从密码套件列表中选择一个密码套件，以及生成【**Server Random】**随机数。接着，服务端将返回【"),t("strong",[v._v("Server Hello")]),v._v("】消息，里面带有上述生成或选择的内容。其实，除了Server Hello消息，服务端为了证明自己的身份，会发送【"),t("strong",[v._v("Server Certificate")]),v._v("】消息给客户端，这个消息里有服务端的数字证书。最后，服务端会发送【"),t("strong",[v._v("Server Hello Done")]),v._v("】消息，目的是告诉服务端已经将所有该发送的前置内容发送给客户端了。")])]),v._v(" "),t("li",[t("p",[v._v("客户端拿到服务端的证书后，会对数字证书进行校验，以验证证书身份的真实有效性。首先来说一下证书的签名和校验过程：CA首先会将服务端的公钥，用途颁发者等信息打包，然后对这些信息进行hash计算得到一个hash值，接着CA会使用自己的私钥将对hash值签名，并将其添加在文件证书上形成了最终的数字证书。客户端的校验过程是个逆过程，即：首先客户端会使用同样的hash算法获取该证书的hash值，并且使用浏览器或者操作系统集成的CA的公钥信息对签名进行校验得到另一个hash值，最后会对这两个hash值进行比较，如果相同则说明这个证书是可信赖的。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("第三次握手")]),v._v("：客户端验证完证书后，会生成一个随机数【"),t("strong",[v._v("Pre-master")]),v._v("】，并且使用服务端的公钥加密该随机数，然后发送【"),t("strong",[v._v("Change Cipher Key Exchange")]),v._v("】消息给服务端。服务端会使用自己的私钥对这个消息进行解密，得到客户端发来的随机数。至此，客户端和服务端都共享了三个随机数，分别是【Client Random】，【Server Random】和【Pre-master】，双方可以根据这三个随机数生成会话密钥，这是一个对称密钥，用于后续对HTTP数据进行加解密。生成会话密钥后，客户端会发送一个【"),t("strong",[v._v("Change Cipher Spec")]),v._v("】的消息用于告诉服务端开始使用加密方式发送消息。然后，客户端再发送一个【"),t("strong",[v._v("Encrypted Handshake Message(finished)")]),v._v("】消息把之前所有发送的数据做个摘要，再使用会话密钥加密后让服务器验证加密通信是否可用以及判断之前的握手信息是否被篡改。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("第四次握手")]),v._v("：服务端也是同样的操作，会发送【"),t("strong",[v._v("Change Cipher Spec")]),v._v("】以及【"),t("strong",[v._v("Encrypted Handshake Message(finished)")]),v._v("】消息用于验证双方加密解密都没有问题，至此所有的握手正式完成。")])])])]),v._v(" "),t("li",[t("p",[v._v("这种RSA密钥协商算法的最大问题是不具备"),t("strong",[v._v("前向加密")]),v._v("，所谓的前向加密是指，这种算法是由客户端传递随机数，服务端收到后使用私钥解密得到随机数，这样做的话，一旦服务端的私钥泄露了，那么所有TLS通讯密文都会被破解。")])]),v._v(" "),t("li",[t("p",[v._v("为了解决这个问题，就出了Diffie-Hellman密钥交换算法，这是一种基于离散对数问题的密钥交换算法，但是这种算法计算性能不佳，需要做大量的乘法，为了提升西能，就出现了ECDHE算法，即基于椭圆曲线的Diffie-Hellman密钥交换算法。基于这种算法的TLS也需要四次握手，它需要确定椭圆曲线，基点G等基础的算法参数信息，通过客户端和服务端分别随机生成私钥，并通过G分别生成公钥，最后交换各自的公钥即可。")])])]),v._v(" "),t("h2",{attrs:{id:"https是如何改进引入证书带来性能损耗的问题的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#https是如何改进引入证书带来性能损耗的问题的"}},[v._v("#")]),v._v(" HTTPS是如何改进引入证书带来性能损耗的问题的？")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203212022191.png",alt:"img"}})]),v._v(" "),t("h3",{attrs:{id:"tls-升级"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tls-升级"}},[v._v("#")]),v._v(" TLS 升级")]),v._v(" "),t("p",[v._v("当然，如果可以，直接把 TLS 1.2 升级成 TLS 1.3，TLS 1.3 大幅度简化了握手的步骤，"),t("strong",[v._v("完成 TLS 握手只要 1 RTT")]),v._v("，而且安全性更高。")]),v._v(" "),t("p",[v._v("在 TLS 1.2 的握手中，一般是需要 4 次握手，先要通过 Client Hello （第 1 次握手）和 Server Hello（第 2 次握手） 消息协商出后续使用的加密算法，再互相交换公钥（第 3 和 第 4 次握手），然后计算出最终的会话密钥，下图的左边部分就是 TLS 1.2 的握手过程：")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203212024406.png",alt:"img"}})]),v._v(" "),t("p",[v._v("上图的右边部分就是 TLS 1.3 的握手过程，可以发现 "),t("strong",[v._v("TLS 1.3 把 Hello 和公钥交换这两个消息合并成了一个消息，于是这样就减少到只需 1 RTT 就能完成 TLS 握手")]),v._v("。")]),v._v(" "),t("p",[v._v("怎么合并的呢？具体的做法是，客户端在 Client Hello 消息里带上了支持的椭圆曲线，以及这些"),t("strong",[v._v("椭圆曲线对应的公钥")]),v._v("。")]),v._v(" "),t("p",[v._v("服务端收到后，选定一个椭圆曲线等参数，然后返回消息时，带上服务端这边的公钥。经过这 1 个 RTT，双方手上已经有生成"),t("strong",[v._v("会话密钥")]),v._v("的材料了，于是客户端计算出会话密钥，就可以进行应用数据的加密传输了。")]),v._v(" "),t("p",[v._v("而且，TLS1.3 对密码套件进行“减肥”了， "),t("strong",[v._v("对于密钥交换算法，废除了不支持前向安全性的 RSA 和 DH 算法，只支持 ECDHE 算法")]),v._v("。")]),v._v(" "),t("h3",{attrs:{id:"会话复用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#会话复用"}},[v._v("#")]),v._v(" 会话复用")]),v._v(" "),t("p",[v._v("TLS 握手的目的就是为了协商出会话密钥，也就是对称加密密钥，那我们如果我们"),t("strong",[v._v("把首次 TLS 握手协商的对称加密密钥缓存起来")]),v._v("，待下次需要建立 HTTPS 连接时，直接「复用」这个密钥，不就减少 TLS 握手的性能损耗了吗？")]),v._v(" "),t("p",[v._v("这种方式就是"),t("strong",[v._v("会话复用")]),v._v("（"),t("em",[v._v("TLS session resumption")]),v._v("），会话复用分两种：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("第一种叫 Session ID；")])]),v._v(" "),t("li",[t("p",[v._v("第二种叫 Session Ticket；")])])]),v._v(" "),t("h4",{attrs:{id:"session-id"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#session-id"}},[v._v("#")]),v._v(" Session ID")]),v._v(" "),t("p",[v._v("Session ID 的工作原理是，"),t("strong",[v._v("客户端和服务器首次 TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识")]),v._v("，Session ID 和会话密钥相当于 key-value 的关系。")]),v._v(" "),t("p",[v._v("当客户端再次连接时，hello 消息里会带上 Session ID，服务器收到后就会从内存找，如果找到就直接用该会话密钥恢复会话状态，跳过其余的过程，只用一个消息往返就可以建立安全通信。当然为了安全性，内存中的会话密钥会定期失效。")]),v._v(" "),t("p",[v._v("但是它有两个缺点：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("服务器必须保持每一个客户端的会话密钥，随着客户端的增多，"),t("strong",[v._v("服务器的内存压力也会越大")]),v._v("。")])]),v._v(" "),t("li",[t("p",[v._v("现在网站服务一般是由多台服务器通过负载均衡提供服务的，"),t("strong",[v._v("客户端再次连接不一定会命中上次访问过的服务器")]),v._v("，于是还要走完整的 TLS 握手过程；")])])]),v._v(" "),t("h4",{attrs:{id:"session-ticket"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#session-ticket"}},[v._v("#")]),v._v(" Session Ticket")]),v._v(" "),t("p",[v._v("为了解决 Session ID 的问题，就出现了 Session Ticket，"),t("strong",[v._v("服务器不再缓存每个客户端的会话密钥，而是把缓存的工作交给了客户端")]),v._v("，类似于 HTTP 的 Cookie。")]),v._v(" "),t("p",[v._v("客户端与服务器首次建立连接时，服务器会加密「会话密钥」作为 Ticket 发给客户端，交给客户端缓存该 Ticket。")]),v._v(" "),t("p",[v._v("客户端再次连接服务器时，客户端会发送 Ticket，服务器解密后就可以获取上一次的会话密钥，然后验证有效期，如果没问题，就可以恢复会话了，开始加密通信。")]),v._v(" "),t("h2",{attrs:{id:"http版本的变化对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http版本的变化对比"}},[v._v("#")]),v._v(" HTTP版本的变化对比？")]),v._v(" "),t("h3",{attrs:{id:"http1-1-vs-http1-0"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http1-1-vs-http1-0"}},[v._v("#")]),v._v(" HTTP1.1 VS HTTP1.0")]),v._v(" "),t("ol",[t("li",[t("p",[t("strong",[v._v("长连接")]),v._v("：Http1.1使用长连接的方式改善了Http1.0短连接造成的性能开销。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("管道传输")]),v._v("：Http1.1支持管道网络传输，即只要第一个请求发出去了，可以不必等待其响应就可以发送第二个请求，从而减少了整体的响应时间。")])])]),v._v(" "),t("h3",{attrs:{id:"http2-vs-http1-1"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http2-vs-http1-1"}},[v._v("#")]),v._v(" HTTP2 VS HTTP1.1")]),v._v(" "),t("ol",[t("li",[t("p",[t("strong",[v._v("头部压缩")]),v._v("：考虑到Http1.1中并没有对header进行压缩就发送，导致首部信息越多延迟越大，Http2会在你发送多个请求，如果它们的头是一样的，那么协议将会消除重复的部分。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("二进制格式")]),v._v("，http1.1中的报文是纯文本形式的，Http2中改为二进制格式，将头信息和数据体都设置为二进制的。这样虽然对人不友好，但对计算机友好，可以不需要再次将明文转换为二进制，从而提高了数据的传输的效率。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("多路复用")]),v._v("：Http2中可以在一个连接中并发多个请求或者响应，而不是按照顺序一一对应。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("服务器推送")]),v._v("：Http2中改进了传统的请求-应答模式，服务不再是被动地响应，而是可以主动向客户端推送消息。")])])]),v._v(" "),t("h3",{attrs:{id:"http3-vs-http2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http3-vs-http2"}},[v._v("#")]),v._v(" HTTP3 VS HTTP2")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("Http2的主要问题在于，它使用了多路复用的功能，多个Http请求复用了一个TCP连接，而下层的TCP协议并不知道有多少个Http请求，一旦发生了丢包现象，那么会触发TCP的重传机制，那么在一个TCP中的所有HTTP请求都将等待这个丢失的包被重传回来，进而会阻塞住所有的HTTP请求。")])]),v._v(" "),t("li",[t("p",[v._v("考虑到以上问题都是基于TCP的传输层的可靠性传输机制的问题，所有HTTP3直接"),t("strong",[v._v("将HTTP下层的TCP协议改成了UDP协议")]),v._v("。因为，UDP是不管发送顺序和丢包的，所以不会出现Http2中的问题。")])]),v._v(" "),t("li",[t("p",[v._v("为了解决UDP不可靠传输的问题，Http3使用基于UDP的"),t("strong",[v._v("QUIC")]),v._v("协议实现了类似TCP可靠性传输的问题。QUIC有自己的一套机制来保证传输的可靠性，当某个流丢失时，只会阻塞这个流，其他流不会受到影响。")])])]),v._v(" "),t("h2",{attrs:{id:"get和post请求的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#get和post请求的区别"}},[v._v("#")]),v._v(" GET和POST请求的区别？")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("前者将请求参数放在URL 中，文本格式；后者将请求参数放在请求体（body）中，可以是文本、二进制等格式")])]),v._v(" "),t("li",[t("p",[v._v("前者语义上是从服务器获取资源，安全（无副作用，不会破坏服务器上的资源）、幂等（多次请求相同的操作，结果都是相同的）、可缓存；后者语义上是向服务器提交资源，不安全（有副作用）、不幂等、不可缓存")])]),v._v(" "),t("li",[t("p",[v._v("前者的URL 是明文传输，会保存在浏览器历史记录中，安全性不足，可能会受到CSRF攻击；后者较为安全。")])])]),v._v(" "),t("h2",{attrs:{id:"http状态码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http状态码"}},[v._v("#")]),v._v(" HTTP状态码？")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("200：请求成功。")])]),v._v(" "),t("li",[t("p",[v._v("300：重定向。301-永久移动，302-临时移动，304-未修改。")])]),v._v(" "),t("li",[t("p",[v._v("400：请求错误。401-未授权，403-禁止，404-未找到。")])]),v._v(" "),t("li",[t("p",[v._v("500：服务器错误。501-尚未实施，502-网关错误，503-服务不可用。")])])]),v._v(" "),t("h2",{attrs:{id:"cookie和session的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cookie和session的区别"}},[v._v("#")]),v._v(" Cookie和Session的区别？")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("HTTP协议是一种"),t("strong",[v._v("无状态协议")]),v._v("，也就是说每次服务器接收到客户端的请求时，都是一个全新的请求，服务器并不知道客户端的历史请求记录。Session和Cookie的主要目的就是为了弥补HTTP的无状态特性。")])]),v._v(" "),t("li",[t("p",[v._v("对于Session来说，客户端请求服务端，"),t("strong",[v._v("服务端会为这次请求开辟一块内存空间，这个对象就是Session对象，存储结构为ConcurrentHashMap")]),v._v("。服务器可以利用Session存储客户端在同一会话期间的一些操作。"),t("strong",[v._v("服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户")]),v._v("。这个Session是保存在服务端的，有一个唯一标识。")])]),v._v(" "),t("li",[t("p",[v._v("思考一下服务端如何"),t("strong",[v._v("识别特定的客户")]),v._v("？这个时候Cookie就登场了。"),t("strong",[v._v("它是服务器发送到Web浏览器的一小块数据，浏览器会进行存储，并在每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端")]),v._v("。")])]),v._v(" "),t("li",[t("p",[v._v("实际上大多数的应用都是"),t("strong",[v._v("用 Cookie 来实现Session跟踪的")]),v._v("，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，"),t("strong",[v._v("以后每次请求把这个会话ID发送到服务器，我就知道你是谁了")]),v._v("。")])])]),v._v(" "),t("h2",{attrs:{id:"tcp与udp的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp与udp的区别"}},[v._v("#")]),v._v(" TCP与UDP的区别？")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("连接：TCP是面向连接的传输层协议，传输数据之前先要建立连接。UDP是不需要连接，即刻传输数据。")])]),v._v(" "),t("li",[t("p",[v._v("服务对象：TCP是一对一的端到端连接。UDP支持一对一，一对多和多对多的交互通信。")])]),v._v(" "),t("li",[t("p",[v._v("可靠性：TCP是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。UDP是尽最大努力交付，不保证可靠交付数据。")])]),v._v(" "),t("li",[t("p",[v._v("拥塞控制和流量控制：TCP有拥塞控制和流量控制的机制，保证数据传输的安全性。UDP则没有，即使网络非常拥堵了，也不会影响UDP的发送速率。")])]),v._v(" "),t("li",[t("p",[v._v("首部开销：TCP首部长度较长，在没有使用选项字段时是20字节，如果使用了选项字段则会变长。UDP首部只有8个字节，并且是固定不变的，开销较小。")])]),v._v(" "),t("li",[t("p",[v._v("传输方式：TCP是"),t("strong",[v._v("流式传输")]),v._v("，没有边界，保证顺序和可靠性。UDP是一个包一个包的发送，是没有边界的，但可能丢包和乱序。")])])]),v._v(" "),t("h2",{attrs:{id:"tcp握手为什么是三次"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp握手为什么是三次"}},[v._v("#")]),v._v(" TCP握手为什么是三次？")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("一种比较片面的理由是，"),t("strong",[v._v("只有三次握手才能保证双方都具备接收和发送能力")]),v._v("，但是这种说法没有说出主要原因。换句话说，因为TCP为了保证可靠性和拥塞控制需要维护一些状态信息，诸如Socket，序列号和窗口，所以更严谨的说法是为什么三次握手可以保证初始化"),t("strong",[v._v("Socket，序列号和窗口大小")]),v._v("并成功建立TCP连接。")])]),v._v(" "),t("li",[t("p",[v._v("第一个原因是"),t("strong",[v._v("只有三次握手才可以阻止重复历史连接的初始化")]),v._v("，这是最重要的一个原因。简单来说，三次握手可以防止旧的重复连接初始化造成混乱。网络环境是错综复杂的，往往并不是如我们期望的一样，先发送的数据包，就先到达目标主机，可能会由于网络拥堵等乱七八糟的原因，"),t("strong",[v._v("会使得旧的数据包，先到达目标主机")]),v._v("。当一个旧的同步报文到达服务端时，服务端会发送一个SYN+ACK报文给客户端，客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送RST报文中止这一次连接。")])]),v._v(" "),t("li",[t("p",[v._v("三次握手的第二个原因是同步双方初始序列号。TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它可以用于去除重复数据且根据数据包的序列号按序接收。可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 SYN 报文的时候，需要服务端回一个 ACK 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，**这样一来一回，才能确保双方的初始序列号能被可靠的同步。**其实，四次握手也能够实现可靠的同步双方初始序号，但是第二步和第三步可以优化成一步，所以就成了三次握手。")])]),v._v(" "),t("li",[t("p",[v._v("第三个原因是避免资源浪费，其实这个原因和第一个原因是息息相关的。如果只有「两次握手」，当客户端的 SYN 请求连接在网络中阻塞，客户端没有接收到 ACK 报文，就会重新发送 SYN ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 ACK 确认信号，所以"),t("strong",[v._v("每收到一个")]),v._v(" "),t("strong",[v._v("SYN")]),v._v(" "),t("strong",[v._v("就只能先主动建立一个连接")]),v._v("，这会造成什么情况呢？如果客户端的 SYN 阻塞丢失了，重复发送多次 SYN 报文，那么服务器在收到请求后就会**建立多个冗余的无效链接，造成不必要的资源浪费。**即两次握手会造成消息滞留情况下，服务器重复接受无用的连接请求 SYN 报文，而造成重复分配资源。")])])]),v._v(" "),t("h2",{attrs:{id:"为什么time-wait等待时间是2msl"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么time-wait等待时间是2msl"}},[v._v("#")]),v._v(" 为什么TIME_WAIT等待时间是2MSL？")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("MSL 是 Maximum Segment Lifetime，"),t("strong",[v._v("报文最大生存时间")]),v._v("，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。")])]),v._v(" "),t("li",[t("p",[v._v("TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是：网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以"),t("strong",[v._v("一来一回需要等待 2 倍的时间")]),v._v("。")])])]),v._v(" "),t("h2",{attrs:{id:"tcp的粘包问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp的粘包问题"}},[v._v("#")]),v._v(" TCP的粘包问题？")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("值得注意的是，"),t("strong",[v._v("粘包并不是 TCP 协议本身的“问题”，而是一个“现象”")]),v._v("。TCP 本身面向字节流的特性，导致会有所谓的“粘包”问题，需要应用层进行拆分。所以也有一种说法是“TCP 粘包是一个伪命题”。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("TCP 是基于字节流的，数据块是没有边界、没有结构的字节流")]),v._v("，因此可能产生粘包：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("发送方为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小、数据量小的数据包，合并成一个大的数据包一次性发送。")])]),v._v(" "),t("li",[t("p",[v._v("接收方不能及时读取数据，导致缓冲区中的多个包粘连。")])])])]),v._v(" "),t("li",[t("p",[v._v("解决方案：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("发送方关闭 Nagle 算法")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("应用层定义消息边界")]),v._v("，最常见的两种解决方案就是基于长度或者基于终结符（Delimiter）")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("基于长度的实现有两种方式，一种是使用固定长度；另一种方式是使用不固定长度，但是需要在应用层协议的协议头中增加表示负载长度的字段，HTTP 协议的消息边界就是基于长度实现的")])]),v._v(" "),t("li",[t("p",[v._v("HTTP 协议除了使用基于长度的方式实现边界，也会使用"),t("strong",[v._v("基于终结符的策略")]),v._v("，当 HTTP 使用块传输（Chunked Transfer）机制时，HTTP 头中就不再包含 Content-Length 了，它会使用负载大小为 0 的 HTTP 消息作为终结符表示消息的边界")])])])]),v._v(" "),t("li",[t("p",[v._v("除了这两种方式之外，我们可以基于特定的规则实现消息的边界，例如：使用 TCP 协议发送 JSON 数据，接收方可以根据接收到的数据是否能够被解析成合法的 JSON 判断消息是否终结。")])])])])]),v._v(" "),t("h2",{attrs:{id:"流量控制和拥塞控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#流量控制和拥塞控制"}},[v._v("#")]),v._v(" 流量控制和拥塞控制？")]),v._v(" "),t("ol",[t("li",[t("p",[t("strong",[v._v("流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么")]),v._v("。")])]),v._v(" "),t("li",[t("p",[v._v("一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….")])])]),v._v(" "),t("li",[t("p",[v._v("所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。")])]),v._v(" "),t("li",[t("p",[v._v("于是，就有了"),t("strong",[v._v("拥塞控制")]),v._v("，控制的目的就是"),t("strong",[v._v("避免「发送方」的数据填满整个网络。")])])])]),v._v(" "),t("h2",{attrs:{id:"ipv4和ipv6的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ipv4和ipv6的区别"}},[v._v("#")]),v._v(" IPv4和IPv6的区别？")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("IPv6：基本首部（40字节）+有效载荷（多个扩展首部+数据部分），IPv4：首部（固定部分（20字节）+可变部分）+数据部分")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("IPv6的地址从IPv4的32（8 * 4）位增加到128（16 * 8）位，这样大的地址空间在可预见的未来无法使用完。")])])]),v._v(" "),t("li",[t("p",[v._v("IPv4采用点分十进制方法，IPv6采用冒号十六进制记法。")])]),v._v(" "),t("li",[t("p",[v._v("IPv4的首部是可变的，后者的首部是固定的40字节。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("IPv6允许协议继续扩充，但是IPv4的功能是不变的。")])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("相同点：都具有原地址和目的地址，只不过位数不同，32位和128位")])])])]),v._v(" "),t("h2",{attrs:{id:"路由协议使用的是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#路由协议使用的是什么"}},[v._v("#")]),v._v(" 路由协议使用的是什么？")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("RIP内部网关协议：基于距离向量法。按照固定的时间间隔和相邻的几个路由器交换自己的路由表，经过若干次交换后，所有的路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳的路由器地址。")])]),v._v(" "),t("li",[t("p",[v._v("OSPF内部网关协议：开放最短路径优先。使用洪泛法向自治系统的所有路由器发送消息，包括链路状态。")])])])])}),[],!1,null,null,null);_.default=r.exports}}]);