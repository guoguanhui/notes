(window.webpackJsonp=window.webpackJsonp||[]).push([[205],{762:function(v,a,l){"use strict";l.r(a);var _=l(14),t=Object(_.a)({},(function(){var v=this,a=v.$createElement,l=v._self._c||a;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h2",{attrs:{id:"类加载的过程"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#类加载的过程"}},[v._v("#")]),v._v(" 类加载的过程")]),v._v(" "),l("ol",[l("li",[l("p",[v._v("所谓的类加载指的是，所有的描述类各类信息的class字节码文件需要加载进虚拟机中才能被运行和使用。Java虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以直接背jvm使用的Java类型，这个过程就是所谓的类加载。")])]),v._v(" "),l("li",[l("p",[v._v("加载：加载阶段主要完成了三件事，分别是通过一个类的全限定名来获取定义此类的二进制流；把这个字节流所代表的的静态存储结构转换为方法区的运行时数据；在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。")])]),v._v(" "),l("li",[l("p",[v._v("验证：该步骤的主要作用就是保证被加载类的准确性，换句话说，就是保证Class文件的字节流中包含的信息符合Java虚拟机规范中的全部约束要求。这里主要从四个方面去验证类的准确性，包括文件格式校验，元数据校验，字节码验证，符号引用验证。")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("文件格式校验主要检查字节流是否满足Class文件格式的规范，比如魔数，版本号。需要说明的是这个步骤是唯一需要对字节流进行读取操作的，其他的三个步骤都直接在方法区的存储结构中进行。")])]),v._v(" "),l("li",[l("p",[v._v("元数据验证主要针对字节码中描述的信息进行语义分析，比如判断该类是否有父类，除了Object类外，其他的类都需要有父类；其次，这个类是否继承了不该继承的类等。这个步骤主要对元数据中的数据类型进行校验。")])]),v._v(" "),l("li",[l("p",[v._v("字节码验证：通过数据流分析和控制流分析，确定程序语义是否合法，符合逻辑。这个步骤主要对类的方法体进行校验分析，保证被校验的类不会做出危害虚拟机安全的行为。如，保证任何的跳转指令都不会跳到方法体以外的字节码指令等。")])]),v._v(" "),l("li",[l("p",[v._v("符号引用验证：这个验证步骤发生在虚拟机将符号引用转换为直接引用的时候，这个会在后续的解析阶段中发生。符号引用验证可以确保解析行为可以正常进行，通常会验证符号引用中通过字符串描述的全限定名是否可以找到对应的类等。这个验证阶段有可能会抛出java.lang.NoSuchMethodError等异常。")])])])]),v._v(" "),l("li",[l("p",[v._v("准备：该阶段的主要作用是为类的静态变量分配内存并初始化为默认值。")])]),v._v(" "),l("li",[l("p",[v._v("解析：该阶段主要用于将类中的符号引用转换为直接引用。所谓的符号引用，是一种任意形式的字面量，可以无歧义的定位到目标。符号引用与虚拟机的内存布局无关。而直接引用是可以指向目标的指针，相对偏移量等，它是与内存布局紧密相关的。")])]),v._v(" "),l("li",[l("p",[v._v("初始化：这个阶段主要为类静态变量赋初始值，也就是说执行clinit方法，即所谓的类构造器。这个方法是由编译器收集所有类变量的赋值动作以及静态语句块中的语句组成的。")])])]),v._v(" "),l("h2",{attrs:{id:"类加载模型与双亲委派"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#类加载模型与双亲委派"}},[v._v("#")]),v._v(" 类加载模型与双亲委派")]),v._v(" "),l("ol",[l("li",[l("p",[v._v("类加载器完成的是类加载阶段中的“通过一个类全限定名来获取该类的二进制流”这个动作。")])]),v._v(" "),l("li",[l("p",[v._v("类加载架构主要是三层架构，即启动类加载器、扩展类加载器、应用程序类加载器以及自定义类加载器。启动类加载器是由C++实现的，它是虚拟机的一部分，而其他的类加载器都是由Java语言实现的，是独立于虚拟机外部的。")]),v._v(" "),l("ul",[l("li",[v._v("启动类加载器加载JAVA_HOME/lib目录下的类")]),v._v(" "),l("li",[v._v("扩展类加载器加载JAVA_HOME/lib/ext目录下的类")]),v._v(" "),l("li",[v._v("应用程序类加载器加载classpath路径下指定的类，将其加载到内存中")]),v._v(" "),l("li",[v._v("自定义类加载器，继承自ClassLoader")])])]),v._v(" "),l("li",[l("p",[v._v("所谓的双亲委派模型，其实就是类加载器之间的层次模型，他要求除了启动类加载器，其余的类加载器都需要有自己的父类加载器，这种父子关系通过组合来实现。在加载类的时，首先会将加载任务委托给父类加载器，依次委托，如果父类加载器可以完成类加载，则成功返回，如果不能完成类加载任务，则抛出ClassNotFoundException异常，再自己加载类。")])]),v._v(" "),l("li",[l("p",[v._v("对于双亲委派模型出现的原因，最重要的是"),l("strong",[v._v("防止内存中出现多份同样的字节码")]),v._v("。比如，如果没有双亲委派模型，当用户编写了一个java.lang.Object的同名类并放在类路径下，当多个类加载器都去加载这个类到内存，系统将会出现多个不同的Object类，那么类之间的比较和唯一性将无法比较。")])])])])}),[],!1,null,null,null);a.default=t.exports}}]);