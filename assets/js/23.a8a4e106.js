(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{578:function(a,t,v){"use strict";v.r(t);var r=v(14),_=Object(r.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h2",{attrs:{id:"同步vs异步-阻塞vs非阻塞"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#同步vs异步-阻塞vs非阻塞"}},[a._v("#")]),a._v(" 同步vs异步 / 阻塞vs非阻塞")]),a._v(" "),v("h3",{attrs:{id:"同步vs异步"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#同步vs异步"}},[a._v("#")]),a._v(" 同步vs异步")]),a._v(" "),v("ol",[v("li",[v("p",[v("strong",[a._v("同步：")]),a._v(" 同步就是发起一个调用后，"),v("strong",[a._v("被调用者")]),a._v("未处理完请求之前，调用不返回。")])]),a._v(" "),v("li",[v("p",[v("strong",[a._v("异步：")]),a._v(" 异步就是发起一个调用后，立刻得到"),v("strong",[a._v("被调用者")]),a._v("的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。")])]),a._v(" "),v("li",[v("p",[a._v("同步和异步的区别最大在于，异步的话调用者不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果。")])])]),a._v(" "),v("h3",{attrs:{id:"阻塞vs非阻塞"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#阻塞vs非阻塞"}},[a._v("#")]),a._v(" 阻塞vs非阻塞")]),a._v(" "),v("ol",[v("li",[v("p",[v("strong",[a._v("阻塞：")]),a._v(" 阻塞就是发起一个请求，"),v("strong",[a._v("调用者")]),a._v("一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。")])]),a._v(" "),v("li",[v("p",[v("strong",[a._v("非阻塞：")]),a._v(" 非阻塞就是发起一个请求，"),v("strong",[a._v("调用者")]),a._v("不用一直等着结果返回，可以先去干其他事情。")])])]),a._v(" "),v("h2",{attrs:{id:"unix-i-o模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#unix-i-o模型"}},[a._v("#")]),a._v(" UNIX I/O模型")]),a._v(" "),v("ol",[v("li",[v("p",[a._v("如何去理解 UNIX I/O 模型，大致有以下两个维度：")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("区分同步或异步（synchronous/asynchronous）。简单来说，同步是一种可靠的有序运行机制，当我们进行同步操作时，后续的任务是等待当前调用返回，才会进行下一步；而异步则相反，其他任务不需要等待当前调用返回，通常依靠事件、回调等机制来实现任务间次序关系。")])]),a._v(" "),v("li",[v("p",[a._v("区分阻塞与非阻塞（blocking/non-blocking）。在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如 ServerSocket 新连接建立完毕，或数据读取、写入操作完成；而非阻塞则是不管 IO 操作是否结束，直接返回，相应操作在后台继续处理。")])])])]),a._v(" "),v("li",[v("p",[a._v("不能一概而论认为同步或阻塞就是低效，具体还要看应用和系统特征。")])]),a._v(" "),v("li",[v("p",[a._v("对于一个网络 I/O 通信过程，比如网络数据读取，会涉及两个对象，"),v("strong",[a._v("一个是调用这个 I/O 操作的用户线程，另外一个就是操作系统内核。一个进程的地址空间分为用户空间和内核空间，用户线程不能直接访问内核空间")]),a._v("。")])]),a._v(" "),v("li",[v("p",[a._v("当用户线程发起 I/O 操作后，网络数据读取操作会经历两个步骤：")]),a._v(" "),v("ul",[v("li",[v("p",[v("strong",[a._v("用户线程等待内核将数据从网卡拷贝到内核空间。")])])]),a._v(" "),v("li",[v("p",[v("strong",[a._v("内核将数据从内核空间拷贝到用户空间。")])])])])]),a._v(" "),v("li",[v("p",[a._v("各种 I/O 模型的区别就是：它们实现这两个步骤的方式是不一样的。")])])]),a._v(" "),v("h3",{attrs:{id:"同步阻塞i-o"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#同步阻塞i-o"}},[a._v("#")]),a._v(" 同步阻塞I/O")]),a._v(" "),v("p",[a._v("用户线程发起 read 调用后就阻塞了，让出 CPU。内核等待网卡数据到来，把数据从网卡拷贝到内核空间，接着把数据拷贝到用户空间，再把用户线程叫醒。")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203212216726.png",alt:"image-20220321221635568"}})]),a._v(" "),v("h3",{attrs:{id:"同步非阻塞i-o"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#同步非阻塞i-o"}},[a._v("#")]),a._v(" 同步非阻塞I/O")]),a._v(" "),v("p",[v("strong",[a._v("用户线程不断的发起 read 调用，数据没到内核空间时，每次都返回失败，直到数据到了内核空间")]),a._v("，这一次 read 调用后，在等待数据从内核空间拷贝到用户空间这段时间里，线程还是阻塞的，等数据到了用户空间再把线程叫醒。")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203212205286.png",alt:"img"}})]),a._v(" "),v("h3",{attrs:{id:"i-o多路复用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#i-o多路复用"}},[a._v("#")]),a._v(" I/O多路复用")]),a._v(" "),v("p",[a._v("用户线程的"),v("strong",[a._v("读取操作分成两步了，线程先发起 select 调用，目的是问内核数据准备好了吗？等内核把数据准备好了，用户线程再发起 read 调用")]),a._v("。在等待数据从内核空间拷贝到用户空间这段时间里，线程还是阻塞的。那为什么叫 I/O 多路复用呢？"),v("strong",[a._v("因为一次 select 调用可以向内核查多个数据通道（Channel）的状态，所以叫多路复用")]),a._v("。")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203212205260.png",alt:"img"}})]),a._v(" "),v("h3",{attrs:{id:"信号驱动i-o"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#信号驱动i-o"}},[a._v("#")]),a._v(" 信号驱动I/O")]),a._v(" "),v("p",[a._v("首先开启 Socket 的信号驱动 I/O 功能，并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个 SIGIO 信号，可以在信号处理函数中调用 I/O 操作函数处理数据。"),v("strong",[a._v("信号驱动式 I/O 模型的优点是我们在数据报到达期间进程不会被阻塞，我们只要等待信号处理函数的通知即可")])]),a._v(" "),v("h3",{attrs:{id:"异步i-o"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#异步i-o"}},[a._v("#")]),a._v(" 异步I/O")]),a._v(" "),v("p",[a._v("用户线程"),v("strong",[a._v("发起 read 调用的同时注册一个回调函数，read 立即返回，等内核将数据准备好后，再调用指定的回调函数完成处理")]),a._v("。在这个过程中，用户线程一直没有阻塞。")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203212217131.png",alt:"image-20220321221712017"}})]),a._v(" "),v("h2",{attrs:{id:"java-i-o模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java-i-o模型"}},[a._v("#")]),a._v(" Java I/O模型")]),a._v(" "),v("h3",{attrs:{id:"bio"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#bio"}},[a._v("#")]),a._v(" BIO")]),a._v(" "),v("p",[a._v("BIO（blocking IO） 即阻塞 IO。指的主要是传统的 java.io 包，它基于流模型实现。")]),a._v(" "),v("h4",{attrs:{id:"bio-简介"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#bio-简介"}},[a._v("#")]),a._v(" BIO 简介")]),a._v(" "),v("p",[a._v("java.io 包提供了我们最熟知的一些 IO 功能，比如 File 抽象、输入输出流等。交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。")]),a._v(" "),v("p",[a._v("很多时候，人们也把 java.net 下面提供的部分网络 API，比如 Socket、ServerSocket、HttpURLConnection 也归类到同步阻塞 IO 类库，因为网络通信同样是 IO 行为。")]),a._v(" "),v("p",[a._v("BIO 的优点是代码比较简单、直观；缺点则是 IO 效率和扩展性存在局限性，容易成为应用性能的瓶颈。")]),a._v(" "),v("h4",{attrs:{id:"bio-的性能缺陷"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#bio-的性能缺陷"}},[a._v("#")]),a._v(" BIO 的性能缺陷")]),a._v(" "),v("p",[v("strong",[a._v("BIO 会阻塞进程，不适合高并发场景")]),a._v("。")]),a._v(" "),v("p",[a._v("采用 BIO 的服务端，通常由一个独立的 Acceptor 线程负责监听客户端连接。服务端一般在while(true) 循环中调用 accept() 方法等待客户端的连接请求，一旦接收到一个连接请求，就可以建立 Socket，并基于这个 Socket 进行读写操作。此时，不能再接收其他客户端连接请求，只能等待当前连接的操作执行完成。")]),a._v(" "),v("p",[a._v("如果要让 "),v("strong",[a._v("BIO 通信模型")]),a._v(" 能够同时处理多个客户端请求，就必须使用多线程（主要原因是socket.accept()、socket.read()、socket.write() 涉及的三个主要函数都是同步阻塞的），但会造成不必要的线程开销。不过可以通过 "),v("strong",[a._v("线程池机制")]),a._v(" 改善，线程池还可以让线程的创建和回收成本相对较低。")]),a._v(" "),v("p",[v("strong",[a._v("即使可以用线程池略微优化，但是会消耗宝贵的线程资源，并且在百万级并发场景下也撑不住")]),a._v("。如果并发访问量增加会导致线程数急剧膨胀可能会导致线程堆栈溢出、创建新线程失败等问题，最终导致进程宕机或者僵死，不能对外提供服务。")]),a._v(" "),v("h3",{attrs:{id:"nio"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#nio"}},[a._v("#")]),a._v(" NIO")]),a._v(" "),v("p",[a._v("NIO（non-blocking IO） 即非阻塞 IO。指的是 Java 1.4 中引入的 java.nio 包。")]),a._v(" "),v("p",[a._v("为了解决 BIO 的性能问题， Java 1.4 中引入的 java.nio 包。NIO 优化了内存复制以及阻塞导致的严重性能问题。")]),a._v(" "),v("p",[a._v("java.nio 包提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。")]),a._v(" "),v("p",[a._v("NIO 有哪些性能优化点呢？")]),a._v(" "),v("h4",{attrs:{id:"使用缓冲区优化读写流"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用缓冲区优化读写流"}},[a._v("#")]),a._v(" 使用缓冲区优化读写流")]),a._v(" "),v("p",[a._v("NIO 与传统 I/O 不同，它是基于块（Block）的，它以块为基本单位处理数据。在 NIO 中，最为重要的两个组件是缓冲区（Buffer）和通道（Channel）。")]),a._v(" "),v("p",[a._v("Buffer 是一块连续的内存块，是 NIO 读写数据的缓冲。Buffer 可以将文件一次性读入内存再做后续处理，而传统的方式是边读文件边处理数据。Channel 表示缓冲数据的源头或者目的地，它用于读取缓冲或者写入数据，是访问缓冲的接口。")]),a._v(" "),v("h4",{attrs:{id:"使用-directbuffer-减少内存复制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用-directbuffer-减少内存复制"}},[a._v("#")]),a._v(" 使用 DirectBuffer 减少内存复制")]),a._v(" "),v("p",[a._v("NIO 还提供了一个可以直接访问物理内存的类 DirectBuffer。普通的 Buffer 分配的是 JVM 堆内存，而 DirectBuffer 是直接分配物理内存。")]),a._v(" "),v("p",[v("strong",[a._v("数据要输出到外部设备，必须先从用户空间复制到内核空间，再复制到输出设备，而 DirectBuffer 则是直接将步骤简化为从内核空间复制到外部设备，减少了数据拷贝。")])]),a._v(" "),v("p",[a._v("这里拓展一点，由于 DirectBuffer 申请的是非 JVM 的物理内存，所以创建和销毁的代价很高。DirectBuffer 申请的内存并不是直接由 JVM 负责垃圾回收，但在 DirectBuffer 包装类被回收时，会通过 Java 引用机制来释放该内存块。")]),a._v(" "),v("h4",{attrs:{id:"优化-i-o-避免阻塞"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优化-i-o-避免阻塞"}},[a._v("#")]),a._v(" 优化 I/O，避免阻塞")]),a._v(" "),v("p",[a._v("传统 I/O 的数据读写是在用户空间和内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。")]),a._v(" "),v("p",[a._v("NIO 的 Channel 有自己的处理器，可以完成内核空间和磁盘之间的 I/O 操作。在 NIO 中，我们读取和写入数据都要通过 Channel，由于 Channel 是双向的，所以读、写可以同时进行。")]),a._v(" "),v("h3",{attrs:{id:"aio"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#aio"}},[a._v("#")]),a._v(" AIO")]),a._v(" "),v("p",[a._v("AIO（Asynchronous IO） 即异步非阻塞 IO，指的是 Java 7 中，对 NIO 有了进一步的改进，也称为 NIO2，引入了异步非阻塞 IO 方式。")]),a._v(" "),v("p",[a._v("在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO）。异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。")]),a._v(" "),v("h2",{attrs:{id:"参考"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[a._v("#")]),a._v(" 参考")]),a._v(" "),v("p",[v("a",{attrs:{href:"https://dunwu.github.io/javacore/io/java-io.html#unix-i-o-%E6%A8%A1%E5%9E%8B",target:"_blank",rel:"noopener noreferrer"}},[a._v("Java IO 模型 | JAVACORE"),v("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=_.exports}}]);