(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{567:function(a,t,s){"use strict";s.r(t);var v=s(14),e=Object(v.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"java内存模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java内存模型"}},[a._v("#")]),a._v(" Java内存模型")]),a._v(" "),s("p",[a._v("JMM就是Java内存模型(java memory model)。因为"),s("strong",[a._v("在不同的硬件生产商和不同的操作系统下，内存的访问有一定的差异，所以会造成相同的代码运行在不同的系统上会出现各种问题")]),a._v("。所以"),s("strong",[a._v("java内存模型(JMM)屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的并发效果。")])]),a._v(" "),s("p",[a._v("Java内存模型规定"),s("strong",[a._v("所有的变量都存储在主内存")]),a._v("中，包括实例变量，静态变量，但是不包括局部变量和方法参数。每个线程都有自己的工作内存，"),s("strong",[a._v("线程的工作内存保存了该线程用到的变量和主内存的副本拷贝，线程对变量的操作都在工作内存中进行")]),a._v("。"),s("strong",[a._v("线程不能直接读写主内存中的变量")]),a._v("。")]),a._v(" "),s("p",[a._v("不同的线程之间也无法访问对方工作内存中的变量。线程之间变量值的传递均需要通过主内存来完成。")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("《Java虚拟机规范》[1]中曾试图定义一种“Java内存模型”[2]（Java Memory Model，JMM）"),s("strong",[a._v("来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果")]),a._v("。")])]),a._v(" "),s("li",[s("p",[a._v("定义Java内存模型并非一件容易的事情，这个模型必须定义得足够严谨，才能让Java的并发内存访问操作不会产生歧义；但是也必须定义得足够宽松，使得虚拟机的实现能有足够的自由空间去利用硬件的各种特性（寄存器、高速缓存和指令集中某些特有的指令）来获取更好的执行速度。经过长时间的验证和修补，"),s("strong",[a._v("直至JDK 5（实现了JSR-133[3]）发布后，Java内存模型才终于成熟、完善起来了。")])])])]),a._v(" "),s("h3",{attrs:{id:"jmm的引入"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jmm的引入"}},[a._v("#")]),a._v(" JMM的引入")]),a._v(" "),s("h4",{attrs:{id:"从堆栈说起"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#从堆栈说起"}},[a._v("#")]),a._v(" 从堆栈说起")]),a._v(" "),s("p",[a._v("JVM内部使用的Java内存模型在线程栈和堆之间划分内存。 此图从逻辑角度说明了Java内存模型：")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231552076.png",alt:"img"}})]),a._v(" "),s("h4",{attrs:{id:"堆栈里面放了什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#堆栈里面放了什么"}},[a._v("#")]),a._v(" 堆栈里面放了什么?")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("线程堆栈还包含正在执行的每个方法的所有局部变量(调用堆栈上的所有方法)。 线程只能访问它自己的线程堆栈。 由线程创建的局部变量对于创建它的线程以外的所有其他线程是不可见的。 即使两个线程正在执行完全相同的代码，两个线程仍将在每个自己的线程堆栈中创建该代码的局部变量。 因此，每个线程都有自己的每个局部变量的版本。")])]),a._v(" "),s("li",[s("p",[a._v("基本类型的所有局部变量(boolean，byte，short，char，int，long，float，double)完全存储在线程堆栈中，因此对其他线程不可见。 一个线程可以将一个基本类型变量的副本传递给另一个线程，但它不能共享原始局部变量本身。")])]),a._v(" "),s("li",[s("p",[a._v("堆包含了在Java应用程序中创建的所有对象，无论创建该对象的线程是什么。 这包括基本类型的包装类(例如Byte，Integer，Long等)。 无论是创建对象并将其分配给局部变量，还是创建为另一个对象的成员变量，该对象仍然存储在堆上。")])])]),a._v(" "),s("p",[s("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231552069.png",alt:"img"}})]),a._v(" "),s("ol",[s("li",[s("p",[s("strong",[a._v("局部变量可以是基本类型，在这种情况下，它完全保留在线程堆栈上。")])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("局部变量也可以是对象的引用。 在这种情况下，引用(局部变量)存储在线程堆栈中，但是对象本身存储在堆(Heap)上。")])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("对象的成员变量与对象本身一起存储在堆上。 当成员变量是基本类型时，以及它是对象的引用时都是如此。")])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("静态类变量也与类定义一起存储在堆上。")])])])]),a._v(" "),s("h4",{attrs:{id:"线程栈如何访问堆上对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线程栈如何访问堆上对象"}},[a._v("#")]),a._v(" 线程栈如何访问堆上对象?")]),a._v(" "),s("p",[a._v("所有具有对象引用的线程都可以访问堆上的对象。 当一个线程有权访问一个对象时，它也可以访问该对象的成员变量。 如果两个线程同时在同一个对象上调用一个方法，它们都可以访问该对象的成员变量，但每个线程都有自己的局部变量副本。")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231553675.png",alt:"img"}})]),a._v(" "),s("p",[a._v("两个线程有一组局部变量。 其中一个局部变量(局部变量2)指向堆上的共享对象(对象3)。 两个线程各自对同一对象具有不同的引用。 "),s("strong",[a._v("它们的引用是局部变量，因此存储在每个线程的线程堆栈中(在每个线程堆栈上)。 但是，这两个不同的引用指向堆上的同一个对象")]),a._v("。")]),a._v(" "),s("p",[a._v("注意共享对象(对象3)如何将对象2和对象4作为成员变量引用(由对象3到对象2和对象4的箭头所示)。 通过对象3中的这些成员变量引用，两个线程可以访问对象2和对象4.")]),a._v(" "),s("p",[a._v("该图还显示了一个局部变量，该变量指向堆上的两个不同对象。 在这种情况下，引用指向两个不同的对象(对象1和对象5)，而不是同一个对象。 理论上，如果两个线程都引用了两个对象，则两个线程都可以访问对象1和对象5。 但是在上图中，每个线程只引用了两个对象中的一个。")]),a._v(" "),s("h3",{attrs:{id:"jmm与硬件结构关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jmm与硬件结构关系"}},[a._v("#")]),a._v(" JMM与硬件结构关系")]),a._v(" "),s("h4",{attrs:{id:"硬件内存结构简介"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#硬件内存结构简介"}},[a._v("#")]),a._v(" 硬件内存结构简介")]),a._v(" "),s("p",[a._v("现代硬件内存架构与内部Java内存模型略有不同。 了解硬件内存架构也很重要，以了解Java内存模型如何与其一起工作。 本节介绍了常见的硬件内存架构，后面的部分将介绍Java内存模型如何与其配合使用。")]),a._v(" "),s("p",[a._v("这是现代计算机硬件架构的简化图：")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231553577.png",alt:"img"}})]),a._v(" "),s("p",[a._v("现代计算机通常有2个或更多CPU。 其中一些CPU也可能有多个内核。 关键是，在具有2个或更多CPU的现代计算机上，可以同时运行多个线程。 每个CPU都能够在任何给定时间运行一个线程。 这意味着如果您的Java应用程序是多线程的，线程真的在可能同时运行.")]),a._v(" "),s("p",[a._v("每个CPU基本上都包含一组在CPU内存中的寄存器。 CPU可以在这些寄存器上执行的操作比在主存储器中对变量执行的操作快得多。 这是因为CPU可以比访问主存储器更快地访问这些寄存器。")]),a._v(" "),s("p",[a._v("每个CPU还可以具有CPU高速缓存存储器层。 事实上，大多数现代CPU都有一些大小的缓存存储层。 CPU可以比主存储器更快地访问其高速缓存存储器，但通常不会像访问其内部寄存器那样快。 因此，CPU高速缓存存储器介于内部寄存器和主存储器的速度之间。 某些CPU可能有多个缓存层(级别1和级别2)，但要了解Java内存模型如何与内存交互，这一点并不重要。 重要的是要知道CPU可以有某种缓存存储层。")]),a._v(" "),s("p",[a._v("计算机还包含主存储区(RAM)。 所有CPU都可以访问主内存。 主存储区通常比CPU的高速缓存存储器大得多。同时访问速度也就较慢.")]),a._v(" "),s("p",[a._v("通常，当CPU需要访问主存储器时，它会将部分主存储器读入其CPU缓存。 它甚至可以将部分缓存读入其内部寄存器，然后对其执行操作。 当CPU需要将结果写回主存储器时，它会将值从其内部寄存器刷新到高速缓冲存储器，并在某些时候将值刷新回主存储器。")]),a._v(" "),s("h4",{attrs:{id:"jmm与硬件内存连接-引入"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jmm与硬件内存连接-引入"}},[a._v("#")]),a._v(" JMM与硬件内存连接 - 引入")]),a._v(" "),s("p",[a._v("如前所述，"),s("strong",[a._v("Java内存模型和硬件内存架构是不同的。 硬件内存架构不区分线程堆栈和堆。 在硬件上，线程堆栈和堆都位于主存储器中。 线程堆栈和堆的一部分有时可能存在于CPU高速缓存和内部CPU寄存器中。")]),a._v(" 这在图中说明：")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231552285.png",alt:"img"}})]),a._v(" "),s("p",[a._v("当对象和变量可以存储在计算机的各种不同存储区域中时，可能会出现某些问题。 两个主要问题是：")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("Visibility of thread updates (writes) to shared variables.")])]),a._v(" "),s("li",[s("p",[a._v("Race conditions when reading, checking and writing shared variables.")])])]),a._v(" "),s("p",[a._v("以下各节将解释这两个问题。")]),a._v(" "),s("h4",{attrs:{id:"jmm与硬件内存连接-对象共享后的可见性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jmm与硬件内存连接-对象共享后的可见性"}},[a._v("#")]),a._v(" JMM与硬件内存连接 - 对象共享后的可见性")]),a._v(" "),s("p",[a._v("如果两个或多个线程共享一个对象，而没有正确使用volatile声明或同步，则一个线程对共享对象的更新可能对其他线程不可见。")]),a._v(" "),s("p",[a._v("想象一下，共享对象最初存储在主存储器中。 然后，在CPU上运行的线程将共享对象读入其CPU缓存中。 它在那里对共享对象进行了更改。 只要CPU缓存尚未刷新回主内存，共享对象的更改版本对于在其他CPU上运行的线程是不可见的。 这样，每个线程最终都可能拥有自己的共享对象副本，每个副本都位于不同的CPU缓存中。")]),a._v(" "),s("p",[a._v("下图描绘了该情况。 在左CPU上运行的一个线程将共享对象复制到其CPU缓存中，并将其count变量更改为2.对于在右边的CPU上运行的其他线程，此更改不可见，因为计数更新尚未刷新回主内存中.")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231552689.png",alt:"img"}})]),a._v(" "),s("p",[a._v("要解决此问题，您可以使用Java的"),s("strong",[a._v("volatile关键字")]),a._v("。 "),s("strong",[a._v("volatile关键字可以确保直接从主内存读取给定变量，并在更新时始终写回主内存")]),a._v("。")]),a._v(" "),s("h4",{attrs:{id:"jmm与硬件内存连接-竞态条件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jmm与硬件内存连接-竞态条件"}},[a._v("#")]),a._v(" JMM与硬件内存连接 - 竞态条件")]),a._v(" "),s("p",[a._v("如果两个或多个线程共享一个对象，并且多个线程更新该共享对象中的变量，则可能会出现"),s("strong",[a._v("竞态")]),a._v("。")]),a._v(" "),s("p",[a._v("想象一下，如果线程A将共享对象的变量计数读入其CPU缓存中。 想象一下，线程B也做同样的事情，但是进入不同的CPU缓存。 现在，线程A将一个添加到count，而线程B执行相同的操作。 现在var1已经增加了两次，每个CPU缓存一次。")]),a._v(" "),s("p",[a._v("如果这些增量是按先后顺序执行的，则变量计数将增加两次并将原始值+ 2写回主存储器。")]),a._v(" "),s("p",[a._v("但是，两个增量同时执行而没有适当的同步。 无论线程A和B中哪一个将其更新后的计数版本写回主存储器，更新的值将仅比原始值高1，尽管有两个增量。")]),a._v(" "),s("p",[a._v("该图说明了如上所述的竞争条件问题的发生：")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231553906.png",alt:"img"}})]),a._v(" "),s("p",[a._v("要解决此问题，您可以使用Java "),s("strong",[a._v("synchronized")]),a._v("块。 同步块保证在任何给定时间只有一个线程可以进入代码的给定关键部分。 同步块"),s("strong",[a._v("还保证在同步块内访问的所有变量都将从主存储器中读入，当线程退出同步块时，所有更新的变量将再次刷新回主存储器")]),a._v("，无论变量是不是声明为volatile")]),a._v(" "),s("h2",{attrs:{id:"主内存与工作内存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#主内存与工作内存"}},[a._v("#")]),a._v(" 主内存与工作内存")]),a._v(" "),s("p",[a._v("Java内存模型的主要目的是定义程序中各种变量的访问规则，即**关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。**此处的变量（Variables）与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后者是线程私有的[1]，不会被共享，自然就不会存在竞争问题。")]),a._v(" "),s("p",[a._v("Java内存模型规定了"),s("strong",[a._v("所有的变量都存储在主内存")]),a._v("（Main Memory）中（此处的主内存与介绍物理硬件时提到的主内存名字一样，两者也可以类比，但物理上它仅是虚拟机内存的一部分）。"),s("strong",[a._v("每条线程还有自己的工作内存")]),a._v("（Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用的变量的主内存副本[2]，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据[3]。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231553812.png",alt:"img"}})]),a._v(" "),s("p",[s("strong",[a._v("这里所讲的主内存、工作内存与Java内存区域中的Java堆、栈、方法区等并不是同一个层次的对内存的划分，这两者基本上是没有任何关系的。如果两者一定要勉强对应起来，那么从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分[4]，而工作内存则对应于虚拟机栈中的部分区域。从更基础的层次上说，主内存直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（或者是硬件、操作系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问的是工作内存。")])]),a._v(" "),s("h2",{attrs:{id:"内存间交互"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存间交互"}},[a._v("#")]),a._v(" 内存间交互")]),a._v(" "),s("p",[a._v("关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节，Java内存模型中定义了以下8种操作来完成。")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。")])]),a._v(" "),s("li",[s("p",[a._v("unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。")])]),a._v(" "),s("li",[s("p",[a._v("read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以")])]),a._v(" "),s("li",[s("p",[a._v("便随后的load动作使用。")])]),a._v(" "),s("li",[s("p",[a._v("load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。")])]),a._v(" "),s("li",[s("p",[a._v("use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。")])]),a._v(" "),s("li",[s("p",[a._v("assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。")])]),a._v(" "),s("li",[s("p",[a._v("store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。")])]),a._v(" "),s("li",[s("p",[a._v("write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。")])])]),a._v(" "),s("p",[a._v("如果要把一个变量从主内存拷贝到工作内存，那就要按顺序执行read和load操作，如果要把变量从工作内存同步回主内存，就要按顺序执行store和write操作。注意，Java内存模型只要求上述两个操作必须按顺序执行，但不要求是连续执行。也就是说read与load之间、store与write之间是可插入其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现的顺序是read a、read b、load b、load a。")]),a._v(" "),s("h2",{attrs:{id:"volatile变量的特殊规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#volatile变量的特殊规则"}},[a._v("#")]),a._v(" volatile变量的特殊规则")]),a._v(" "),s("h3",{attrs:{id:"保证可见性但不保证原子性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#保证可见性但不保证原子性"}},[a._v("#")]),a._v(" 保证可见性但不保证原子性")]),a._v(" "),s("p",[a._v("当一个变量被定义成volatile之后，它将具备两项特性："),s("strong",[a._v("第一项是保证此变量对所有线程的可见性")]),a._v("，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以"),s("strong",[a._v("立即得知")]),a._v("的。而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。比如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再对主内存进行读取操作，新变量值才会对线程B可见。")]),a._v(" "),s("p",[a._v("关于volatile变量的可见性，经常会被开发人员误解，他们会误以为下面的描述是正确的：“volatile变量对所有线程是立即可见的，对volatile变量所有的写操作都能立刻反映到其他线程之中。换句话说，volatile变量在各个线程中是一致的，所以基于volatile变量的运算在并发下是线程安全的”。这句话的论据部分并没有错，"),s("strong",[a._v("但是由其论据并不能得出“基于volatile变量的运算在并发下是线程安全的”这样的结论")]),a._v("。")]),a._v(" "),s("p",[a._v("volatile变量在各个线程的工作内存中是不存在一致性问题的（从物理存储的角度看，各个线程的工作内存中volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题），但是Java里面的运算操作符并非原子操作，这导致volatile变量的运算在并发下一样是不安全的。")]),a._v(" "),s("p",[a._v("问题就出在自增运算“race++”之中，我们用Javap反编译这段代码后会得到代码清单12-2所示，发现只有一行代码的increase()方法在Class文件中是"),s("strong",[a._v("由4条字节码指令构成")]),a._v("（return指令不是由race++产生的，这条指令可以不计算），从字节码层面上已经很容易分析出并发失败的原因了：当getstatic指令把race的值取到操作栈顶时，volatile关键字保证了race的值在此时是正确的，但是在执行iconst_1、iadd这些指令的时候，其他线程可能已经把race的值改变了，而操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能把较小的race值同步回主内存之中。")]),a._v(" "),s("p",[a._v("由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized、java.util.concurrent中的锁或原子类）来保证原子性：")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。")])]),a._v(" "),s("li",[s("p",[a._v("变量不需要与其他的状态变量共同参与不变约束。")])])]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("volatile")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("boolean")]),a._v(" shutdownRequested"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("shutdown")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n\tshutdownRequested "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("doWork")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("while")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("!")]),a._v("shutdownRequested"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 代码的业务逻辑")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[s("strong",[a._v("注："),s("strong",[a._v("当shutdown()方法被调用时，能保证所有线程中执行的doWork()方法都")]),a._v("立即")]),a._v("停下来。")]),a._v(" "),s("p",[s("strong",[a._v("volatile一般多用于while判断的场景，判断某一个条件是否达到，如果满足条件可以立即退出循环或者立即返回。")])]),a._v(" "),s("h3",{attrs:{id:"禁止指令重排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#禁止指令重排序"}},[a._v("#")]),a._v(" 禁止指令重排序")]),a._v(" "),s("p",[a._v("使用volatile变量的第二个语义是禁止指令重排序优化，"),s("strong",[a._v("普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致")]),a._v("。因为在同一个线程的方法执行过程中无法感知到这点，这就是Java内存模型中描述的所谓“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）。")]),a._v(" "),s("p",[a._v("重排序时不能把后面的指令重排序到"),s("strong",[a._v("内存屏障")]),a._v("之前的位置，只有一个处理器访问内存时，并不需要内存屏障；但如果有两个或更多处理器访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。编译期重排序的典型就是通过调整指令顺序，"),s("strong",[a._v("做到在不改变程序语义的前提下，尽可能减少寄存器的读取、存储次数，充分复用寄存器的存储值。")])]),a._v(" "),s("p",[s("strong",[a._v("将本处理器的缓存写入了内存，该写入动作也会引起别的处理器或者别的内核无效化（Invalidate）其缓存")]),a._v("，这种操作相当于对缓存中的变量做了一次前面介绍Java内存模式中所说的“store和write”操作[4]。"),s("strong",[a._v("所以通过这样一个空操作，可让前面volatile变量的修改对其他处理器立即可见。")])]),a._v(" "),s("p",[a._v("那为何说它禁止指令重排序呢？从硬件架构上讲，指令重排序是指处理器采用了允许将多条指令不按程序规定的顺序分开发送给各个相应的电路单元进行处理。但并不是说指令任意重排，处理器必须能正确处理指令依赖情况保障程序能得出正确的执行结果。")]),a._v(" "),s("p",[a._v("在同一个处理器中，重排序过的代码看起来依然是有序的。因此，lock addl$0x0，(%esp)指令把修改同步到内存时，意味着所有之前的操作都已经执行完成，这样便形成了“指令重排序无法越过内存屏障”的效果。")]),a._v(" "),s("p",[a._v("在某些情况下，volatile的同步机制的性能确实要优于锁（使用synchronized关键字或java.util.concurrent包里面的锁），但是由于虚拟机对锁实行的许多消除和优化，使得我们很难确切地说volatile就会比synchronized快上多少。")]),a._v(" "),s("p",[a._v("volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢上一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。不过即便如此，大多数场景下volatile的总开销仍然要比锁来得更低。我们在volatile与锁中选择的唯一判断依据仅仅是volatile的语义能否满足使用场景的需求。")]),a._v(" "),s("h4",{attrs:{id:"禁止指令重排序的应用-双锁检测-dcl-的单例模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#禁止指令重排序的应用-双锁检测-dcl-的单例模式"}},[a._v("#")]),a._v(" 禁止指令重排序的应用-双锁检测（DCL）的单例模式")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Singleton")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("volatile")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Singleton")]),a._v(" singleton"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Singleton")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Singleton")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getInstance")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("singleton "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 1")]),a._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("synchronized")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Singleton")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("singleton "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n                    singleton "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Singleton")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 2")]),a._v("\n                "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" singleton"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v(" \n")])])]),s("p",[s("strong",[a._v("分析：")])]),a._v(" "),s("p",[a._v("实际上当程序执行到2处的时候，如果我们没有使用volatile关键字修饰变量singleton，就可能会造成错误。这是因为使用new关键字初始化一个对象的过程并不是一个原子的操作，它分成下面三个步骤（三个指令）进行：")]),a._v(" "),s("ol",[s("li",[a._v("给 singleton 分配内存")]),a._v(" "),s("li",[a._v("调用 Singleton 的构造函数来初始化成员变量")]),a._v(" "),s("li",[a._v("将 singleton 对象指向分配的内存空间（执行完这步 singleton 就为非 null 了）")])]),a._v(" "),s("p",[a._v("如果虚拟机存在指令重排序优化，则步骤b和c的顺序是无法确定的。如果A线程率先进入同步代码块并先执行了c而没有执行b，此时因为singleton已经非null。这时候线程B到了1处，判断singleton非null并将其返回使用，因为"),s("strong",[a._v("此时Singleton实际上还未初始化，自然就会出错。synchronized可以解决内存可见性，但是不能解决重排序问题。")])]),a._v(" "),s("h4",{attrs:{id:"规则详解-内存屏障"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#规则详解-内存屏障"}},[a._v("#")]),a._v(" 规则详解（内存屏障）")]),a._v(" "),s("p",[a._v("假定T表示一个线程，V和W分别表示两个volatile型变量，那么在进行read、load、use、assign、store和write操作时需要满足如下规则：")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("只有当线程T对变量V执行的前一个动作是load的时候，线程T才能对变量V执行use动作；并且，只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load动作。线程T对变量V的use动作可以认为是和线程T对变量V的load、read动作相关联的，必须连续且一起出现。")]),a._v(" "),s("p",[a._v("这条规则要求在工作内存中，每次使用V前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量V所做的修改。")])]),a._v(" "),s("li",[s("p",[a._v("只有当线程T对变量V执行的前一个动作是assign的时候，线程T才能对变量V执行store动作；并且，只有当线程T对变量V执行的后一个动作是store的时候，线程T才能对变量V执行assign动作。线程T对变量V的assign动作可以认为是和线程T对变量V的store、write动作相关联的，必须连续且一起出现。")]),a._v(" "),s("p",[a._v("这条规则要求在工作内存中，每次修改V后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量V所做的修改。")])]),a._v(" "),s("li",[s("p",[a._v("假定动作A是线程T对变量V实施的use或assign动作，假定动作F是和动作A相关联的load或store动作，假定动作P是和动作F相应的对变量V的read或write动作；与此类似，假定动作B是线程T对变量W实施的use或assign动作，假定动作G是和动作B相关联的load或store动作，假定动作Q是和动作G相应的对变量W的read或write动作。如果A先于B，那么P先于Q。")]),a._v(" "),s("p",[a._v("这条规则要求volatile修饰的变量不会被指令重排序优化，从而保证代码的执行顺序与程序的顺序相同。")])])]),a._v(" "),s("h2",{attrs:{id:"原子性、可见性与有序性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原子性、可见性与有序性"}},[a._v("#")]),a._v(" 原子性、可见性与有序性")]),a._v(" "),s("h3",{attrs:{id:"原子性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原子性"}},[a._v("#")]),a._v(" 原子性")]),a._v(" "),s("p",[a._v("由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，我们大致可以认为，"),s("strong",[a._v("基本数据类型的访问、读写都是具备原子性的（例外就是long和double的非原子性协定，读者只要知道这件事情就可以了，无须太过在意这些几乎不会发生的例外情况）")]),a._v("。")]),a._v(" "),s("p",[a._v("如果应用场景需要一个更大范围的原子性保证（经常会遇到），Java内存模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作。"),s("strong",[a._v("这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。")])]),a._v(" "),s("h3",{attrs:{id:"可见性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#可见性"}},[a._v("#")]),a._v(" 可见性")]),a._v(" "),s("p",[a._v("可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。上文在讲解volatile变量的时候我们已详细讨论过这一点。"),s("strong",[a._v("Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此")]),a._v("。**普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。**因此我们可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。")]),a._v(" "),s("p",[a._v("除了volatile之外，Java还有两个关键字能实现可见性，它们是synchronized和final。"),s("strong",[a._v("同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）”这条规则获得的")]),a._v("**。**而final关键字的可见性是指："),s("strong",[a._v("被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看见final字段的值。")])]),a._v(" "),s("h3",{attrs:{id:"有序性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#有序性"}},[a._v("#")]),a._v(" 有序性")]),a._v(" "),s("p",[a._v("Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内似表现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。")]),a._v(" "),s("p",[a._v("Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“"),s("strong",[a._v("一个变量在同一个时刻只允许一条线程对其进行lock操作")]),a._v("”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。")]),a._v(" "),s("h2",{attrs:{id:"先行发生原则-happens-before"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#先行发生原则-happens-before"}},[a._v("#")]),a._v(" 先行发生原则（happens-before）")]),a._v(" "),s("p",[a._v("如果Java内存模型中所有的有序性都仅靠volatile和synchronized来完成，那么有很多操作都将会变得非常啰嗦，但是我们在编写Java并发代码的时候并没有察觉到这一点，这是因为Java语言中有一个“先行发生”（Happens-Before）的原则。这个原则非常重要，它是判断数据是否存在竞争，线程是否安全的非常有用的手段。")]),a._v(" "),s("p",[a._v("先行发生是Java内存模型中定义的两项操作之间的偏序关系，比如说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。")]),a._v(" "),s("p",[a._v("下面是Java内存模型下一些**“天然的”先行发生关系**，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来，则它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("程序次序规则（Program Order Rule）："),s("strong",[a._v("在一个线程内")]),a._v("，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。"),s("strong",[a._v("注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。")])])]),a._v(" "),s("li",[s("p",[a._v("管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是“同一个锁”，而“后面”是指时间上的先后。")])]),a._v(" "),s("li",[s("p",[a._v("volatile变量规则（Volatile Variable Rule）："),s("strong",[a._v("对一个volatile变量的写操作先行发生于后面对这个变量的读操作")]),a._v("，这里的“后面”同样是指时间上的先后。")])]),a._v(" "),s("li",[s("p",[a._v("线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作。")])]),a._v(" "),s("li",[s("p",[a._v("线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。")])]),a._v(" "),s("li",[s("p",[a._v("线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread::interrupted()方法检测到是否有中断发生。")])]),a._v(" "),s("li",[s("p",[a._v("对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。")])]),a._v(" "),s("li",[s("p",[a._v("传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。")])])]),a._v(" "),s("p",[a._v("其实，可以这么简单的理解，"),s("strong",[a._v("为了避免 Java 程序员为了理解 JMM 提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现方法，JMM 就出了这么一个简单易懂的 Happens-before 原则")]),a._v("，一个 Happens-before 规则就对应于一个或多个编译器和处理器的重排序规则，这样，我们只需要弄明白 Happens-before 就行了。")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231552954.png",alt:"img"}})]),a._v(" "),s("h3",{attrs:{id:"实例分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实例分析"}},[a._v("#")]),a._v(" 实例分析")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" value "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\npubilc "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("setValue")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("value "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getValue")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("假设存在线程A和B，"),s("strong",[a._v("线程A先（时间上的先后）调用了setValue(1)，然后线程B调用了同一个对象的getValue()")]),a._v("，那么线程B收到的返回值是什么？")]),a._v(" "),s("p",[a._v("我们依次分析一下先行发生原则中的各项规则。由于两个方法分别由线程A和B调用，不在一个线程中，所以程序次序规则在这里不适用；由于没有同步块，自然就不会发生lock和unlock操作，所以管程锁定规则不适用；由于value变量没有被volatile关键字修饰，所以volatile变量规则不适用；后面的线程启动、终止、中断规则和对象终结规则也和这里完全没有关系。因为没有一个适用的先行发生规则，所以最后一条传递性也无从谈起，因此我们可以判定，"),s("strong",[a._v("尽管线程A在操作时间上先于线程B，但是无法确定线程B中getValue()方法的返回结果，换句话说，这里面的操作不是线程安全的。")])]),a._v(" "),s("p",[a._v("那怎么修复这个问题呢？我们至少有两种比较简单的方案可以选择：要么把getter/setter方法都定义为synchronized方法，这样就可以套用管程锁定规则；要么把value定义为volatile变量，由于setter方法对value的修改不依赖value的原值，满足volatile关键字使用场景，这样就可以套用volatile变量规则来实现先行发生关系。")]),a._v(" "),s("p",[s("strong",[a._v("时间先后顺序与先行发生原则之间基本没有因果关系，所以我们衡量并发安全问题的时候不要受时间顺序的干扰，一切必须以先行发生原则为准。")])])])}),[],!1,null,null,null);t.default=e.exports}}]);