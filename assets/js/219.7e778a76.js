(window.webpackJsonp=window.webpackJsonp||[]).push([[219],{774:function(v,_,o){"use strict";o.r(_);var r=o(14),e=Object(r.a)({},(function(){var v=this,_=v.$createElement,o=v._self._c||_;return o("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[o("h2",{attrs:{id:"说一下innodb和myisam数据库引擎的区别"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#说一下innodb和myisam数据库引擎的区别"}},[v._v("#")]),v._v(" 说一下InnoDB和MyIsam数据库引擎的区别？")]),v._v(" "),o("ol",[o("li",[o("p",[v._v("对于存储引擎，可以使用show engines;语句进行查询，一般支持InnoDB，MyIsam，Memory，Archive等数据库存储引擎。")])]),v._v(" "),o("li",[o("p",[v._v("InnoDB是MySQL的默认引擎，它支持事务、外键、表锁、行锁，索引使用的是B+树。InnoDB的数据存储方式是聚集索引，它通过表的主键顺序，为整个表的行记录构建一颗B+树，每个节点表示一页，所有叶子节点存储了整张表的数据。")])]),v._v(" "),o("li",[o("p",[v._v("MyIsam存储引擎不支持事务，只支持表级锁，它的索引使用的也是B+树，但不是聚集索引，它的叶子节点存储的也不是一整页的行数据，而是一个指向具体行的内存地址。所以，通过这个地址，可以快速定位到行数据，查找速度较快。这种引擎通常适用于大量读取操作，不需要事务支持的场景。")])])]),v._v(" "),o("h2",{attrs:{id:"mysql的底层结构是什么"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#mysql的底层结构是什么"}},[v._v("#")]),v._v(" MySQL的底层结构是什么？")]),v._v(" "),o("ol",[o("li",[o("p",[v._v("我们知道，MySQL的逻辑存储结构是通过"),o("strong",[v._v("表空间、段、区、数据页以及数据行")]),v._v("等组成的，其中页是InnDB的最小存储单位，大小一般为16k，可以存放大概2-200行的数据。在页中，行记录是按照主键的顺序以链表的形式组成在一起的，此外，页中还有一个页目录，可以对行记录进行索引。")])]),v._v(" "),o("li",[o("p",[v._v("而对于MySQL的物理存储方式是通过聚集索引实现的，聚集索引是按照每张表的主键顺序为所有行记录构建的一颗B+树。在该二叉树中，叶子结点存放的是实际的行记录数据，而非叶子结点存放的是偏移量或者索引值，并不存储实际的行数据。")])])]),v._v(" "),o("h2",{attrs:{id:"b-树了解吗"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#b-树了解吗"}},[v._v("#")]),v._v(" B+树了解吗？")]),v._v(" "),o("ol",[o("li",[o("p",[v._v("B+树并不是一颗二叉树，而是一颗平衡多叉查找树。")])]),v._v(" "),o("li",[o("p",[v._v("B+树是从B-树（叫做B树）引化而来的，对于B-树而言，它的非叶子结点最多有M个儿子，而且其所有叶子结点在同一层，所以其是一个高度平衡的多叉搜索树。在对B-树的搜索过程中，首先从根节点开始对结点内的有序关键字进行二分查找，如果没有命中则进入所属范围的子节点中重复查找，直到到叶子结点。")])]),v._v(" "),o("li",[o("p",[v._v("B+树的定义与B-树十分相似，但是两者存在一些显著的不同之处。")]),v._v(" "),o("ul",[o("li",[o("p",[v._v("B-树中的任何一个关键字只出现在一个结点中，所有搜索操作可能在非叶子结点中就停止了。")])]),v._v(" "),o("li",[o("p",[v._v("B+树中，所有的关键字都会在叶子结点中出现，而且非叶子结点并不是存储的实际值，而是存储的子节点的索引。")])]),v._v(" "),o("li",[o("p",[v._v("此外，B+树与B-树的一个最大不同是，B+树的叶子结点之间使用双向链表链接起来了。")])])])])]),v._v(" "),o("h2",{attrs:{id:"b树与b-树的区别"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#b树与b-树的区别"}},[v._v("#")]),v._v(" B树与B+树的区别？")]),v._v(" "),o("ol",[o("li",[o("p",[v._v("B树中，同一个键只会在整棵树中出现一次，所以在查询的时候有可能在在非叶子结点就找到了目标值，但这就进一步导致了查询效率的不稳定性。")])]),v._v(" "),o("li",[o("p",[v._v("B树中，每个节点都会保存关键字、索引和数据，而B+树只有叶子结点保存数据，其他节点保存关键字和索引，所以对于相同的内存空间，可以容纳更多的索引结点。因为一个结点就是一个内存页，一个页的大小一般为16k，在B+树中，因为非叶子节点只存储键和索引，所以可以"),o("strong",[v._v("让每个索引页存储更多的索引值，这样可以使B+树的层数更少，减少磁盘IO的次数")]),v._v("。")])]),v._v(" "),o("li",[o("p",[v._v("B+树中，它的所有叶子结点是通过双向链表连接在一起的，这特别适合范围查询操作，而B树中要实现范围查询，则需要中序遍历二叉树，这增加了IO的次数。")])])]),v._v(" "),o("h2",{attrs:{id:"mysql的索引"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#mysql的索引"}},[v._v("#")]),v._v(" MySQL的索引？")]),v._v(" "),o("ol",[o("li",[o("p",[v._v("MySQL的索引在不同的数据库引擎是不同的，在InnoDB中，它的索引是通过B+树实现的，它将数据存储与索引放在一起，找到索引就代表找到了数据，俗称聚集性索引。而在MyIsam中，虽然它也是用B+树来实现的，但是，它将数据和索引分开存储，叶子结点指向了数据的对应行。")])]),v._v(" "),o("li",[o("p",[v._v("需要注意的是，在InnoDB中，在聚簇索引之上建立的索引称之为辅助索引，辅助索引访问数据都需要二次查找。**非聚簇索引都是辅助索引，但是辅助索引不一定是非聚簇索引。**"),o("strong",[v._v("像复合索引，前缀索引，唯一索引这些辅助索引，它的叶子结点存储的不是行的物理位置，而是主键值。")])])])]),v._v(" "),o("h2",{attrs:{id:"索引为什么不使用红黑树来实现"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#索引为什么不使用红黑树来实现"}},[v._v("#")]),v._v(" 索引为什么不使用红黑树来实现？")]),v._v(" "),o("ol",[o("li",[o("p",[v._v("红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因。")])]),v._v(" "),o("li",[o("p",[v._v("更少的查找次数：平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。")])]),v._v(" "),o("li",[o("p",[v._v("利用磁盘预读特性：为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。而红黑树中由于是二路的，导致相邻的节点其在内存中的位置都是相差很远的，无法有效地利用磁盘的预读特性。")])])]),v._v(" "),o("h2",{attrs:{id:"mysql索引的调优小技巧"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#mysql索引的调优小技巧"}},[v._v("#")]),v._v(" MySQL索引的调优小技巧？")]),v._v(" "),o("ol",[o("li",[o("p",[v._v("如果建立的是复合索引，索引的顺序要按照建立的顺序，否则有可能无法使用到索引。")])]),v._v(" "),o("li",[o("p",[v._v("减少select *的使用，这样可以尽可能地使用覆盖索引，所以需要尽量保持select查询字段与where中的索引字段一样。")])]),v._v(" "),o("li",[o("p",[v._v("禁止对索引做运算和函数操作，这样会导致索引失效。")])]),v._v(" "),o("li",[o("p",[v._v("索引不要放在范围查询的后面，因为在范围查询之后的索引都会失效。")])]),v._v(" "),o("li",[o("p",[v._v("like模糊查询，主要失效的情况。")])]),v._v(" "),o("li",[o("p",[v._v("order by优化")])])]),v._v(" "),o("h2",{attrs:{id:"mvcc机制了解吗-它出现的原因是什么-以及如何实现的"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#mvcc机制了解吗-它出现的原因是什么-以及如何实现的"}},[v._v("#")]),v._v(" MVCC机制了解吗？它出现的原因是什么？以及如何实现的？")]),v._v(" "),o("ol",[o("li",[o("p",[v._v("说到MVCC就不得提InnoDB的事务隔离级别，InnoDB为了保证数据的一致性，设置了不同级别的事务级别。")])]),v._v(" "),o("li",[o("p",[v._v("MVCC总共有四种事务隔离级别，分别是读取未提交，读取已提交，可重复读和序列化这四个，默认的隔离级别是可重复读事务隔离级别。")])]),v._v(" "),o("li",[o("p",[v._v("对于读取未提交的隔离级别，它可以避免丢失修改的问题，因为对于行的操作，都需要对行进行加锁，但是却无法解决脏读的问题，因为它会读取其他事务尚未提交的数据，这违反了数据库隔离性。而读取已提交的事务隔离级别，解决了脏读的问题，但是还未解决不可重复读的问题。不可重复读读取的是已经提交的事务，它主要发生的场景在一个事务多次读取同一个数据集合，但是在这个事务还没结束时，另外一个事务也访问了这个数据集合，并做了一些数据的增删改操作。其实，这种这种问题是可以提交的，本身不是带来多大的问题，但是其违反了数据库"),o("strong",[v._v("事务一致性要求")]),v._v("。在可重复读的事务隔离级别下，它解决了不可重复读的情况，但是可能会出现幻读的状况出现。幻读其实是不可重复读的一种特殊情况，不可重复读一般是针对update而言的，而幻读是针对insert和delete而言，一般在范围查询时会出现这种现象。")])]),v._v(" "),o("li",[o("p",[v._v("可重复读隔离机制为了解决幻读的情况，就提出了MVCC的机制。其实，在可重复读的机制下，对于读操作，有两种类别，分别是当前读和快照读。"),o("strong",[v._v("MVCC使用临键锁来解决了当前读下的幻读问题，而对于快照读的状况，其使用MVCC即多版本并发控制机制来避免幻读。")])])]),v._v(" "),o("li",[o("p",[v._v("MVCC机制依赖于行记录的三个隐藏列，分别是事务ID，回滚指针以及行标识（隐藏自增ID）。此外，它还依赖于undo log，这其实是为了回滚作用的。每次对行记录的改动都会记录一条undo日志，每条undo日志都有一个回滚指针的属性，通过这个指针可以将所有的undo日志链接起来，形成我们所说的版本链。此外，MVCC还需要借助一种read view，read view实际上遵循一个可见性算法，它将需要将当前事务的ID取出，与系统中的其他活跃事务的ID去对比，这些活跃ID由read view去维护**（维护一个尚未提交事务的事务Id数组，以及一个已经创建的最大事务ID）**，如果不符合可见性，则通过回滚指针去取出undo log中的下一个事务ID进行比较，直到遇到可见的事务，这个事务记录就是当前事务能够看到的最新老版本。")])])]),v._v(" "),o("h2",{attrs:{id:"如何通俗地理解三个范式"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#如何通俗地理解三个范式"}},[v._v("#")]),v._v(" 如何通俗地理解三个范式？")]),v._v(" "),o("p",[v._v("第一范式：1NF 是对属性的原子性约束，要求属性具有原子性，不可再分解；")]),v._v(" "),o("p",[v._v("第二范式：2NF 是对记录的唯一性约束，要求记录有惟一标识，即"),o("strong",[v._v("实体的惟一性")]),v._v("；")]),v._v(" "),o("p",[v._v("第三范式：3NF 是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。")]),v._v(" "),o("h2",{attrs:{id:"三大日志"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#三大日志"}},[v._v("#")]),v._v(" 三大日志？")]),v._v(" "),o("h3",{attrs:{id:"redo日志"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#redo日志"}},[v._v("#")]),v._v(" redo日志")]),v._v(" "),o("ol",[o("li",[o("p",[o("code",[v._v("redo log")]),v._v("（重做日志）"),o("strong",[v._v("是")]),o("code",[v._v("**InnoDB**")]),o("strong",[v._v("存储引擎独有的，它让")]),o("code",[v._v("**MySQL**")]),o("strong",[v._v("拥有了崩溃恢复能力")]),v._v("。比如 "),o("code",[v._v("MySQL")]),v._v(" 实例挂了或宕机了，重启时，"),o("code",[v._v("InnoDB")]),v._v("存储引擎会使用"),o("code",[v._v("redo log")]),v._v("恢复数据，保证数据的持久性与完整性。")])]),v._v(" "),o("li",[o("p",[v._v("InnoDB会把“"),o("strong",[v._v("在某个数据页上做了什么修改")]),v._v("”记录到"),o("strong",[v._v("重做日志缓存（")]),o("code",[v._v("**redo log buffer**")]),v._v("**）**里，接着刷盘到 "),o("code",[v._v("redo log")]),v._v(" 文件里。")])]),v._v(" "),o("li",[o("p",[v._v("另外，"),o("code",[v._v("**InnoDB**")]),v._v(" "),o("strong",[v._v("存储引擎有一个后台线程，每隔")]),o("code",[v._v("**1**")]),v._v(" "),o("strong",[v._v("秒，就会把")]),v._v(" "),o("code",[v._v("**redo log buffer**")]),v._v(" "),o("strong",[v._v("中的内容写到文件系统缓存（")]),o("code",[v._v("**page cache**")]),o("strong",[v._v("），然后调用")]),v._v(" "),o("code",[v._v("**fsync**")]),v._v(" "),o("strong",[v._v("刷盘")]),v._v("。")])]),v._v(" "),o("li",[o("p",[v._v("理想情况，"),o("strong",[v._v("事务一提交就会进行刷盘操作，但实际上，刷盘的时机是根据策略来进行的")]),v._v("。刷盘实际主要有三种策略：")]),v._v(" "),o("ul",[o("li",[o("p",[o("strong",[v._v("0")]),v._v(" ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作")])]),v._v(" "),o("li",[o("p",[o("strong",[v._v("1")]),v._v(" ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）")])]),v._v(" "),o("li",[o("p",[o("strong",[v._v("2")]),v._v(" ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache")])])])])]),v._v(" "),o("h3",{attrs:{id:"binlog日志"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#binlog日志"}},[v._v("#")]),v._v(" binlog日志")]),v._v(" "),o("ol",[o("li",[o("p",[o("code",[v._v("**redo log**")]),v._v(" "),o("strong",[v._v("它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于")]),v._v(" "),o("code",[v._v("**InnoDB**")]),v._v(" "),o("strong",[v._v("存储引擎")]),v._v("。"),o("strong",[v._v("而")]),v._v(" "),o("code",[v._v("**binlog**")]),v._v(" "),o("strong",[v._v("是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于")]),o("code",[v._v("**MySQL Server**")]),v._v(" "),o("strong",[v._v("层")]),v._v("。换句话说，不管用什么存储引擎，只要发生了表数据更新，都会产生 "),o("code",[v._v("binlog")]),v._v(" 日志。")])]),v._v(" "),o("li",[o("p",[v._v("可以说"),o("code",[v._v("MySQL")]),v._v("数据库的"),o("strong",[v._v("数据备份、主备、主主、主从")]),v._v("都离不开"),o("code",[v._v("binlog")]),v._v("，需要依靠"),o("code",[v._v("binlog")]),v._v("来同步数据，保证数据一致性。")])]),v._v(" "),o("li",[o("p",[o("code",[v._v("binlog")]),v._v("的写入时机也非常简单，事务执行过程中，先把日志写到"),o("code",[v._v("**binlog cache**")]),v._v("，"),o("strong",[v._v("事务提交的时候")]),v._v("**，再把**"),o("code",[v._v("**binlog cache**")]),o("strong",[v._v("写到磁盘中的")]),o("code",[v._v("**binlog**")]),o("strong",[v._v("文件中")]),v._v("。具体地，binlog日志的刷盘流程为： "),o("strong",[v._v("write，是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快。fsync，才是将数据从page cache 持久化到磁盘的操作")])])]),v._v(" "),o("li",[o("p",[v._v("上述的write和fsync也是由参数控制的，主要有三种选择：")]),v._v(" "),o("ul",[o("li",[o("p",[v._v("为"),o("code",[v._v("0")]),v._v("的时候，表示每次提交事务都只"),o("code",[v._v("write")]),v._v("，由系统自行判断什么时候执行"),o("code",[v._v("fsync")]),v._v("。")])]),v._v(" "),o("li",[o("p",[v._v("为了安全起见，可以设置为"),o("code",[v._v("1")]),v._v("，表示"),o("strong",[v._v("每次提交事务都会执行")]),o("code",[v._v("**fsync**")]),v._v("，就如同"),o("strong",[v._v("binlog 日志刷盘流程")]),v._v("一样。")])]),v._v(" "),o("li",[o("p",[v._v("最后还有一种折中方式，可以设置为"),o("code",[v._v("N(N>1)")]),v._v("，表示每次提交事务都"),o("code",[v._v("write")]),v._v("，但"),o("strong",[v._v("累积")]),o("code",[v._v("**N**")]),o("strong",[v._v("个事务后才")]),o("code",[v._v("**fsync**")]),v._v("。")])])])])]),v._v(" "),o("h3",{attrs:{id:"undo日志"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#undo日志"}},[v._v("#")]),v._v(" undo日志")]),v._v(" "),o("ol",[o("li",[o("p",[v._v("我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行"),o("strong",[v._v("回滚")]),v._v("，在 MySQL 中，恢复机制是通过 "),o("strong",[v._v("回滚日志（undo log）")]),v._v(" 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 "),o("strong",[v._v("回滚日志")]),v._v(" 中的信息将数据回滚到修改之前的样子即可！")])]),v._v(" "),o("li",[o("p",[v._v("并且，"),o("strong",[v._v("回滚日志会先于数据持久化到磁盘上")]),v._v("。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。")])])]),v._v(" "),o("h2",{attrs:{id:"主从复制的原理"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#主从复制的原理"}},[v._v("#")]),v._v(" 主从复制的原理？")]),v._v(" "),o("ol",[o("li",[o("p",[v._v("复制（replication）是MySQL数据库提供的一种"),o("strong",[v._v("高可用高性能")]),v._v("的解决方案，一般用来建立大型的应用。总体来说，replication的工作原理。分为以下3个步骤：")]),v._v(" "),o("ul",[o("li",[o("p",[v._v("主服务器（master）把数据更改记录到二进制日志（binlog）中。")])]),v._v(" "),o("li",[o("p",[v._v("从服务器（slave）把主服务器的二进制日志复制到自己的中继日志（relay log）中。")])]),v._v(" "),o("li",[o("p",[v._v("从服务器重做中继日志中的日志，把更改应用到自己的数据库上，以达到数据的最终一致性。")])])])]),v._v(" "),o("li",[o("p",[v._v("**从服务器有2个线程，一个是I/O线程，负责读取主服务器的二进制日志，并将其保存为中继日志；另一个是SQL线程，复制执行中继日志。**MySQL4.0版本之前，从服务器只有1个线程，既负责读取二进制日志，又负责执行二进制日志中的SQL语句。这种方式不符合高性能的要求，目前已淘汰。")])])]),v._v(" "),o("h2",{attrs:{id:"一条sql语句在mysql中是如何执行的"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#一条sql语句在mysql中是如何执行的"}},[v._v("#")]),v._v(" 一条SQL语句在MySQL中是如何执行的？")]),v._v(" "),o("ol",[o("li",[o("p",[o("strong",[v._v("连接验证及解析")]),v._v("：客户端与MySQL Server建立连接，发送语句给MySQL Server，接收到后如果是查询语句会先去查询缓存中看，有的话就直接返回了，（新版本的MySQL已经废除了查询缓存，命中率太低了），如果是缓存没有或者是非查询语句，会创建一个解析树，然后进行优化，（解析器知道语句是要执行什么，会评估使用各种索引的代价，然后去使用索引，以及调节表的连接顺序）然后调用innodb引擎的接口来执行语句。")])]),v._v(" "),o("li",[o("p",[o("strong",[v._v("写undo log")]),v._v("：innodb 引擎首先开启事务，获得一个事务ID(是一直递增的)，根据执行的语句生成一个反向的语句，(如果是INSERT会生成一条DELETE语句，如果UPDATE语句就会生成一个UPDATE成旧数据的语句)，用于提交失败后回滚，将这条反向语句写入undo log，"),o("strong",[v._v("得到回滚指针，并且更新这个数据行的回滚指针和事务id。")]),v._v("（事务提交后，Undo log并不能立马被删除，而是放入待清理的链表，由purge 线程判断是否有其他事务在使用undo 段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间，简单的说就是看之前的事务是否提交成功，这个事务及之前的事务都提交成功了，这部分undo log才能删除。）")])]),v._v(" "),o("li",[o("p",[o("strong",[v._v("从索引中查找数据")]),v._v("：根据索引去B+树中找到这一行数据（如果是普通索引，查到不符合条件的索引，会把所有数据查找出来，唯一性索引查到第一个数据就可以了）")])]),v._v(" "),o("li",[o("p",[o("strong",[v._v("更新数据")]),v._v("：判断数据页是否在内存中？若在，则直接更新内存中的数据页；否则，将对数据页的更新操作记录到change buffer，暂时不更新到磁盘。change buffer会在空闲时异步更新到磁盘。")])]),v._v(" "),o("li",[o("p",[o("strong",[v._v("写redo log（prepare状态）")]),v._v("：将对数据页的更改写入到redo log，此时redo log中这条事务的状态为prepare状态。")])]),v._v(" "),o("li",[o("p",[o("strong",[v._v("写bin log（同时将redo log设置为commit状态）")]),v._v("：通知MySQL server已经更新操作写入到redo log 了，随时可以提交，将执行的SQL写入到bin log日志，将redo log 中这条事务的状态改成commit状态，事务提交成功。")])])]),v._v(" "),o("h2",{attrs:{id:"两阶段提交"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#两阶段提交"}},[v._v("#")]),v._v(" 两阶段提交？")]),v._v(" "),o("ol",[o("li",[o("p",[v._v("在执行更新语句过程，会记录"),o("code",[v._v("redo log")]),v._v("与"),o("code",[v._v("binlog")]),v._v("两块日志，以基本的事务为单位，"),o("code",[v._v("**redo log**")]),o("strong",[v._v("在事务执行过程中可以不断写入，而")]),o("code",[v._v("**binlog**")]),o("strong",[v._v("只有在提交事务时才写入，所以")]),o("code",[v._v("**redo log**")]),o("strong",[v._v("与")]),o("code",[v._v("**binlog**")]),o("strong",[v._v("的写入时机不一样。")])])]),v._v(" "),o("li",[o("p",[v._v("为了解决两份日志之间的逻辑一致问题，"),o("code",[v._v("InnoDB")]),v._v("存储引擎使用"),o("strong",[v._v("两阶段提交")]),v._v("方案。原理很简单，"),o("strong",[v._v("将")]),o("code",[v._v("**redo log**")]),o("strong",[v._v("的写入拆成了两个步骤")]),o("code",[v._v("**prepare**")]),o("strong",[v._v("和")]),o("code",[v._v("**commit**")]),v._v("，这就是"),o("strong",[v._v("两阶段提交")]),v._v("。")])]),v._v(" "),o("li",[o("p",[v._v("使用"),o("strong",[v._v("两阶段提交")]),v._v("后，写入"),o("code",[v._v("binlog")]),v._v("时发生异常也不会有影响，因为"),o("code",[v._v("MySQL")]),v._v("根据"),o("code",[v._v("redo log")]),v._v("日志恢复数据时，发现"),o("code",[v._v("redo log")]),v._v("还处于"),o("code",[v._v("prepare")]),v._v("阶段，并且没有对应"),o("code",[v._v("binlog")]),v._v("日志，就会回滚该事务。")])])])])}),[],!1,null,null,null);_.default=e.exports}}]);