(window.webpackJsonp=window.webpackJsonp||[]).push([[215],{770:function(n,i,r){"use strict";r.r(i);var e=r(14),t=Object(e.a)({},(function(){var n=this,i=n.$createElement,r=n._self._c||i;return r("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[r("h2",{attrs:{id:"解释一下springmvc的工作原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#解释一下springmvc的工作原理"}},[n._v("#")]),n._v(" 解释一下SpringMVC的工作原理？")]),n._v(" "),r("p",[n._v("Spring MVC提供了一种轻度耦合的方式来开发Web应用，更具体地说，它是一个web框架，是Spring中的子模块。它通过几个核心组件：DispatcherServlet，ModelAndView以及ViewResolver使开发Web应用更加简单。")]),n._v(" "),r("p",[r("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203201028237.png",alt:""}})]),n._v(" "),r("ol",[r("li",[r("p",[n._v("首先用户会发送请求到DispatcherServlet中，DispatcherServlet相当于一个中心调度器，是SpringMVC的核心组成部分。")])]),n._v(" "),r("li",[r("p",[n._v("DispatcherServlet会将收到的请求url通过调用HandlerMapping映射器进行映射，以找到具体的处理器。在这个过程中，会生成处理器对象以及处理器拦截器作为"),r("strong",[n._v("处理器执行链")]),n._v("返回DispatcherServlet。")])]),n._v(" "),r("li",[r("p",[n._v("DispatcherServlet通过HandlerAdapter适配器调用"),r("strong",[n._v("具体的处理器")]),n._v("，通过执行具体的Handler（也可以叫做Controller）后，返回ModelAndView。")])]),n._v(" "),r("li",[r("p",[n._v("Dispatcher收到ModelAndView后，将其传给ViewResolver视图解析器。")])]),n._v(" "),r("li",[r("p",[n._v("ViewResolver视图解析器进行解析后会返回具体的View。")])]),n._v(" "),r("li",[r("p",[n._v("DispatcherServlet会对返回的View进行视图渲染，在这里主要"),r("strong",[n._v("将Model数据对象填充到视图中")]),n._v("。")])]),n._v(" "),r("li",[r("p",[n._v("最后，DispatcherServlet响应用户。")])])]),n._v(" "),r("h2",{attrs:{id:"了解spring-ioc-di吗"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#了解spring-ioc-di吗"}},[n._v("#")]),n._v(" 了解Spring IoC，DI吗？")]),n._v(" "),r("ol",[r("li",[r("p",[n._v("控制反转是一种面向对象编程中的设计思想，它主要用来降低计算机代码间的耦合度，并且它是实现依赖倒置原则的一种实现思路。为了实现一个功能，你可能需要调用一个接口对象的方法，在潜意识里我们可以会想到这个对象应该由自己去创建，但是这事实上并不正确，因为你可能对这个领域并不精通，这个时候，我们需要把创建对象的主动权转交给别人，这就是控制反转的思想。在Spring中，实现控制反转的是IoC容器，它实现的方法是依赖注入。")])]),n._v(" "),r("li",[r("p",[n._v("依赖注入是是实现控制反转的一种方式，"),r("strong",[n._v("所谓依赖注入就是说组件之间的依赖关系是由容器在运行时决定的，需要由容器动态地将依赖注入到某个组件中去")]),n._v("。通过依赖注入，我们可以通过简单配置，而不需任何代码就能指定目标所需要的资源，只需要完成自身的业务逻辑，而不用关心资源来自何处，由谁实现。")])]),n._v(" "),r("li",[r("p",[n._v("依赖注入的方式有三种，setter方式，构造方法注入，注解注入（借助@Autowired和@Resource注解）。")])])]),n._v(" "),r("h2",{attrs:{id:"bean的作用域"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#bean的作用域"}},[n._v("#")]),n._v(" Bean的作用域？")]),n._v(" "),r("ol",[r("li",[r("p",[n._v("在默认的情况下，Spring IoC只会为配置的Bean生成一个实例，而不是多个。但是有时我们希望Bean的实例是多个的，特别是在多线程的环境情况下，为了避免并发情况，我们会希望每次请求有多个实例。")])]),n._v(" "),r("li",[r("p",[n._v("Spring中的Bean有四种作用域，包括：单例，原型，请求和会话。其中，原型指的是，在每次注入或者每次Spring IoC容器获取Bean的过程中，都为其创建一个新的实例；请求的意思是，在Web应用中，每次请求都会创建一个实例；会话作用域指的是，在一次会话过程中只会创建一个实例。")])])]),n._v(" "),r("h2",{attrs:{id:"什么是beandefinition"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是beandefinition"}},[n._v("#")]),n._v(" 什么是BeanDefinition？")]),n._v(" "),r("ol",[r("li",[n._v("我是这么理解的，BeanDefinition是SpringIoC加载Bean过程中的一个产物，可以看出是对Bean定义的抽象，里面封装的数据是与Bean定义相关的，比如属性，初始化方法和销毁方法等。")])]),n._v(" "),r("h2",{attrs:{id:"springbean的生命周期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#springbean的生命周期"}},[n._v("#")]),n._v(" SpringBean的生命周期？")]),n._v(" "),r("ol",[r("li",[r("p",[n._v("SpringBean的生命周期主要有几个重要的阶段，包括Bean的实例化阶段、属性赋值阶段以及Bean销毁阶段。")])]),n._v(" "),r("li",[r("p",[n._v("Bean的实例化阶段主要在createBeanInstance()方法中，它会调用类的构造方法来创建一个Bean实例。在这里，用户可以自定义一个类，通过继承InstantiationAwareBeanPostProcessorAdapter类重写它的两个方法，可以实现Bean实例化前后的一些额外操作。")])]),n._v(" "),r("li",[r("p",[n._v("Bean的属性赋值阶段，主要在populateBean方法中，它会对Bean的各项属性进行赋值。")])]),n._v(" "),r("li",[r("p",[n._v("Bean的初始化阶段：这里主要是调用用户自定义的初始化方法init-Method()进行对象的初始化。在这里，用户可以自定义一个类，继承BeanPostProcessor类，通过重写它的两个方法，可以对Bean的初始化前后做一些额外的操作，比如打印日志等。")])]),n._v(" "),r("li",[r("p",[n._v("Bean的销毁阶段：用户可以自定义destroyMethod方法，在Bean被销毁的时候被调用。")])])]),n._v(" "),r("h2",{attrs:{id:"spring-ioc如何解决循环依赖问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#spring-ioc如何解决循环依赖问题"}},[n._v("#")]),n._v(" Spring IoC如何解决循环依赖问题？")]),n._v(" "),r("ol",[r("li",[r("p",[n._v("所谓的循环依赖，指的是两个或者两个以上的Bean互相持有对方，最终形成闭环，注入A依赖B，B依赖A等情况。")])]),n._v(" "),r("li",[r("p",[n._v("我们知道，在Spring初始化IoC容器的过程中，首先会加载xml文件和注解，并将其解析为BeanDefinition，接着会开始"),r("strong",[n._v("实例化Bean")]),n._v("，并且对Bean的依赖属性等进行填充。")])]),n._v(" "),r("li",[r("p",[n._v("在Spring中，主要有属性注入循环依赖和构造器注入循环依赖。Spring可以解决单例Bean属性注入之间的循环依赖问题，对于构造器注入以及其他原型等的属性注入的循环依赖问题会抛出异常。")])]),n._v(" "),r("li",[r("p",[n._v("Spring使用三层缓存的架构来解决属性循环依赖的问题，而所谓的三层缓存，实际上是三个map，使用它们来保存不同状态的Bean。其中，singletonObjects用作一级缓存，用于保存已经实例化、注入和初始化成功的Bean实例，这里的bean是可以直接使用的；earlySingletonObjects是二级缓存，用于存放刚刚构造（实例化）完成，但还没有进行属性填充的Bean；singletonFactories叫做所谓的三级缓存，用户保存正在创建中的Bean，此时的Bean是没有完成属性注入的。")])]),n._v(" "),r("li",[r("p",[n._v("属性注入循环依赖解决的具体步骤如下：假设A类和B类相互依赖，A中有一个B类的属性，B中有一个A类的属性。那么在初始化A的Bean时，首先会依次去一级依赖，去二级依赖，三级依赖中去找，都没有就调用创建方法创建实例A，将A添加到三级依赖中，然后对A的属性进行依赖注入，填充属性时，发现B的Bean在各级依赖中都没有，就创建B的bean添加到三级依赖，然后对B的属性进行填充，填充B的属性A时，会从三级依赖中取出A，填充完放到二级依赖，然后对B进行初始化，初始化完成添加到一级依赖。B初始化完成后，将B从一级依赖中，填充到实例A，A可以进入到二级依赖，完全初始化完成后，A进入到一级依赖，供用户代码使用。")])]),n._v(" "),r("li",[r("p",[n._v("至于为了Spring IoC为什么无法解决构造器注入循环依赖，主要原因是构造器注入是在A进行实例化过程中进行B的初始化的，但是在B初始化的时候，A还没有放入三级缓存中，所以无法完成B的初始化，导致死循环的出现。")])])]),n._v(" "),r("h2",{attrs:{id:"自动装配了解吗-resource注解用过吗"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#自动装配了解吗-resource注解用过吗"}},[n._v("#")]),n._v(" 自动装配了解吗？@Resource注解用过吗？")]),n._v(" "),r("ol",[r("li",[r("p",[n._v("常见的自动注解有@Autowired和@Resource注解，它们从Spring IoC容器中查找合适的Bean进行注入。")])]),n._v(" "),r("li",[r("p",[n._v("@Autowired注解默认是按照"),r("strong",[n._v("byType")]),n._v("方式进行自动装配，而@Resource注解则默认按照byName的方式进行自动装配。@Autowired如果需要使用"),r("strong",[n._v("byName")]),n._v("的方式进行自动装配，则需要搭配@Qualifier注解使用。")])]),n._v(" "),r("li",[r("p",[n._v("@Autowired注解能够使用在"),r("strong",[n._v("构造器")]),n._v("、方法、"),r("strong",[n._v("参数")]),n._v("、成员变量上，而@Resource能使用在"),r("strong",[n._v("类")]),n._v("、成员变量和方法上。")])])]),n._v(" "),r("h2",{attrs:{id:"介绍一下spring-aop"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下spring-aop"}},[n._v("#")]),n._v(" 介绍一下Spring AOP？")]),n._v(" "),r("ol",[r("li",[r("p",[n._v("所谓的AOP，全称是Aspect Orient Programming，从名字可以看出来，这是一种编程思想，更具体地说，是一种面向切面的编程思想。我们其实比较熟悉的是面向对象的编程思想，这种思想是将程序抽象为各个层次的对象，而面向切面编程是将程序抽象为各个切面。实际上，更通俗易懂地解释，就是AOP能够将那些与业务无关的，确为业务模块所共同调用的逻辑或责任封装起来，以达到减少系统重复代码，降低模块耦合度和易扩展的目的。")])]),n._v(" "),r("li",[r("p",[n._v("AOP通常是使用"),r("strong",[n._v("代理模式")]),n._v("来实现的，根据AOP框架修改源代码的时机，可以将其分为两类。第一类是静态AOP，这类框架在编译阶段对程序源代码进行修改，生成了静态的AOP代理类，比如AspectJ。第二类是动态AOP，这类会在运行阶段动态生成代理对象，比如Spring AOP。动态代理主要可以由JDK动态代理机制和CGLIB机制来实现。")]),n._v(" "),r("ul",[r("li",[r("p",[n._v("JDK动态代理机制中，会在运行期，目标类加载之后，为接口动态生成代理类，再将切面织入到代理类中。")])]),n._v(" "),r("li",[r("p",[n._v("CGLIB动态代理机制则会在运行期，目标类加载之后，动态生成目标类的子类，将切面逻辑加入到子类中。")])])])]),n._v(" "),r("li",[r("p",[n._v("这里再回到Spring AOP中，它有几个核心的概念，分别是切面，切点，增强以及连接点。")]),n._v(" "),r("ul",[r("li",[r("p",[n._v("切面是由切点和增强组成的，它既包含了横切逻辑的定义，也包含了连接点的定义。在Spring中，可以简单认为使用@Aspect注解的类就是切面。")])]),n._v(" "),r("li",[r("p",[n._v("连接点：连接点就是方法的执行，在Spring中，可以认为所有的方法都是连接点。")])]),n._v(" "),r("li",[r("p",[n._v("切点：切点定义了哪些方法执行是我们感兴趣的，换句话说，切点的作用是提供一组规则来匹配连接点，给满足规则的连接点添加Advice即增强。")])]),n._v(" "),r("li",[r("p",[n._v("增强Advice：是和一个切点表达式连接在一起的，会在匹配的连接点方法执行前后周围运行。")])])])])]),n._v(" "),r("h2",{attrs:{id:"spring的事务管理了解吗"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#spring的事务管理了解吗"}},[n._v("#")]),n._v(" Spring的事务管理了解吗？")]),n._v(" "),r("ol",[r("li",[r("p",[n._v("Spring中的事务主要分为两类，分别是"),r("strong",[n._v("编程式")]),n._v("的事务管理和"),r("strong",[n._v("声明式")]),n._v("的事务管理。所谓的编程式的事务管理，指的是通过使用TransactionTemplate等实现事务的控制和管理，这种是属于侵入式的事务管理。而所谓的声明式的事务管理，则是建立在AOP的基础上，本质上是对方法前后进行拦截，在目标方法之前创建或者加入一个事务，而执行方法之后根据执行情况进行提交或者回滚，这种机制通常通过@Transactional注解来实现。")])]),n._v(" "),r("li",[r("p",[n._v("编程式事务每次实现都要单独实现，但业务量大功能复杂时，使用编程式事务无疑是痛苦的，而声明式事务不同，声明式事务属于无侵入式，不会影响业务逻辑的实现，只需要在配置文件中做相关的事务规则声明或者通过注解的方式，便可以将事务规则应用到业务逻辑中。")])]),n._v(" "),r("li",[r("p",[n._v("显然声明式事务管理要优于编程式事务管理，这正是Spring倡导的非侵入式的编程方式。"),r("strong",[n._v("唯一不足的地方就是声明式事务管理的粒度是方法级别，而编程式事务管理是可以到代码块的，但是可以通过提取方法的方式完成声明式事务管理的配置。")])])])]),n._v(" "),r("h2",{attrs:{id:"spring中事务的隔离级别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#spring中事务的隔离级别"}},[n._v("#")]),n._v(" Spring中事务的隔离级别？")]),n._v(" "),r("ol",[r("li",[r("p",[n._v("Spring中的事务隔离级别主要有五类，与MYSQL中的事务隔离级别十分类似。有一个区别是他多增加了一个默认的隔离级别，这种设置会使用后端数据库默认的隔离级别。")])]),n._v(" "),r("li",[r("p",[n._v("其他的四类隔离级别与MYSQL是完全一致的，分别是读取未提交，读取已提交，可重复读以及序列化。")])])]),n._v(" "),r("h2",{attrs:{id:"spring中事务的传播机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#spring中事务的传播机制"}},[n._v("#")]),n._v(" Spring中事务的传播机制？")]),n._v(" "),r("p",[r("strong",[n._v("支持当前事务的情况：")])]),n._v(" "),r("ul",[r("li",[r("p",[n._v("**TransactionDefinition.PROPAGATION_REQUIRED：**如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。")])]),n._v(" "),r("li",[r("p",[r("strong",[n._v("TransactionDefinition.PROPAGATION_SUPPORTS："),r("strong",[n._v("如果当前存在事务，则加入该事务；如果当前没有事务，则")]),n._v("以非事务的方式继续运行")]),n._v("。")])]),n._v(" "),r("li",[r("p",[n._v("**TransactionDefinition.PROPAGATION_MANDATORY：**如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory："),r("strong",[n._v("强制性")]),n._v("）")])])]),n._v(" "),r("p",[r("strong",[n._v("不支持当前事务的情况：")])]),n._v(" "),r("ul",[r("li",[n._v("**TransactionDefinition.PROPAGATION_REQUIRES_NEW：**创建一个新的事务，如果当前存在事务，则把当前事务挂起。")]),n._v(" "),r("li",[n._v("**TransactionDefinition.PROPAGATION_NOT_SUPPORTED：**"),r("strong",[n._v("以非事务方式运行")]),n._v("，如果当前存在事务，则把当前事务挂起。")]),n._v(" "),r("li",[n._v("**TransactionDefinition.PROPAGATION_NEVER：**以非事务方式运行，如果当前存在事务，则抛出异常。")])]),n._v(" "),r("p",[r("strong",[n._v("其他情况：")])]),n._v(" "),r("ul",[r("li",[r("strong",[n._v("TransactionDefinition.PROPAGATION_NESTED：")]),n._v(" 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。")])]),n._v(" "),r("h2",{attrs:{id:"controller和-restcontroller的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#controller和-restcontroller的区别"}},[n._v("#")]),n._v(" @Controller和@RestController的区别？")]),n._v(" "),r("ol",[r("li",[r("p",[n._v("@Controller注解用于返回一个页面，使用这个注解的情况一般在返回一个视图的情况，这种属于比较传统的Spring MVC应用，对应于前后端不分离的情况。")])]),n._v(" "),r("li",[r("p",[n._v("@RestController是一个组合注解，组合了@Controller和@ResponseBody注解，这个注解只返回对象，而对象数据会以JSON的形式写入HTTP响应中，这种情况属于Restful Web服务。")])])]),n._v(" "),r("h2",{attrs:{id:"component和-bean的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#component和-bean的区别"}},[n._v("#")]),n._v(" @Component和@Bean的区别")]),n._v(" "),r("ol",[r("li",[r("p",[n._v("@Component和@Bean都是用于装配Bean的，但是它们的作用对象不同，@Component注解作用于类，而@Bean注解作用于方法。")])]),n._v(" "),r("li",[r("p",[n._v("@Component通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean，@Bean告诉了Spring这是某个类的实例，当我需要用它的时候还给我。")])])]),n._v(" "),r("h2",{attrs:{id:"spring中使用到的设计模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#spring中使用到的设计模式"}},[n._v("#")]),n._v(" Spring中使用到的设计模式？")]),n._v(" "),r("ol",[r("li",[n._v("单例模式\n"),r("ul",[r("li",[n._v("bean的作用范围：singleton")])])]),n._v(" "),r("li",[n._v("工厂方法模式\n"),r("ul",[r("li",[n._v("Spring使用工厂模式可以通过 BeanFactory 或 ApplicationContext 创建 bean 对象。")])])]),n._v(" "),r("li",[n._v("代理模式\n"),r("ul",[r("li",[n._v("Spring AOP代理")])])]),n._v(" "),r("li",[n._v("适配器模式\n"),r("ul",[r("li",[n._v("Spring AOP 的增强或通知(Advice)使用到了适配器模式")]),n._v(" "),r("li",[n._v("Spring MVC：controller")])])]),n._v(" "),r("li",[n._v("观察者模式：Spring 事件驱动模型就是观察者模式很经典的一个应用。")]),n._v(" "),r("li",[n._v("模板方法模式\n"),r("ul",[r("li",[n._v("Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。")]),n._v(" "),r("li",[n._v("模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。")])])]),n._v(" "),r("li",[n._v("装饰者模式：我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。")])]),n._v(" "),r("h2",{attrs:{id:"springboot中的-springbootapplication注解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#springboot中的-springbootapplication注解"}},[n._v("#")]),n._v(" SpringBoot中的@SpringBootApplication注解？")]),n._v(" "),r("ol",[r("li",[r("p",[n._v("@SpringBootApplication是一个组合注解，最核心的注解有三个，分别是@SpringBootConfiguration，@EnableAutoConfiguration以及@ComponentScan这几个注解。")])]),n._v(" "),r("li",[r("p",[n._v("其中，@SpringBootConfiguration 包含了Configuration注解的功能；")])]),n._v(" "),r("li",[r("p",[n._v("@EnableAutoConfiguration是开启自动装配的关键注解，其中标记了@AutoConfigurationPackage，会将被@SpringBootApplication标记的类所在的包，包装成BasePackages，然后注册到spring容器中；")])]),n._v(" "),r("li",[r("p",[n._v("@ComponentScan 定义了包扫描路径，其excludeFilters值可以用来排除类的扫描，springboot指定了TypeExcludeFilter，表明我们可以继承该类来自主定义排除的类 ；")])])]),n._v(" "),r("h2",{attrs:{id:"springboot如何处理异常"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#springboot如何处理异常"}},[n._v("#")]),n._v(" SpringBoot如何处理异常？")]),n._v(" "),r("ol",[r("li",[n._v("SpringBoot中有一个"),r("code",[n._v("@ControllerAdvice")]),n._v("的注解，使用该注解即表示开启全局异常捕获，接下来我们只需在自定义的方法上使用"),r("code",[n._v("@ExceptionHandler")]),n._v("注解，并定义捕获异常的类型，对这种类型的异常进行统一的处理。")])]),n._v(" "),r("h2",{attrs:{id:"springboot的启动流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#springboot的启动流程"}},[n._v("#")]),n._v(" SpringBoot的启动流程？")])])}),[],!1,null,null,null);i.default=t.exports}}]);