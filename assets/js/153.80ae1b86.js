(window.webpackJsonp=window.webpackJsonp||[]).push([[153],{708:function(t,_,v){"use strict";v.r(_);var a=v(14),r=Object(a.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"读写分离"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#读写分离"}},[t._v("#")]),t._v(" 读写分离")]),t._v(" "),v("p",[t._v("高并发这个阶段，肯定是需要做读写分离的，啥意思？因为实际上大部分的互联网公司，一些网站，或者是 app，其实都是读多写少。所以针对这个情况，就是写一个主库，但是主库挂多个从库，然后从多个从库来读，那不就可以支撑更高的读并发压力了吗？")]),t._v(" "),v("h2",{attrs:{id:"主从复制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主从复制"}},[t._v("#")]),t._v(" 主从复制")]),t._v(" "),v("h3",{attrs:{id:"复制的工作原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#复制的工作原理"}},[t._v("#")]),t._v(" 复制的工作原理")]),t._v(" "),v("p",[t._v("复制（replication）是MySQL数据库提供的一种高可用高性能的解决方案，一般用来建立大型的应用。总体来说，replication的工作原理。")]),t._v(" "),v("p",[t._v("分为以下3个步骤：")]),t._v(" "),v("ol",[v("li",[t._v("主服务器（master）把数据更改记录到二进制日志（binlog）中。")]),t._v(" "),v("li",[t._v("从服务器（slave）把主服务器的二进制日志复制到自己的中继日志（relay log）中。")]),t._v(" "),v("li",[t._v("从服务器重做中继日志中的日志，把更改应用到自己的数据库上，以达到数据的最终一致性。")])]),t._v(" "),v("p",[t._v("复制的工作原理并不复杂，其实就是一个完全备份加上二进制日志备份的还原。不同的是这个二进制日志的还原操作基本上实时在进行中。"),v("strong",[t._v("这里特别需要注意的是，复制不是完全实时地进行同步，而是异步实时。这中间存在主从服务器之间的执行延时，如果主服务器的压力很大，则可能导致主从服务器延时较大。")])]),t._v(" "),v("p",[t._v("**从服务器有2个线程，一个是I/O线程，负责读取主服务器的二进制日志，并将其保存为中继日志；另一个是SQL线程，复制执行中继日志。**MySQL4.0版本之前，从服务器只有1个线程，既负责读取二进制日志，又负责执行二进制日志中的SQL语句。这种方式不符合高性能的要求，目前已淘汰。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202204042005801.png",alt:"img"}})]),t._v(" "),v("h3",{attrs:{id:"复制模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#复制模式"}},[t._v("#")]),t._v(" 复制模式")]),t._v(" "),v("h5",{attrs:{id:"异步模式-默认的模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#异步模式-默认的模式"}},[t._v("#")]),t._v(" 异步模式（默认的模式）")]),t._v(" "),v("p",[t._v("主节点不会主动push bin log给从节点，也不会管从节点的同步情况，默认就是这种模式。")]),t._v(" "),v("h5",{attrs:{id:"半同步模式-mysql-5-5之后提供"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#半同步模式-mysql-5-5之后提供"}},[t._v("#")]),t._v(" 半同步模式（MySQL 5.5之后提供）")]),t._v(" "),v("p",[t._v("主节点给从节点发送bin log 之后，会一直等待回应，只要一个从节点接受bin log，并且写入relay log 成功，给主节点返回接受成功的ACK信息，主节点就认为成功，提交事务。")]),t._v(" "),v("h5",{attrs:{id:"全同步模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#全同步模式"}},[t._v("#")]),t._v(" 全同步模式")]),t._v(" "),v("p",[t._v("就是需要所有的从节点接受日志，并且写入relay log 成功，给主节点返回接受成功的ACK信息，主节点才认为成功，提交事务。")]),t._v(" "),v("h3",{attrs:{id:"快照-复制的备份架构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#快照-复制的备份架构"}},[t._v("#")]),t._v(" 快照+复制的备份架构")]),t._v(" "),v("p",[t._v("复制可以用来作为备份，但功能不仅限于备份，其主要功能如下：")]),t._v(" "),v("ul",[v("li",[t._v("数据分布。由于MySQL数据库提供的复制并不需要很大的带宽要求，因此可以在不同的数据中心之间实现数据的复制。")]),t._v(" "),v("li",[t._v("读取的负载平衡。通过建立多个从服务器，可将读取平均地分布到这些从服务器中，并且减少了主服务器的压力。一般通过DNS的Round-Robin和Linux的LVS功能都可以实现负载平衡。")]),t._v(" "),v("li",[t._v("数据库备份。复制对备份很有帮助，但是从服务器不是备份，不能完全代替备份。")]),t._v(" "),v("li",[t._v("高可用性和故障转移。通过复制建立的从服务器有助于故障转移，减少故障的停机时间和恢复时间。")])]),t._v(" "),v("p",[t._v("可见，复制的设计不是简简单单用来备份的，并且只是用复制来进行备份是远远不够的。假设当前应用采用了主从的复制架构，从服务器作为备份。这时，一个初级DBA执行了误操作，如DROP DATABASE或DROP TABLE，这时从服务器也跟着运行了。这时用户怎样从服务器进行恢复呢？")]),t._v(" "),v("p",[t._v("因此，一个比较好的方法是通过对从服务器上的数据库所在分区做快照，以此来避免误操作对复制造成影响。当发生主服务器上的误操作时，只需要将从服务器上的快照进行恢复，然后再根据二进制日志进行point-in-time的恢复即可。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202204042005374.png",alt:"img"}})]),t._v(" "),v("h2",{attrs:{id:"相关问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#相关问题"}},[t._v("#")]),t._v(" 相关问题")]),t._v(" "),v("h3",{attrs:{id:"主从同步延迟问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主从同步延迟问题"}},[t._v("#")]),t._v(" 主从同步延迟问题")]),t._v(" "),v("p",[t._v("这里有一个非常重要的一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行 SQL 的特点，在高并发场景下，从库的数据一定会比主库慢一些，是"),v("strong",[t._v("有延时")]),t._v("的。==所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。==")]),t._v(" "),v("p",[t._v("而且这里还有另外一个问题，就是==如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。==")]),t._v(" "),v("p",[t._v("所以 MySQL 实际上在这一块有两个机制，一个是"),v("strong",[t._v("半同步复制")]),t._v("，用来解决主库数据丢失问题；")]),t._v(" "),v("p",[t._v("这个所谓"),v("strong",[t._v("半同步复制")]),t._v("，也叫 "),v("code",[t._v("semi-sync")]),t._v(" 复制，指的就是主库写入 binlog 日志之后，就会将"),v("strong",[t._v("强制")]),t._v("此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到"),v("strong",[t._v("至少一个从库")]),t._v("的 ack 之后才会认为写操作完成了。")]),t._v(" "),v("p",[t._v("一般来说，如果"),v("strong",[t._v("主从延迟较为严重")]),t._v("，有以下解决方案：")]),t._v(" "),v("ul",[v("li",[t._v("分库，将一个主库拆分为多个主库，每个主库的写并发就减少了几倍，此时主从延迟可以忽略不计。")]),t._v(" "),v("li",[t._v("打开 MySQL 支持的并行复制，多个库并行复制。如果说某个库的写入并发就是特别高，单库写并发达到了 2000/s，并行复制还是没意义。")]),t._v(" "),v("li",[t._v("重写代码，写代码的同学，要慎重，插入数据时立马查询可能查不到。")]),t._v(" "),v("li",[t._v("如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询"),v("strong",[t._v("设置直连主库")]),t._v("。"),v("strong",[t._v("不推荐")]),t._v("这种方法，你要是这么搞，读写分离的意义就丧失了。")])])])}),[],!1,null,null,null);_.default=r.exports}}]);