(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{573:function(t,a,s){"use strict";s.r(a);var n=s(14),v=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"编译概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编译概述"}},[t._v("#")]),t._v(" 编译概述")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231530180.png",alt:"img"}})]),t._v(" "),s("h2",{attrs:{id:"前端编译器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前端编译器"}},[t._v("#")]),t._v(" 前端编译器")]),t._v(" "),s("p",[t._v("前端编译器（叫“编译器的前端”更准确一些）把_.java文件转变成_.class文件。")]),t._v(" "),s("h2",{attrs:{id:"即时编译器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#即时编译器"}},[t._v("#")]),t._v(" 即时编译器")]),t._v(" "),s("p",[t._v("Java虚拟机的即时编译器（常称JIT编译器，Just In Time Compiler）"),s("strong",[t._v("运行期把字节码转变成本地机器码")])]),t._v(" "),s("h2",{attrs:{id:"提前编译器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#提前编译器"}},[t._v("#")]),t._v(" 提前编译器")]),t._v(" "),s("p",[t._v("静态的提前编译器（常称AOT编译器，Ahead Of Time Compiler）"),s("strong",[t._v("直接把程序编译成与目标机器指令集相关的二进制代码")])]),t._v(" "),s("h1",{attrs:{id:"前端编译器-javac"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前端编译器-javac"}},[t._v("#")]),t._v(" 前端编译器（Javac）")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("Javac编译器不像HotSpot虚拟机那样使用C++语言（包含少量C语言）实现，它本身就是一个"),s("strong",[t._v("由Java语言编写的程序")]),t._v("。")])]),t._v(" "),s("li",[s("p",[t._v("在前端编译器中，“优化”手段主要用于提升程序的编码效率，之所以把Javac这类将Java代码转变为字节码的编译器称作“前端编译器”，是因为"),s("strong",[t._v("它只完成了从程序到抽象语法树或中间字节码的生成")]),t._v("，而在此之后，还有一组内置于Java虚拟机内部的“后端编译器”来完成代码优化以及从字节码生成本地机器码的过程，即前面多次提到的即时编译器或提前编译器，这个后端编译器的编译速度及编译结果质量高低，是衡量Java虚拟机性能最重要的一个指标。")])])]),t._v(" "),s("h2",{attrs:{id:"javac的编译过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javac的编译过程"}},[t._v("#")]),t._v(" Javac的编译过程")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("准备过程：初始化插入式注解处理器。")])]),t._v(" "),s("li",[s("p",[t._v("解析与填充符号表过程，包括：")]),t._v(" "),s("ol",[s("li",[s("p",[s("strong",[t._v("词法、语法分析")]),t._v("。将源代码的字符流转变为标记集合，构造出抽象语法树（AST）。")])]),t._v(" "),s("li",[s("p",[t._v("填充符号表。"),s("strong",[t._v("产生符号地址和符号信息。")])]),t._v(" "),s("ol",[s("li",[t._v("如果用户代码中没有提供任何构造函数，那编译器将会添加一个没有参数的、可访问性（public、protected、private或<package>）与当前类型一致的默认构造函数。")])])])])]),t._v(" "),s("li",[s("p",[t._v("插入式注解处理器的"),s("strong",[t._v("注解处理")]),t._v("过程：插入式注解处理器的执行阶段。")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("执行插入式注解时又可能会产生新的符号，如果有新的符号产生，就必须转回到之前的解析、填充符号表的过程中重新处理这些新符号。")])]),t._v(" "),s("li",[s("p",[t._v("譬如Java著名的编码效率工具"),s("strong",[t._v("Lombok")]),t._v("[2]，它可以通过注解来实现自动产生getter/setter方法、进行空置检查、生成受查异常表、产生equals()和hashCode()方法，等等，帮助开发人员消除Java的冗长代码，这些都是依赖插入式注解处理器来实现的。")])])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("语义分析与字节码生成")]),t._v("过程，包括：")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("标注检查。"),s("strong",[t._v("对语法的静态信息进行检查。")])])]),t._v(" "),s("li",[s("p",[t._v("数据流及控制流分析。对程序动态运行过程进行检查。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("解语法糖")]),t._v("。将简化代码编写的语法糖还原为原有的形式。（"),s("strong",[t._v("泛型")]),t._v("、变长参数、foreach循环遍历、自动装箱拆箱、内部类、枚举类、断言语句、数值字面量、对枚举和字符串的switch支持、try语句中定义和关闭资源等语法糖）")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("泛型的本质是参数化类型（Parameterized Type）或者参数化多态（Parametric Polymorphism）的应用，即可以"),s("strong",[t._v("将操作的数据类型指定为方法签名中的一种特殊参数，这种参数类型能够用在类、接口和方法的创建中")]),t._v("，分别构成泛型类、泛型接口和泛型方法。")])]),t._v(" "),s("li",[s("p",[t._v("泛型又叫做"),s("strong",[t._v("类型擦除式泛型")]),t._v("，它只在程序源码中存在，在编译后的字节码文件中，全部泛型都被替换为原来的裸类型（Raw Type）了，并且在相应的地方插入了强制转型代码，因此对于运行期的Java语言来说，ArrayList<int>与ArrayList<String>其实是同一个类型。")])]),t._v(" "),s("li",[s("p",[t._v("变长参数，它在调用的时候变成了一个数组类型的参数，在变长参数出现之前，程序员的确也就是使用数组来完成类似功能的。")])]),t._v(" "),s("li",[s("p",[t._v("遍历循环则是把代码还原成了迭代器的实现，这也是为何遍历循环需要被遍历的类实现Iterable接口的原因。")])])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("字节码生成")]),t._v("。将前面各个步骤所生成的信息转化成字节码。")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码指令写到磁盘中，编译器还进行了少量的代码添加和转换工作。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("例如前文多次登场的实例构造器<init>()方法和类构造器<clinit>()方法就是在这个阶段被添加到语法树之中的。")]),t._v("<init>()和<clinit>()这两个构造器的产生实际上是一种代码收敛的过程，编译器会把语句块（对于实例构造器而言是“{}”块，对于类构造器而言是“static{}”块）、变量初始化（实例变量和类变量）、调用父类的实例构造器（仅仅是实例构造器，<clinit>()方法中无须调用父类的<clinit>()方法，Java虚拟机会自动保证父类构造器的正确执行，但在<clinit>()方法中经常会生成调用java.lang.Object的<init>()方法的代码）"),s("strong",[t._v("等操作收敛到<init>()和<clinit>()方法之中，并且保证无论源码中出现的顺序如何，都一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序进行")]),t._v("，上面所述的动作由Gen::normalizeDefs()方法来实现。")])]),t._v(" "),s("li",[s("p",[t._v("除了生成构造器以外，还有其他的一些代码替换工作用于优化程序某些逻辑的实现方式，如"),s("strong",[t._v("把字符串的加操作替换为StringBuffer或StringBuilder")]),t._v("（取决于目标代码的版本是否大于或等于JDK 5）的append()操作，等等。")])])])])])])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231530604.png",alt:"img"}})]),t._v(" "),s("h2",{attrs:{id:"语法糖"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#语法糖"}},[t._v("#")]),t._v(" 语法糖")]),t._v(" "),s("h3",{attrs:{id:"包装类型的自动装箱与拆箱"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#包装类型的自动装箱与拆箱"}},[t._v("#")]),t._v(" 包装类型的自动装箱与拆箱")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("包装类型有常量池，用来存放使用最频繁的一些整数，比如Integer常量池存有-128~127的整数，超出的部分会使用new新建一个Integer实例。")])]),t._v(" "),s("li",[s("p",[t._v("包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱。")])]),t._v(" "),s("li",[s("p",[t._v("基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会"),s("strong",[t._v("自动拆箱")]),t._v("变为基本型后再进行比较。")])]),t._v(" "),s("li",[s("p",[t._v("两个Integer对象进行“==”比较时，如果有一方的Integer对象是new获得的，返回false,因为比较的是两个对象的地址。")])]),t._v(" "),s("li",[s("p",[t._v("两个包装类型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true，否则返回false。")])]),t._v(" "),s("li",[s("p",[t._v("包装类型调用equals()，但是参数是基本类型，这时候，先会进行"),s("strong",[t._v("自动装箱")]),t._v("，基本型转换为其封装类型，若类型不同返回false，若装箱后类型相同，则比较值，如果值相同，则返回true，否则返回false。")])])]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * @Author WaleGarrett\n * @Date 2021/11/10 19:42\n */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TestInteger")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),t._v(" b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),t._v(" c "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),t._v(" d "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),t._v(" e "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("321")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Integer常量池的大小是-128~127，超出的会进行new")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),t._v(" f "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("321")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Integer常量池的大小是-128~127，超出的会进行new")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Long")]),t._v(" g "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3L")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("c "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" d"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("e "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" f"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// false")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("c "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("equals")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("g "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("g"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("equals")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//false")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h1",{attrs:{id:"后端编译器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#后端编译器"}},[t._v("#")]),t._v(" 后端编译器")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("如果我们把字节码看作是程序语言的一种中间表示形式（Intermediate Representation，IR）的话，那编译器无论在何时、在何种状态下"),s("strong",[t._v("把Class文件转换成与本地基础设施（硬件指令集、操作系统）相关的二进制机器码")]),t._v("，它都可以视为整个编译过程的后端。")])]),t._v(" "),s("li",[s("p",[t._v("无论是提前编译器抑或即时编译器，都不是Java虚拟机必需的组成部分，《Java虚拟机规范》中从来没有规定过虚拟机内部必须要包含这些编译器，更没有限定或指导这些编译器应该如何去实现。但是，后端编译器编译性能的好坏、代码优化质量的高低却是衡量一款商用虚拟机优秀与否的关键指标之一，它们也是商业Java虚拟机中的核心，是最能体现技术水平与价值的功能。")])])]),t._v(" "),s("h2",{attrs:{id:"即时编译器-jit"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#即时编译器-jit"}},[t._v("#")]),t._v(" 即时编译器-JIT")]),t._v(" "),s("ol",[s("li",[t._v("目前主流的两款商用Java虚拟机（HotSpot、OpenJ9）里，Java程序"),s("strong",[t._v("最初")]),t._v("都是通过"),s("strong",[t._v("解释器（Interpreter）进行解释执行的")]),t._v("，"),s("strong",[t._v("当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为“热点代码”（Hot Spot Code），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成本地机器码，并以各种手段尽可能地进行代码优化")]),t._v("，运行时完成这个任务的后端编译器被称为"),s("strong",[t._v("即时编译器")]),t._v("。")])]),t._v(" "),s("h3",{attrs:{id:"为何hotspot虚拟机要使用解释器与即时编译器并存的架构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为何hotspot虚拟机要使用解释器与即时编译器并存的架构"}},[t._v("#")]),t._v(" 为何HotSpot虚拟机要使用解释器与即时编译器并存的架构？")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("解释器与编译器两者各有优势：当程序需要"),s("strong",[t._v("迅速启动和执行")]),t._v("的时候，解释器可以首先发挥作用，省去编译的时间，立即运行。当程序启动后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以"),s("strong",[t._v("减少解释器的中间损耗，获得更高的执行效率")]),t._v("。")])]),t._v(" "),s("li",[s("p",[t._v("当程序运行环境中内存资源限制较大，可以"),s("strong",[t._v("使用解释执行节约内存")]),t._v("（如部分嵌入式系统中和大部分的JavaCard应用中就只有解释器的存在），反之可以使用编译执行来提升效率。")])]),t._v(" "),s("li",[s("p",[t._v("同时，"),s("strong",[t._v("解释器还可以作为编译器激进优化时后备的“逃生门”")]),t._v("（如果情况允许，HotSpot虚拟机中也会采用不进行激进优化的客户端编译器充当“逃生门”的角色），让编译器根据概率选择一些不能保证所有情况都正确，但大多数时候都能提升运行速度的优化手段，"),s("strong",[t._v("当激进优化的假设不成立，如加载了新类以后，类型继承结构出现变化、出现“罕见陷阱”（Uncommon Trap）时可以通过逆优化（Deoptimization）退回到解释状态继续执行")]),t._v("，因此在整个Java虚拟机执行架构里，解释器与编译器经常是相辅相成地配合工作。")])])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231530675.png",alt:"img"}})]),t._v(" "),s("h3",{attrs:{id:"为何hotspot虚拟机要实现两个-或三个-不同的即时编译器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为何hotspot虚拟机要实现两个-或三个-不同的即时编译器"}},[t._v("#")]),t._v(" 为何HotSpot虚拟机要实现两个（或三个）不同的即时编译器？")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("由于即时编译器编译本地代码需要占用程序运行时间，通常要编译出优化程度越高的代码，所花费的时间便会越长；而且想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，这对解释执行阶段的速度也有所影响。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot虚拟机在编译子系统中加入了分层编译的功能")]),t._v("，分层编译的概念其实很早就已经提出，但直到JDK 6时期才被初步实现，后来一直处于改进阶段，最终在JDK 7的服务端模式虚拟机中作为默认编译策略被开启。分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次。")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("第0层。程序纯解释执行，并且解释器不开启性能监控功能（Profiling）。")])]),t._v(" "),s("li",[s("p",[t._v("第1层。使用"),s("strong",[t._v("客户端编译器")]),t._v("将字节码编译为本地代码来运行，进行简单可靠的稳定优化，不开启性能监控功能。")])]),t._v(" "),s("li",[s("p",[t._v("第2层。仍然使用"),s("strong",[t._v("客户端编译器")]),t._v("执行，仅开启方法及回边次数统计等有限的性能监控功能。")])]),t._v(" "),s("li",[s("p",[t._v("第3层。仍然使用"),s("strong",[t._v("客户端编译器")]),t._v("执行，开启全部性能监控，除了第2层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部的统计信息。")])]),t._v(" "),s("li",[s("p",[t._v("第4层。使用"),s("strong",[t._v("服务端编译器")]),t._v("将字节码编译为本地代码，相比起客户端编译器，服务端编译器会启用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化。")])])])]),t._v(" "),s("li",[s("p",[t._v("实施分层编译后，解释器、客户端编译器和服务端编译器就会同时工作，热点代码都可能会被多次编译，"),s("strong",[t._v("用客户端编译器获取更高的编译速度，用服务端编译器来获取更好的编译质量")]),t._v("，在解释执行的时候也无须额外承担收集性能监控信息的任务，而在服务端编译器采用高复杂度的优化算法时，客户端编译器可先采用简单优化来为它争取更多的编译时间。")])])]),t._v(" "),s("h3",{attrs:{id:"哪些程序代码会被编译为本地代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#哪些程序代码会被编译为本地代码"}},[t._v("#")]),t._v(" 哪些程序代码会被编译为本地代码？")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("在运行过程中会被即时编译器编译的目标是“"),s("strong",[t._v("热点代码")]),t._v("”，这里所指的热点代码主要有两类，包括：")]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("被多次调用的方法。")])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("被多次执行的循环体。")])])])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("对于这两种情况，编译的目标对象都是整个方法体，而不会是单独的循环体。")])]),t._v(" "),s("ol",[s("li",[s("p",[t._v("第一种情况，由于是依靠方法调用触发的编译，那编译器理所当然地会以整个方法作为编译对象，这种编译也是虚拟机中标准的即时编译方式。")])]),t._v(" "),s("li",[s("p",[t._v("而对于后一种情况，尽管编译动作是由循环体所触发的，热点只是方法的一部分，但编译器依然必须以整个方法作为编译对象，只是执行入口（从方法第几条字节码指令开始执行）会稍有不同，编译时会传入执行入口点字节码序号（Byte Code Index，BCI）。")])])])])]),t._v(" "),s("h3",{attrs:{id:"即时编译被触发的条件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#即时编译被触发的条件"}},[t._v("#")]),t._v(" 即时编译被触发的条件？")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("在上面的描述里，无论是“多次执行的方法”，还是“多次执行的代码块”，所谓“多次”只定性不定量，并不是一个具体严谨的用语，那到底多少次才算“多次”呢？还有一个问题，就是Java虚拟机是如何统计某个方法或某段代码被执行过多少次的呢？"),s("strong",[t._v("即时编译被触发的条件？")])])]),t._v(" "),s("li",[s("p",[t._v("要知道某段代码是不是热点代码，是不是需要触发即时编译，这个行为称为“热点探测”（HotSpot Code Detection）。")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("基于采样的热点探测（Sample Based Hot Spot Code Detection）。采用这种方法的虚拟机会周期性地检查各个线程的调用栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”。基于采样的热点探测的好处是实现简单高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可），缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。")])]),t._v(" "),s("li",[s("p",[t._v("基于计数器的热点探测（Counter Based Hot Spot Code Detection）。采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是“热点方法”。这种统计方法实现起来要麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系。但是它的统计结果相对来说更加精确严谨。"),s("strong",[t._v("在HotSpot虚拟机中使用的是第二种基于计数器的热点探测方法。")])])])])])]),t._v(" "),s("h3",{attrs:{id:"即时编译的过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#即时编译的过程"}},[t._v("#")]),t._v(" 即时编译的过程？")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("在默认条件下，无论是方法调用产生的标准编译请求，还是栈上替换编译请求，虚拟机在编译器还未完成编译之前，都仍然将按照解释方式继续执行代码，而编译动作则在后台的编译线程中进行。")])]),t._v(" "),s("li",[s("p",[t._v("那在后台执行编译的过程中，编译器具体会做什么事情呢？服务端编译器和客户端编译器的编译过程是有所差别的。"),s("strong",[t._v("对于客户端编译器来说，它是一个相对简单快速的三段式编译器，主要的关注点在于局部性的优化，而放弃了许多耗时较长的全局优化手段。")])])])]),t._v(" "),s("h4",{attrs:{id:"客户端编译过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#客户端编译过程"}},[t._v("#")]),t._v(" 客户端编译过程")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("在第一个阶段，一个平台独立的前端"),s("strong",[t._v("将字节码构造成一种高级中间代码表示")]),t._v("（High-Level Intermediate Representation，HIR，即与目标机器指令集无关的中间表示）。HIR使用静态单分配（Static Single Assignment，SSA）的形式来代表代码值，这可以使得一些在HIR的构造过程之中和之后进行的优化动作更容易实现。在此之前编译器已经会在字节码上完成一部分基础优化，如方法内联、常量传播等优化将会在字节码被构造成HIR之前完成。")])]),t._v(" "),s("li",[s("p",[t._v("在第二个阶段，一个平台相关的后端"),s("strong",[t._v("从HIR中产生低级中间代码表示")]),t._v("（Low-Level Intermediate Representation，LIR，即与目标机器指令集相关的中间表示），而在此之前会在HIR上完成另外一些优化，如空值检查消除、范围检查消除等，以便让HIR达到更高效的代码表示形式。")])]),t._v(" "),s("li",[s("p",[t._v("最后的阶段是在平台相关的后端使用线性扫描算法（Linear Scan Register Allocation）在LIR上分配寄存器，并在LIR上做窥孔（Peephole）优化，然后产生机器代码。")])])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://walegarrett-image-1304556108.cos.ap-chengdu.myqcloud.com/markdown_img/202203231530625.png",alt:"img"}})]),t._v(" "),s("h4",{attrs:{id:"服务器端编译过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务器端编译过程"}},[t._v("#")]),t._v(" 服务器端编译过程")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("服务端编译器则是专门面向服务端的典型应用场景，并为服务端的性能配置针对性调整过的编译器，也是一个能容忍很高优化复杂度的高级编译器。")])]),t._v(" "),s("li",[s("p",[t._v("另外，还可能根据解释器或客户端编译器提供的性能监控信息，进行一些不稳定的预测性激进优化，如守护内联（Guarded Inlining）、分支频率预测（Branch Frequency Prediction）等。")])]),t._v(" "),s("li",[s("p",[t._v("以即时编译的标准来看，服务端编译器无疑是比较缓慢的，但"),s("strong",[t._v("它的编译速度依然远远超过传统的静态优化编译器，而且它相对于客户端编译器编译输出的代码质量有很大提高，可以大幅减少本地代码的执行时间")]),t._v("，从而抵消掉额外的编译时间开销，所以也有很多非服务端的应用选择使用服务端模式的HotSpot虚拟机来运行。")])])]),t._v(" "),s("h2",{attrs:{id:"提前编译器-aot"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#提前编译器-aot"}},[t._v("#")]),t._v(" 提前编译器-AOT")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("现在提前编译产品和对其的研究有着两条明显的分支，一条分支是做与传统C、C++编译器类似的，"),s("strong",[t._v("在程序运行之前把程序代码编译成机器码的静态翻译工作")]),t._v("；")])]),t._v(" "),s("li",[s("p",[t._v("另外一条分支是"),s("strong",[t._v("把原本即时编译器在运行时要做的编译工作****提前做好并保存下来，下次运行到这些代码（譬如公共库代码在被同一台机器其他Java进程使用）时直接把它加载进来使用")]),t._v("。")])])]),t._v(" "),s("h3",{attrs:{id:"传统的提前编译应用形式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#传统的提前编译应用形式"}},[t._v("#")]),t._v(" 传统的提前编译应用形式")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("传统的提前编译应用形式，它在Java中存在的价值直指即时编译的最大弱点："),s("strong",[t._v("即时编译要占用程序运行时间和运算资源")]),t._v("。")])]),t._v(" "),s("li",[s("p",[t._v("即使现在先进的即时编译器已经足够快，以至于能够容忍相当高的优化复杂度了；即使现在先进的即时编译器架构有了分层编译的支持，可以先用快速但低质量的即时编译器为高质量的即时编译器争取出更多编译时间，"),s("strong",[t._v("但是，无论如何，即时编译消耗的时间都是原本可用于程序运行的时间，消耗的运算资源都是原本可用于程序运行的资源，这个约束从未减弱，更不会消失，始终是悬在即时编译头顶的****达摩克利斯之剑。")])])])]),t._v(" "),s("h3",{attrs:{id:"提前编译第二种应用形式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#提前编译第二种应用形式"}},[t._v("#")]),t._v(" 提前编译第二种应用形式")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("关于提前编译的第二条路径，本质是给即时编译器做缓存加速，去改善Java程序的启动时间，以及需要一段时间预热后才能到达最高性能的问题。")])]),t._v(" "),s("li",[s("p",[t._v("这种提前编译被称为动态提前编译（Dynamic AOT）或者索性就大大方方地直接叫即时编译缓存（JIT Caching）。在目前的Java技术体系里，这条路径的提前编译已经完全被主流的商用JDK支持。")])]),t._v(" "),s("li",[s("p",[t._v("hotSpot运行时可以直接加载这些编译的结果，实现加快程序启动速度，减少程序达到全速运行状态所需时间的目的。这里面确实有比较大的优化价值，试想一下，各种Java应用最起码会用到Java的标准类库，如java.base等模块，"),s("strong",[t._v("如果能够将这个类库提前编译好，并进行比较高质量的优化，显然能够节约不少应用运行时的编译成本。")])])]),t._v(" "),s("li",[s("p",[t._v("在此要说明的是，这的确是很好的想法，但实际应用起来并不是那么容易，原因是这种提前编译方式不仅要和目标机器相关，甚至还必须与HotSpot虚拟机的运行时参数绑定。譬如虚拟机运行时采用了不同的垃圾收集器，这原本就需要即时编译子系统的配合（典型的如生成内存屏障代码）才能正确工作，要做提前编译的话，自然也要把这些配合的工作平移过去。")])])]),t._v(" "),s("h2",{attrs:{id:"即时编译器相对于提前编译器的优点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#即时编译器相对于提前编译器的优点"}},[t._v("#")]),t._v(" 即时编译器相对于提前编译器的优点")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("首先，是性能分析制导优化（Profile-Guided Optimization，PGO）。上一节介绍HotSpot的即时编译器时就多次提及在解释器或者客户端编译器运行过程中，会**不断收集性能监控信息，譬如某个程序点抽象类通常会是什么实际类型、条件判断通常会走哪条分支、方法调用通常会选择哪个版本、循环通常会进行多少次等，这些数据一般在静态分析时是无法得到的，或者不可能存在确定且唯一的解，最多只能依照一些启发性的条件去进行猜测。**但在动态运行时却能看出它们具有非常明显的偏好性。如果一个条件分支的某一条路径执行特别频繁，而其他路径鲜有问津，那就可以把热的代码集中放到一起，集中优化和分配更好的资源（分支预测、寄存器、缓存等）给它。")])]),t._v(" "),s("li",[s("p",[t._v("其次，是激进预测性优化（Aggressive Speculative Optimization），这也已经成为很多即时编译优化措施的基础。**静态优化无论如何都必须保证优化后所有的程序外部可见影响（不仅仅是执行结果）与优化前是等效的，不然优化之后会导致程序报错或者结果不对，若出现这种情况，则速度再快也是没有价值的。**然而，相对于提前编译来说，即时编译的策略就可以不必这样保守，如果性能监控信息能够支持它做出一些正确的可能性很大但无法保证绝对正确的预测判断，就已经可以大胆地按照高概率的假设进行优化，**万一真的走到罕见分支上，大不了退回到低级编译器甚至解释器上去执行，并不会出现无法挽救的后果。**只要出错概率足够低，这样的优化往往能够大幅度降低目标程序的复杂度，输出运行速度非常高的代码。譬如在Java语言中，默认方法都是虚方法调用，部分C、C++程序员（甚至一些老旧教材）会说虚方法是不能内联的，但如果Java虚拟机真的遇到虚方法就去查虚表而不做内联的话，Java技术可能就已经因性能问题而被淘汰很多年了。实际上虚拟机会通过类继承关系分析等一系列激进的猜测去做去虚拟化（Devitalization），以保证绝大部分有内联价值的虚方法都可以顺利内联。")])]),t._v(" "),s("li",[s("p",[t._v("最后，是链接时优化（Link-Time Optimization，LTO），Java语言天生就是动态链接的，一个个Class文件在运行期被加载到虚拟机内存当中，然后在即时编译器里产生优化后的本地代码，这类事情在Java程序员眼里看起来毫无违和之处。但如果类似的场景出现在使用提前编译的语言和程序上，譬如C、C++的程序要调用某个动态链接库的某个方法，就会出现很明显的边界隔阂，还难以优化。这是因为主程序与动态链接库的代码在它们编译时是完全独立的，两者各自编译、优化自己的代码。这些代码的作者、编译的时间，以及编译器甚至很可能都是不同的，当出现跨链接库边界的调用时，那些理论上应该要做的优化——譬如做对调用方法的内联，就会执行起来相当的困难。如果刚才说的虚方法内联让C、C++程序员理解还算比较能够接受的话（其实C++编译器也可以通过一些技巧来做到虚方法内联），那这种跨越动态链接库的方法内联在他们眼里可能就近乎于离经叛道了（但实际上依然是可行的）。")])])]),t._v(" "),s("h1",{attrs:{id:"编译器优化技术"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编译器优化技术"}},[t._v("#")]),t._v(" 编译器优化技术")]),t._v(" "),s("h2",{attrs:{id:"方法内联"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#方法内联"}},[t._v("#")]),t._v(" 方法内联")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("内联被业内戏称为优化之母，因为除了消除方法调用的成本之外，它更重要的意义是为其他优化手段建立良好的基础，内联对其他优化手段的巨大价值：没有内联，多数其他优化都无法有效进行。")])]),t._v(" "),s("li",[s("p",[t._v("方法内联的优化行为理解起来是没有任何困难的，**不过就是把目标方法的代码原封不动地“复制”到发起调用的方法之中，避免发生真实的方法调用而已。**但实际上Java虚拟机中的内联过程却远没有想象中容易，甚至如果不是即时编译器做了一些特殊的努力，按照经典编译原理的优化理论，大多数的Java方法都无法进行内联。")])]),t._v(" "),s("li",[s("p",[t._v("无法内联的原因其实在讲解Java方法解析和分派调用的时候就已经解释过："),s("strong",[t._v("只有使用invokespecial指令调用的私有方法、实例构造器、父类方法和使用invokestatic指令调用的静态方法才会在编译期进行解析")]),t._v("。除了上述四种方法之外（最多再除去被final修饰的方法这种特殊情况，尽管它使用invokevirtual指令调用，但也是非虚方法，《Java语言规范》中明确说明了这点），其他的Java方法调用都必须在运行时进行方法接收者的多态选择，它们都有可能存在多于一个版本的方法接收者，简而言之，Java语言中默认的实例方法是虚方法。")])]),t._v(" "),s("li",[s("p",[t._v("对于一个虚方法，编译器静态地去做内联的时候很难确定应该使用哪个方法版本，如果不依赖上下文，是无法确定b的实际类型是什么的。假如有ParentB和SubB是两个具有继承关系的父子类型，并且子类重写了父类的get()方法，那么b.get()是执行父类的get()方法还是子类的get()方法，这应该是根据实际类型动态分派的，而实际类型必须在实际运行到这一行代码时才能确定，编译器很难在编译时得出绝对准确的结论。")])]),t._v(" "),s("li",[s("p",[t._v("为了解决虚方法的内联问题，Java虚拟机首先引入了一种名为"),s("strong",[t._v("类型继承关系分析")]),t._v("（Class Hierarchy Analysis，CHA）的技术，这是整个应用程序范围内的类型分析技术，用于确定在目前已加载的类中，某个接口是否有多于一种的实现、某个类是否存在子类、某个子类是否覆盖了父类的某个虚方法等信息。这样，编译器在进行内联时就会分不同情况采取不同的处理：**如果是非虚方法，那么直接进行内联就可以了，这种的内联是有百分百安全保障的；如果遇到虚方法，则会向CHA查询此方法在当前程序状态下是否真的有多个目标版本可供选择，如果查询到只有一个版本，那就可以假设“应用程序的全貌就是现在运行的这个样子”来进行内联，这种内联被称为守护内联（Guarded Inlining）。不过由于Java程序是动态连接的，说不准什么时候就会加载到新的类型从而改变CHA结论，因此这种内联属于激进预测性优化，必须预留好“逃生门”，即当假设条件不成立时的“退路”（Slow Path）。**假如在程序的后续执行过程中，虚拟机一直没有加载到会令这个方法的接收者的继承关系发生变化的类，那这个内联优化的代码就可以一直使用下去。"),s("strong",[t._v("如果加载了导致继承关系发生变化的新类，那么就必须抛弃已经编译的代码，退回到解释状态进行执行，或者重新进行编译。")])])]),t._v(" "),s("li",[s("p",[t._v("所以说，在多数情况下Java虚拟机进行的方法内联都是一种激进优化。事实上，激进优化的应用在高性能的Java虚拟机中比比皆是，极为常见。除了方法内联之外，对于出现概率很小（通过经验数据或解释器收集到的性能监控信息确定概率大小）的隐式异常、使用概率很小的分支等都可以被激进优化“移除”，如果真的出现了小概率事件，这时才会从“逃生门”回到解释状态重新执行。")])])]),t._v(" "),s("h2",{attrs:{id:"逃逸分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#逃逸分析"}},[t._v("#")]),t._v(" 逃逸分析")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("逃逸分析（Escape Analysis）是目前Java虚拟机中比较前沿的优化技术，它与类型继承关系分析一样，并不是直接优化代码的手段，而是为其他优化措施提供依据的分析技术。")])]),t._v(" "),s("li",[s("p",[t._v("逃逸分析的基本原理是：分析对象动态作用域，"),s("strong",[t._v("当一个对象在方法里面被定义后，它可能被外部方法所引用")]),t._v("，例如作为调用参数传递到其他方法中，这种称为方法逃逸；"),s("strong",[t._v("甚至还有可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量")]),t._v("，这种称为线程逃逸；从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。")])]),t._v(" "),s("li",[s("p",[t._v("如果能证明一个对象不会逃逸到方法或线程之外（换句话说是别的方法或线程无法通过任何途径访问到这个对象），或者逃逸程度比较低（只逃逸出方法而不会逃逸出线程），则可能为这个对象实例采取不同程度的优化，如：")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("栈上分配[1]（Stack Allocations）：在Java虚拟机中，Java堆上分配创建对象的内存空间几乎是Java程序员都知道的常识，"),s("strong",[t._v("Java堆中的对象对于各个线程都是共享和可见的")]),t._v("，只要持有这个对象的引用，就可以访问到堆中存储的对象数据。虚拟机的垃圾收集子系统会回收堆中不再使用的对象，但回收动作无论是标记筛选出可回收对象，还是回收和整理内存，都需要耗费大量资源。**如果确定一个对象不会逃逸出线程之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。**在一般应用中，完全不会逃逸的局部对象和不会逃逸出线程的对象所占的比例是很大的，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，垃圾收集子系统的压力将会下降很多。"),s("strong",[t._v("栈上分配可以支持方法逃逸，但不能支持线程逃逸。")])])]),t._v(" "),s("li",[s("p",[t._v("标量替换（Scalar Replacement）：若一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型（int、long等数值类型及reference类型等）都不能再进一步分解了，那么这些数据就可以被称为"),s("strong",[t._v("标量")]),t._v("。相对的，如果一个数据可以继续分解，那它就被称为聚合量（Aggregate），"),s("strong",[t._v("Java中的对象就是典型的聚合量")]),t._v("。如果把一个Java对象拆散，根据程序访问的情况，将其用到的成员变量恢复为原始类型来访问，这个过程就称为标量替换。"),s("strong",[t._v("假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序真正执行的时候将可能不去创建这个对象，而改为直接创建它的若干个被这个方法使用的成员变量来代替。将对象拆分后，除了可以让对象的成员变量在栈上（栈上存储的数据")]),t._v("，很大机会被虚拟机分配至物理机器的高速寄存器中存储）分配和读写之外，还可以为后续进一步的优化手段创建条件。标量替换可以视作栈上分配的一种特例，实现更简单（不用考虑整个对象完整结构的分配），"),s("strong",[t._v("但对逃逸程度的要求更高，它不允许对象逃逸出方法范围内。")])])]),t._v(" "),s("li",[s("p",[t._v("同步消除（Synchronization Elimination）：线程同步本身是一个相对耗时的过程，"),s("strong",[t._v("如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以安全地消除掉。")])])])])]),t._v(" "),s("li",[s("p",[t._v("直到JDK 6，HotSpot才开始支持初步的逃逸分析，而且到现在这项优化技术尚未足够成熟，仍有很大的改进余地。**不成熟的原因主要是逃逸分析的计算成本非常高，甚至不能保证逃逸分析带来的性能收益会高于它的消耗。**如果要百分之百准确地判断一个对象是否会逃逸，需要进行一系列复杂的数据流敏感的过程间分析，才能确定程序各个分支执行时对此对象的影响。前面介绍即时编译、提前编译优劣势时提到了过程间分析这种大压力的分析算法正是即时编译的弱项。可以试想一下，如果逃逸分析完毕后发现几乎找不到几个不逃逸的对象，那这些运行期耗用的时间就白白浪费了，所以目前虚拟机只能采用不那么准确，但时间压力相对较小的算法来完成分析。")])])])])}),[],!1,null,null,null);a.default=v.exports}}]);