(window.webpackJsonp=window.webpackJsonp||[]).push([[207],{761:function(v,a,t){"use strict";t.r(a);var _=t(14),e=Object(_.a)({},(function(){var v=this,a=v.$createElement,t=v._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"熟悉jvm吗-介绍一下运行时内存区划分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#熟悉jvm吗-介绍一下运行时内存区划分"}},[v._v("#")]),v._v(" 熟悉jvm吗？介绍一下运行时内存区划分？")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("虚拟机栈：虚拟机栈是线程私有的一个区域，主要用来存储方法在被调用时创建的栈帧对象，在栈帧中，存储了局部变量表，方法返回地址等信息，每个方法的执行到结束都对应着一个栈帧的入栈和出栈的过程。")])]),v._v(" "),t("li",[t("p",[v._v("本地方法栈：与虚拟机栈不同的是，本地方法栈时为虚拟机使用到的本地native方法服务的，除了这个不同，其他的都和虚拟机栈是一样的。")])]),v._v(" "),t("li",[t("p",[v._v("程序计数器：程序计数器也是线程私有的，程序计数器主要用来指示线程执行到的字节码的位置。程序计数器出现的原因是，在多线程的环境中，当发生了线程的切换时，程序计数器能够保证线程恢复到切换之前的执行位置。")])]),v._v(" "),t("li",[t("p",[v._v("堆：堆是所有线程共享的一块内存区域，主要的作用就是为大部分对象分配内存，而我们所说的垃圾收集也是针对这部分内存区域而言的。根据现在大部分的现代垃圾收集器使用的分代回收理论，堆内存一般被划分为几个区域：新生代和老年代，其实还有个永久代，但在jdk1.8中废除了。对于新生代，通常又被划分为三个区域，分别是Eden区，from Survivor区和to Survivor区。")])]),v._v(" "),t("li",[t("p",[v._v("方法区：俗称非堆，是用来存放类结构信息，字段信息以及方法等信息的。此外，方法区中还存放静态变量和字符串常量池等内容。方法区只是一个概念，在不同的java版本中有不同的实现方式。比如，在jdk1.7之前中，方法区是通过永久代实现的，而永久代位于堆中。在jdk1.8中，永久代被废除，方法区转而通过元空间来实现。元空间位于本地内存，这块区域并不受jvm虚拟机来管理。需要注意的是，对于静态变量和字符串常量池，它们在jdk1.7的时候就已经被移动到堆中了。")])]),v._v(" "),t("li",[t("p",[v._v("直接内存："),t("strong",[v._v("直接内存其实不属于jvm运行时数据区域的一部分")]),v._v("，只不过这部分内存也经常被使用。特别是在java的NIO出现后，直接内存越来越受到重视。java nio中，会分配DirectByteBuffer缓冲区，这里分配的其实就是直接内存，或者说是堆外内存。那为什么在Java NIO中要提供这样一种操作呢？其实，对于我们的io来说，比如文件读写，socket等，都需要先把对象从堆内拷贝到堆外，才能写入Socket或者文件，这里在拷贝数据的过程中，就涉及到了用户态和内核态的转换。而当分配的是堆外内存时，会在java的堆中保存DirectByteBuffer的引用，这样的话，可以使用这个引用操作直接内存，进而避免了一次不必要的内存拷贝和操作系统状态的切换。")])])]),v._v(" "),t("h2",{attrs:{id:"方法区的回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法区的回收"}},[v._v("#")]),v._v(" 方法区的回收？")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("方法区的回收主要面向两部分的内容：常量池中废弃的常量以及不再使用的类。")])]),v._v(" "),t("li",[t("p",[v._v("对于方法区中的废弃常量的回收，也主要包括对字面量和符号引用，符号引用包括类和接口的全限定名，字段的名称和描述以及方法的名称和描述符。对这些废弃常量的回收比较简单，只要常量池中的常量没有被任何地方引用，则可以进行回收。")])]),v._v(" "),t("li",[t("p",[v._v("对于不再使用的类的回收则相对比较复杂，被回收的类需要满足是哪个条件，即：")]),v._v(" "),t("ul",[t("li",[v._v("该类的所有实例都已经被回收了也就是Java堆中不存在该类及其任何子类的实例。")]),v._v(" "),t("li",[v._v("加载该类的类加载器已经被回收。")]),v._v(" "),t("li",[v._v("该类的java.lang.Class对象没有被任何地方被引用，而且无法在任何地方通过反射访问该类的方法。")])])])]),v._v(" "),t("h2",{attrs:{id:"jvm的oom和栈溢出异常"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm的oom和栈溢出异常"}},[v._v("#")]),v._v(" JVM的OOM和栈溢出异常？")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("对于OOM来说，在运行时内存区域中，唯一一个不会造成内存溢出的地方就是程序计数器，其他地方都有可能出现内存溢出的情况。")])]),v._v(" "),t("li",[t("p",[v._v("虚拟机栈：当java虚拟机栈的容量是可以动态扩展时，而栈扩展时又无法申请到足够的内存，此时就会抛出内存溢出异常。")])]),v._v(" "),t("li",[t("p",[v._v("堆：因为堆的大小是可以通过参数设置的，如-Xms可以用来设置初始堆的大小，而-Xmx用来设置堆的最大内存。当创建对象时，如果无法在堆中为对象分配内存，而且堆无法扩展时，就会报出内存溢出异常。")])]),v._v(" "),t("li",[t("p",[v._v("方法区：对于元空间来说，也可以使用-XX:MetaspaceSize和-XX:MaxMetaspaceSize来设置大小，当元空间无法满足新的内存分配时，也会抛出内存溢出异常。")])]),v._v(" "),t("li",[t("p",[v._v("此外，当创建了大量的线程时，也可能报内存溢出异常。")])]),v._v(" "),t("li",[t("p",[v._v("当GC时间太长了，也可能报出内存溢出异常，过长的意思是，当超过98%的时间来进行垃圾收集，但是只回收了不到2%的内存，在这类极端情况下会抛出oom异常。")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);